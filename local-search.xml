<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉树算法合集</title>
    <link href="/2025/01/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <url>/2025/01/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树基本性质"><a href="#二叉树基本性质" class="headerlink" title="二叉树基本性质"></a>二叉树基本性质</h1><p>性质1：在二叉树的第 $i$ 层上至多有 $2^{i-1}$ 个结点（i&gt;&#x3D;1）</p><p>性质2：深度为 $k$ 的二叉树至多有 $2^k-1$ 个结点（k&gt;&#x3D;1）</p><p>性质3：对于任何一颗二叉树T，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0&#x3D;n_2+1$</p><blockquote><p>原理：点数 &#x3D; 边数 + 1</p><p>由 $n &#x3D; n0 + n1 + n2 &#x3D; 2*n2 + n1 + 1$ 得 $n_0&#x3D;n_2+1$</p></blockquote><p>性质4：具有n个节点的<strong>完全二叉树</strong>深为$log_2{k}+1$</p><p>性质5：如果对一颗有n个结点的<strong>完全二叉树</strong>（其深度为$[log_2n]+1$）的结点按层序编号（从第1层到$[log_2n]+1$层，每层从左到右），对任一结点i（1&lt;&#x3D;i&lt;&#x3D;n）:</p><p>（1）如果$i&#x3D;1$，则结点i是二叉树的根，无双亲，如果$i&gt;1$,则其双亲结点是结点$[i&#x2F;2]$<br>（2）如果$2i&gt;n$，则结点i无左孩子（结点i为叶子结点）否则左孩子是结点$2i$。<br>（3）如果$2i+1&gt;n$,则结点i无右孩子，否则其右孩子是结点$2i+1$.</p><blockquote><p>若根节点从0开始，左 &#x3D; $2i + 1$，右 &#x3D; $2i+2$</p></blockquote><h1 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> val;<br>node * l;<br>node * r;<br><br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> val_)&#123;<br>val = val_;<br>        l = <span class="hljs-literal">nullptr</span>;<br>        r = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>先序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>        in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">layerTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br>queue&lt;node *&gt; q;<br>q.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node * f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>layer.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br><br><span class="hljs-keyword">if</span>(f-&gt;l != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;l);<br><span class="hljs-keyword">if</span>(f-&gt;r != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的建树"><a href="#二叉树的建树" class="headerlink" title="二叉树的建树"></a>二叉树的建树</h1><h2 id="T1–已知后序和中序遍历"><a href="#T1–已知后序和中序遍历" class="headerlink" title="T1–已知后序和中序遍历"></a>T1–已知后序和中序遍历</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805349394006016&page=1">1127 ZigZagging on a Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>后序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(postl &gt; postr) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != post[postr]) i++;<br><br>node* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(postl, postl + (i - inl) - <span class="hljs-number">1</span>, inl, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//注意：这里不能改成（r-inl），因为左右子树未必节点数相同</span><br>p-&gt;r = <span class="hljs-built_in">create</span>(postl + (i - inl), postr - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, inr);<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="T2–已知先序和中序遍历"><a href="#T2–已知先序和中序遍历" class="headerlink" title="T2–已知先序和中序遍历"></a>T2–已知先序和中序遍历</h2><blockquote><p>前序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-type">int</span> i = inl;<br>    <span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br>    <br>    node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>    p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br>    p-&gt;r = <span class="hljs-built_in">create</span>(prel + (i-inl) + <span class="hljs-number">1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="T3–已知层序和中序遍历"><a href="#T3–已知层序和中序遍历" class="headerlink" title="T3–已知层序和中序遍历"></a>T3–已知层序和中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> layerl, <span class="hljs-type">int</span> layerr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(layerl &gt; layerr)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != layer[layerl]) i++;<br><br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(layerl<span class="hljs-number">+1</span>, layerl + (i-inl) ,inl, i<span class="hljs-number">-1</span>);<br>p-&gt;r = <span class="hljs-built_in">create</span>(layerl+(i-inl)<span class="hljs-number">+1</span>, layerr, i<span class="hljs-number">+1</span>, inr);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T4–已知先序和后序遍历（不唯一）"><a href="#T4–已知先序和后序遍历（不唯一）" class="headerlink" title="T4–已知先序和后序遍历（不唯一）"></a>T4–已知先序和后序遍历（不唯一）</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805353470869504&page=1">1119 Pre- and Post-order Traversals - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>已知先序和后序遍历可能无法唯一地确定二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-keyword">return</span> p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<span class="hljs-comment">//找到后序遍历倒数第二个点，即右子树的第一个点</span><br><span class="hljs-keyword">if</span>(i - prel - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)&#123; <br>p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//若左子树为空，那么右子树第一个点可能在左子树，也可能在右子树。此处我们将该点放在右子树</span><br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>p-&gt;r = <span class="hljs-built_in">create</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h1 id="序列互转"><a href="#序列互转" class="headerlink" title="序列互转"></a>序列互转</h1><h2 id="任意两种序列-转-其他"><a href="#任意两种序列-转-其他" class="headerlink" title="任意两种序列 转 其他"></a>任意两种序列 转 其他</h2><p>若题目只要求某个遍历序列，可以在建树的过程中，直接生成序列。</p><p>先 + 中 转 后</p><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805345078067200&page=1">1138 Postorder Traversal - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br><span class="hljs-built_in">getPost</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">getPost</span>(prel+(i-inl)<span class="hljs-number">+1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>post.<span class="hljs-built_in">push_back</span>(pre[prel]);<br>&#125;<br></code></pre></td></tr></table></figure><p>先+后 转 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getIn</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(pre[prel] == post[postr])&#123;<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<br><span class="hljs-keyword">if</span>(i - prel &gt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">getIn</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-built_in">getIn</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="先-中-后序-转-层序（完全二叉树）"><a href="#先-中-后序-转-层序（完全二叉树）" class="headerlink" title="先&#x2F;中&#x2F;后序 转 层序（完全二叉树）"></a>先&#x2F;中&#x2F;后序 转 层序（完全二叉树）</h2><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>满二叉树(Full binary tree)：各层 (1~h-1) 的结点数都达到最大个数的二叉树。所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层。</p></blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805407749357568&page=0">1064 Complete Binary Search Tree - PAT (Advanced Level) Practice (pintia.cn)</a>、</p><p>对于一颗完全二叉树&#x2F;满二叉树而言，按层序从上到下，从左到右地标注（root &#x3D; 0），可以得到任意一个节点r，其左孩子为r*2+1，右孩子为 r*2 + 2。可以根据这个性质，将先&#x2F;中&#x2F;后序序列转为层序。</p><p>这里以中序转层序（节点数为n）为例，函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inToLayer</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>layer[r] = in[idx++];<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层序-转-先-中-后序（完全二叉树）"><a href="#层序-转-先-中-后序（完全二叉树）" class="headerlink" title="层序 转  先&#x2F;中&#x2F;后序（完全二叉树）"></a>层序 转  先&#x2F;中&#x2F;后序（完全二叉树）</h2><p>以 层序 转 后序为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>post.<span class="hljs-built_in">push_back</span>(layer[r]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(p-&gt;l),<span class="hljs-built_in">getDepth</span>(p-&gt;r));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的镜像"><a href="#求二叉树的镜像" class="headerlink" title="求二叉树的镜像"></a>求二叉树的镜像</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(p-&gt;l != <span class="hljs-literal">nullptr</span> || p-&gt;r != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">swap</span>(p-&gt;l, p-&gt;r);<br><span class="hljs-built_in">mirror</span>(p-&gt;l);<br><span class="hljs-built_in">mirror</span>(p-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><blockquote><p>定义：一棵空树 或 左右子树的高度差不超过1且左右子树也是平衡树</p></blockquote><p>输入一颗二叉树，判断是否为平衡二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBanlance</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> &amp; depth)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">int</span> ld,rd;<br>    <span class="hljs-comment">//先判断左右子树是否平衡，再判断当前子树，避免重复计算深度</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBanlance</span>(p-&gt;l,ld) &amp;&amp; <span class="hljs-built_in">isBanlance</span>(p-&gt;r,rd))&#123;<br><span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(ld - rd);<br><span class="hljs-keyword">if</span>(diff &lt;= <span class="hljs-number">1</span>)&#123;<br>depth = <span class="hljs-built_in">max</span>(ld,rd) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><blockquote><p>定义：一颗二叉树，所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</p><p>直观理解：从根节点画一条纵轴，左右子树完全沿轴对称</p></blockquote><p>核心思想：左右子树对称 &lt;&#x3D;&gt; 左右根节点相等 &amp;&amp; 左子树的左子树和右子树的右子树对称 &amp;&amp; 左子树的右子树和右子树的左子树对称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSym</span><span class="hljs-params">(node * le, node * ri)</span></span>&#123;<br><span class="hljs-keyword">if</span>(le == <span class="hljs-literal">nullptr</span> &amp;&amp; ri == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(le != <span class="hljs-literal">nullptr</span> &amp;&amp; ri != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">return</span> (le-&gt;x == ri-&gt;x) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;l,ri-&gt;r) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;r,ri-&gt;l);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeSym</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSym</span>(p-&gt;l, p-&gt;r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805359372255232&page=1">1110 Complete Binary Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p></blockquote><p>一颗树是完全二叉树的充要条件是：层序遍历的最大下标等于 n-1 (root &#x3D;&#x3D; 0) </p><blockquote><p>root &#x3D;&#x3D; 1时，层序遍历的最大下标等于 n</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-type">int</span> d = q.<span class="hljs-built_in">front</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br>maxIdx = <span class="hljs-built_in">max</span>(maxIdx,d);<br><span class="hljs-keyword">if</span>(nodes[f].l != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].l,<span class="hljs-number">2</span>*d + <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">if</span>(nodes[f].r != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].r,<span class="hljs-number">2</span>*d + <span class="hljs-number">2</span>&#125;);<br>&#125;<br><span class="hljs-keyword">return</span> maxIdx == n<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h1><blockquote><p>二叉搜索树(Binary Search Tree)：它是一棵空树，或者是具有下列性质的二叉树： </p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； </p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </p><p>左、右子树也分别为二叉排序树。</p></blockquote><p>一个重要性质：二叉搜索树的中序遍历序列是有序上升的。（很多题目中可利用该性质将BST当成普通二叉树来做）</p><h2 id="BST建树"><a href="#BST建树" class="headerlink" title="BST建树"></a>BST建树</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805355987451904&page=1">1115 Counting Nodes in a Binary Search Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node * <span class="hljs-title">insert</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt;= p-&gt;val)&#123; <span class="hljs-comment">//根据不同题目，这里可能是x &gt; p-&gt;val</span><br>p-&gt;r = <span class="hljs-built_in">insert</span>(p-&gt;r, x);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p-&gt;l = <span class="hljs-built_in">insert</span>(p-&gt;l, x);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node * root = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;v[i]; <span class="hljs-comment">//按固定顺序插入的二叉搜索树是唯一的。</span><br>    root = <span class="hljs-built_in">insert</span>(root, v[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BST上LCA"><a href="#BST上LCA" class="headerlink" title="BST上LCA"></a>BST上LCA</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805343727501312&page=1">1143 Lowest Common Ancestor - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>BST上任意两点的最近公共祖先满足条件：$min(u,v) &lt;&#x3D; a &lt;&#x3D; max(u,v)$</p><p>满足这个条件的点是唯一的，是充要条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//沿先序遍历路径找LCA</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-comment">//pre[i] &gt;= min(u,v) &amp;&amp; pre[i] &lt;= max(u,v)</span><br>    <span class="hljs-keyword">if</span>((pre[i] &gt;= u &amp;&amp; pre[i] &lt;= v) || (pre[i] &gt;= v &amp;&amp; pre[i] &lt;= u))&#123;<br>        a = pre[i];<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断某个先序序列是否来自BST"><a href="#判断某个先序序列是否来自BST" class="headerlink" title="判断某个先序序列是否来自BST"></a>判断某个先序序列是否来自BST</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805440976633856&page=0">1043 Is It a Binary Search Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>法1：按该先序序列逐个插入节点，建立BST，与正确的先序序列比较。</p><p>法2：直接在先序序列上判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于二叉搜索树的先序遍历的序列而言</span><br><span class="hljs-comment">//头节点一定为根节点，而左右子树的根，在该序列中的距离一定为1</span><br><span class="hljs-comment">//由此规律可构造的平衡树的节点个数一定是n个</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> j = r;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &lt; pre[l]) i++;<span class="hljs-comment">//第一个 &gt;= root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &gt;= pre[l]) j--;<span class="hljs-comment">//最后一个 &lt; root的节点</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &gt;= pre[l]) i++;<span class="hljs-comment">//第一个 &lt; root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &lt; pre[l]) j--;<span class="hljs-comment">//最后一个 &gt;= root的节点</span><br>&#125;<br><span class="hljs-keyword">if</span>(i - j != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">getPost</span>(l<span class="hljs-number">+1</span>, j);<br><span class="hljs-built_in">getPost</span>(i, r);<br>post.<span class="hljs-built_in">push_back</span>(pre[l]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉搜索树AVL"><a href="#平衡二叉搜索树AVL" class="headerlink" title="平衡二叉搜索树AVL"></a>平衡二叉搜索树AVL</h1><blockquote><p>AVL树的名字来源于它的发明作者G.M. <strong>A</strong>delson-<strong>V</strong>elsky 和 E.M. <strong>L</strong>andis。</p><p>AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree, 简称平衡二叉树）</p><p>将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。</p></blockquote><p>每次查找AVL树中的元素，耗时O（logN）</p><p>AVL树满足以下两个条件：</p><blockquote><p>条件一：它必须是二叉查找树。</p><p>条件二：每个节点的左子树和右子树的高度差至多为1。</p></blockquote><h2 id="AVL建树"><a href="#AVL建树" class="headerlink" title="AVL建树"></a>AVL建树</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805351302414336&page=1">1123 Is It a Complete AVL Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><h1 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805347921805312&page=1">1130 Infix Expression - PAT (Advanced Level) Practice (pintia.cn)</a></p><img src="二叉树算法合集.assets/4d1c4a98-33cc-45ff-820f-c548845681ba.jpeg" alt="infix1.JPG" align = "left" /><blockquote><p>二叉运算树的中序遍历，恰是一个中缀表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">inTra</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>string le = <span class="hljs-built_in">inTra</span>(tree[p].l);<br>string ri = <span class="hljs-built_in">inTra</span>(tree[p].r);<br><span class="hljs-keyword">if</span>((le != <span class="hljs-string">&quot;&quot;</span> || ri != <span class="hljs-string">&quot;&quot;</span>) &amp;&amp; p != root)&#123; <span class="hljs-comment">//若非根节点p，存在孩子，需要加上括号</span><br>le = <span class="hljs-string">&quot;(&quot;</span> + le;<br>ri = ri + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> le + tree[p].s + ri;<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">inTra</span>(root);<br></code></pre></td></tr></table></figure><h1 id="最近公共祖先LCA"><a href="#最近公共祖先LCA" class="headerlink" title="最近公共祖先LCA"></a>最近公共祖先LCA</h1><p>参考BLOG：</p><p><a href="https://www.jvruo.com/archives/629/#comments">【蒟蒻图论】三种算法解决LCA - 蒟蒻のBLOG (jvruo.com)</a></p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><blockquote><p>在“Lowest Common Ancestor”中，“lowest”的含义与常规理解有些不同，</p><p>指的是最深的公共祖先，而不是最接近树根的节点。</p></blockquote><blockquote><p>LCA适用于多叉树（有向无环图），而不仅仅是二叉树。</p></blockquote><img src="二叉树算法合集.assets/3030388996.png" align = "left" alt="LCA2.png" style="zoom:70%;" /><h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><p><a href="https://shawnliang.wiki/post/lca-binary-lifting/">LCA算法之倍增法 - Shawn’s algorithm notes (shawnliang.wiki)</a></p><p>倍增是用的最多的LCA<strong>在线</strong>算法，其复杂度为 $O(nlogn+mlogn)$ [n为点数，m为询问数]</p><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1038430130011897856&page=1">1151 LCA in a Binary Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>前序+中序建树  + 二叉树上LCA </p><p>坑点：题目没说给出的序列值是在下标1~N范围内，MAX &#x3D; N会段错误</p></blockquote><p><code>depth</code>和<code>fa</code>预处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br>depth[x] = depth[f] + <span class="hljs-number">1</span>;<br>fa[x][<span class="hljs-number">0</span>] = f;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; (<span class="hljs-number">1</span>&lt;&lt;i) &lt;= depth[x] ; i ++)&#123;<br>fa[x][i] = fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != f)&#123;<br><span class="hljs-built_in">dfs</span>(it, x);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><code>log2(x)</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) lg[i]--;<br></code></pre></td></tr></table></figure><p><code>lca(a, b)</code>：a和b两点最短公共祖先</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">//将两个节点跳到同一深度</span><br><span class="hljs-keyword">if</span>(depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a,b);<br><span class="hljs-keyword">while</span>(depth[a] != depth[b])&#123;<br>a = fa[a][lg[depth[a] - depth[b]]];<br>&#125;<br><span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-comment">//逐步倍增到LCA前一位置：即a和b的父亲相等</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = lg[depth[a]] ; k &gt;= <span class="hljs-number">0</span> ; k --)&#123;<br><span class="hljs-keyword">if</span>(fa[a][k] != fa[b][k])&#123;<br>a = fa[a][k];<br>b = fa[b][k];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉序-ST表"><a href="#欧拉序-ST表" class="headerlink" title="欧拉序 + ST表"></a>欧拉序 + ST表</h2><h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><p><a href="https://www.cnblogs.com/JVxie/p/4854719.html">最近公共祖先LCA(Tarjan算法)的思考和算法实现 - JVxie - 博客园 (cnblogs.com)</a></p><p>Tarjan是求解LCA唯一的<strong>离线</strong>算法，其时间复杂度达到了$O(n+m)$。</p><p>Tarjan的基本逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span>从根节点开始进行<span class="hljs-built_in">DFS</span> (设当前遍历到节点u，其子节点为v);<br><span class="hljs-number">2.</span>若u还存在没访问过的子节点，继续遍历，否则进行操作<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>；<br><span class="hljs-number">3.</span>将u标记为”访问过“<br><span class="hljs-number">4.</span>在并查集中，将v合并到u上,并标记节点v已被访问过；<br><span class="hljs-number">5.</span>寻找与当前点u有询问关系的点x，若点x已经被访问过，那么lca（u,x）= <span class="hljs-built_in">find</span>(u)；<br></code></pre></td></tr></table></figure><p>Tarjan函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it] &amp;&amp; it != f)&#123;<br><span class="hljs-built_in">tarjan</span>(it, x);<br><span class="hljs-built_in">join</span>(x, it);<br>&#125;<br>&#125;<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; it : q[x])&#123;<br><span class="hljs-type">int</span> t = it.first;<br><span class="hljs-type">int</span> i = it.second;<br><span class="hljs-keyword">if</span>(visited[t])&#123;<br>ans[i] = <span class="hljs-built_in">find</span>(t);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>询问关系的存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q[MAX];<br><span class="hljs-comment">//first - 端点 ；second - 下标 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;<br>    q[u].<span class="hljs-built_in">push_back</span>(&#123;v,i&#125;);<br>    q[v].<span class="hljs-built_in">push_back</span>(&#123;u,i&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最优二叉查找树"><a href="#最优二叉查找树" class="headerlink" title="最优二叉查找树"></a>最优二叉查找树</h1><p><a href="https://pintia.cn/problem-sets/1844196541682872320/exam/problems/type/7?problemSetProblemId=1844196541703843844&page=0">7-5 最优二叉查找树 - 练习3-2 (pintia.cn)</a></p><p>假设 一颗 查找树 上的每个点（深度为 c ）都有一个查找概率p，那么我们可以得到查找次数的期望：<br>$$<br>E(c) &#x3D; \sum_{i}^{n} c_i*p_i<br>$$<br>最优二叉查找树 指的是 使得查找次数期望最小 的 二叉查找树。</p><p>设C（i，j）为以i为左端点，j为右端点的二叉树的查找期望代价。</p><p>我们可以得到如下的状态转移方程：<br>$$<br>\begin{cases}<br>C[i][j] &#x3D; 0 &amp; i &gt; j \<br>C[i][j] &#x3D; P_i &amp; i &#x3D; j \<br>C[i][j] &#x3D; min( C[i][k-1] + C[k+1][j] + \sum_{i}^{j} P ) ) &amp; else \<br>\end{cases}<br>$$<br>在得到c[i][j]数组的同时，我们需要可以记录一下，取最小值时候的根k，得到R[i][j]数组，以构造查找树。</p><p>动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//处理坐标为x，y的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">// int root = 0;</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x ; i &lt;= y ; i ++)&#123;<br>sum += c[i][i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = x ; k &lt;= y ; k ++)&#123;<br><span class="hljs-keyword">if</span>(sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y] &lt; res)&#123;<br>res = sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y];<br><span class="hljs-comment">// root = k;</span><br>&#125;<br>&#125;<br>c[x][y] = res;<br><span class="hljs-comment">// r[x][y] = root;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按主对角线方向进行dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-type">double</span> p;cin&gt;&gt;p;<br>    c[i][i] = p*<span class="hljs-number">10000</span>; <span class="hljs-comment">// 这题要求输出结果x10000后的数值</span><br>    r[i][i] = i;<br>&#125;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>,y = <span class="hljs-number">2</span>,cnt = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>( !( x == <span class="hljs-number">1</span> &amp;&amp; y == n) )&#123;<br>    <span class="hljs-built_in">dp</span>(x, y);<br>    x++;y++;<br>    <span class="hljs-keyword">if</span>(y &gt; n)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = ++cnt;<br>    &#125;<br>&#125;<span class="hljs-built_in">dp</span>(x, y);<br>cout&lt;&lt;c[<span class="hljs-number">1</span>][n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2025/01/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2025/01/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>属性：<br>pre[]：记录每个结点的先驱结点<br>size[]：记录当前结点所属集合的大小<br>count：记录连通分量的个数<br>方法：<br>查找代表元（find）：查找当前结点所属集合的代表元，树形结构，我们可以通过pre逐层向上查找，一直找到根节点即为当前集合的代表元。<br>（这里的代表元就是一个集合中的代表元素，如果两个元素的代表元相同，则这两个元素属于同一集合）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p>合并（connect）：合并两个结点，我们通过pre[y]&#x3D;x，将y结点连接到x上，这里我们为了减少find函数的迭代次数，我们总是把小的集合连接到大的集合上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询（isconnect）：判断两个结点是否属于同一集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><p>断开连接（disconnect）：将当前结点断开与其上层节点的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        pre[x] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre;<br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count = n;<br>        pre.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            pre[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        pre[x] = x;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre[MAX],n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy) pre[fx] = fy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;t;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-type">int</span> z,x,y;<br>cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">if</span>(z == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Union</span>(x,y);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)?<span class="hljs-string">&quot;Y&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>)&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>康托展开</title>
    <link href="/2025/01/12/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <url>/2025/01/12/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><p>康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。<br>$$<br>X&#x3D;a[n]<em>(n-1)!+a[n-1]</em>(n-2)!+…+a[i]*(i-1)!+…+a[1]*0!<br>$$<br>其中, a[i]为整数，并且0 &lt;&#x3D; a[i] &lt;&#x3D; i, 0 &lt;&#x3D; i &lt; n, 表示当前未出现的的元素中排第几个，这就是康托展开</p><p>举个例子说明。<br>在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。</p><p>首位是3，则小于3的数有两个，为1和2，a[5]&#x3D;2，则首位小于3的所有排列组合为 a[5]*(5-1)!<br>第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]&#x3D;2<br>第三位是1，则在其之后小于1的数有0个，所以a[3]&#x3D;0<br>第四位是5，则在其之后小于5的数有1个，为2，所以a[2]&#x3D;1<br>最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0<br>根据公式：<br>X &#x3D; 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! &#x3D; 2 * 24 + 2 * 6 + 1 &#x3D; 61<br>所以比 34152 小的组合有61个，即34152是排第62。</p><h1 id="八数码难题（BFS剪枝）"><a href="#八数码难题（BFS剪枝）" class="headerlink" title="八数码难题（BFS剪枝）"></a>八数码难题（BFS剪枝）</h1><p><a href="https://www.luogu.com.cn/problem/P1379">P1379 八数码难题 - 洛谷 | 计算机科学教育新生态</a></p><p>在 3×3 的棋盘上，摆有八个棋子，每个棋子上标有 1 至 8 的某一数字。棋盘中留有一个空格，空格用 0 来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局 和 目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 状态结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> x,y,steps;<br><span class="hljs-type">int</span> ctVal;<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>&#125;;<br><br><span class="hljs-comment">// 0-10的阶乘</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> f[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-comment">// 某个排列是否出现过</span><br><span class="hljs-type">bool</span> visct[<span class="hljs-number">10000000</span>];<br><span class="hljs-comment">// 起点和终点</span><br>string s,t;<br><span class="hljs-type">int</span> tt;<br><br><span class="hljs-comment">// 康托展开</span><br><span class="hljs-comment">// 即将 某个排列 映射 到 某个数字（第几个排列）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>vis[s[i]-<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; s[i] - <span class="hljs-string">&#x27;0&#x27;</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[j]) low++;<br>&#125;<br>res += f[cnt--]*low;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;node&gt; q;<br><span class="hljs-comment">// 初始化起点</span><br>node temp;<br>temp.steps = <span class="hljs-number">0</span>;<br>temp.ctVal = <span class="hljs-built_in">cantor</span>(s);<br>visct[temp.ctVal] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>temp.a[i][j] = s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>temp.x = i;<br>temp.y = j;<br>&#125;<br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(temp);<br><br>tt = <span class="hljs-built_in">cantor</span>(<span class="hljs-string">&quot;123804765&quot;</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node fr = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 如果找到，退出</span><br><span class="hljs-keyword">if</span>(fr.ctVal == tt)&#123;<br>cout&lt;&lt;fr.steps;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>node nex; string str;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br>nex.x = fr.x + dirx[i];<br>nex.y = fr.y + diry[i];<br><span class="hljs-keyword">if</span>(!(nex.x &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.x &lt;= <span class="hljs-number">3</span> &amp;&amp; nex.y &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.y &lt;= <span class="hljs-number">3</span>)) <span class="hljs-keyword">continue</span>;<br>nex.steps = fr.steps + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memcpy</span>(nex.a,fr.a,<span class="hljs-built_in">sizeof</span>(nex.a));<br><span class="hljs-built_in">swap</span>(nex.a[fr.x][fr.y],nex.a[nex.x][nex.y]);<br>str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>str += <span class="hljs-built_in">char</span>(nex.a[i][j] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br>nex.ctVal = <span class="hljs-built_in">cantor</span>(str);<br><span class="hljs-comment">// 如果康托展开值重复，说明之前出现过更优解</span><br><span class="hljs-keyword">if</span>(!visct[nex.ctVal])&#123;<br>q.<span class="hljs-built_in">push</span>(nex);<br>visct[nex.ctVal] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛</title>
    <link href="/2025/01/12/%E8%B4%A8%E6%95%B0%E7%AD%9B/"/>
    <url>/2025/01/12/%E8%B4%A8%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h1><blockquote><p>暴力枚举法， 一般在查询很少的时候使用</p></blockquote><p>判断一个数 n 是否为质数的时间复杂度为$O(\sqrt{n})$</p><p>若询问m次，时间复杂度为 $O(m\sqrt{n})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= x ; i ++)&#123;<br><span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h1><blockquote><p>Eratosthenes 筛法（埃拉托斯特尼筛法，简称埃氏筛法。</p></blockquote><p>建立一个&lt;&#x3D;n的$O(1)$查询表的时间复杂度是$O(nloglogn)$</p><p>原理：对于任意一个大于1的正整数 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="n">，那么它的x倍就是非素数。如果从小到大遍历每个数，同时把当前数的所有倍数记为非素数，那么运行结束的时候没有被标记的数就是素数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= n ; i ++)&#123; <br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i ; j &lt;= n ; j += i)&#123;<span class="hljs-comment">//注意这里可以从i*i开始</span><br>isPrime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h1><blockquote><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。</p><p>而欧拉筛法保证了一个合数只被最小的素因数标记，达到了线性的时间复杂度</p></blockquote><p>建立一个&lt;&#x3D;n的$O(1)$查询表的时间复杂度是$O(n)$</p><p>原理：从小到大遍历每个数，记录&lt;&#x3D; i的非素数，将它们与 i 的乘积（&lt;&#x3D;n）标记为非素数，若i % it &#x3D;&#x3D; 0，则直接break，因为后面还会有更大倍数标记这个乘积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    vector&lt;<span class="hljs-type">int</span> &gt; pri;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br>pri.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : pri)&#123;<br><span class="hljs-keyword">if</span>(i*it &gt; n) <span class="hljs-keyword">break</span>;<br>isPrime[i*it] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(i % it == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//关键</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2024-国赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-大家一起查作弊字符串处理">RC-u1大家一起查作弊（字符串处理）</h1><blockquote><p>分数 15 作者 DAI, Longao 单位 杭州百腾教育科技有限公司</p></blockquote><p>在今年的睿抗比赛上，有同学的提交代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">asfiasfgwef12</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> tsadflas=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> masf11233=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span>[]wasdf1213= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> +<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] vasf124l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> + I];<br><span class="hljs-type">int</span>[][] ddasf1234p= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[masf11233<br>...<br></code></pre></td></tr></table></figure><p>你肯定很奇怪，这看上去代码似乎不像是正常写出来的代码呀？没错，这是这位同学在网络上购买了所谓的“保研综测套餐”，商家为逃避赛后查重，给这位同学发去了经过混淆的代码。然而经过技术支持方的努力，这位同学不仅被封禁，与TA购买了相同“套餐”的同学也利用技术手段全部查出，目前主办方已向警方报案，这些同学的“保研”梦很有可能会转变为“案底”梦……因此如果你在比赛前也购买了类似的服务，现在迷途知返还来得及——毕竟这个商家起码还做了一些努力，许多商家号称“一对一”，实际上将一份代码发给了数十位同学……</p><p>回到题目，虽然具体检查的手段无法公开，但我们可以尝试简化再简化的手段来找到被这样混淆的程序。对于给定的大量字符串，你首先要提取出所有的<strong>关键词</strong>。一个<strong>关键词</strong>的定义是：由大写字母、小写字母、数字组成的字符串，并且前后均为非大小写字母及数字（包含开头及换行符）。如以下的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] vasf124l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> + I];<br></code></pre></td></tr></table></figure><p>关键词为：<code>int</code>、<code>vasf124l</code>、<code>new</code>、<code>int</code>、<code>10</code>以及<code>I</code>。</p><p>然后对于所有关键词，你需要计算<strong>可疑分数</strong>的和以及关键词平均长度。其中一个关键词的<strong>可疑分数</strong>如下定义：</p><ul><li>如果一个关键词同时包含大写字母、小写字母、数字，则分数 + 5 分；</li><li>否则，如同时包含（大写字母、数字）或（小写字母、数字）的，分数 + 3分；</li><li>否则，如同时包含（大写字母、小写字母）的，分数 + 1 分；</li><li>其余情况不加分。</li></ul><p>对于给定的数据，请你输出所有关键词的<strong>可疑分数</strong>的和、长度的和以及数量。</p><h3 id="输入格式">输入格式</h3><p>输入包含若干行字符串，表示待检测的程序。保证每行字符串的长度不超过1000（除了一行最后的换行符外），输入总长度不超过6×104，并且至少有一个关键词。</p><h3 id="输出格式">输出格式</h3><p>对于输入的所有字符串，第一行输出可疑分数的和，第二行输出关键词的总长度以及关键词的个数（以避免计算平均值带来的浮点误差），用一个空格隔开。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs in">static void nnmMNBkf3kfa()&#123;<br>    int fefvB4=2;<br>    int [][]fsdk9A=new int[fefvB4][fefvB4];<br>    fsdk9A[0][0]=1;<br>    for (int gfdgsUB3 = 0; gfdgsUB3 &lt; fefvB4; gfdgsUB3++) &#123;<br>        for (int fdnbXZ8 = 0; fdnbXZ8&lt;fefvB4-gfdgsUB3-1; fdnbXZ8++) &#123;<br>            fsdk9A[gfdgsUB3][fdnbXZ8+1]=fsdk9A[gfdgsUB3][fdnbXZ8]+gfdgsUB3+fdnbXZ8+2;<br>            fsdk9A[gfdgsUB3+1][fdnbXZ8]=fsdk9A[gfdgsUB3][fdnbXZ8]+gfdgsUB3+fdnbXZ8+1;<br>            break;<br>        &#125;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">155<br>276 54<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><blockquote><p>比赛时用getline一直卡样例，后来用cin才过，不知道什么原因：)</p></blockquote><p>Step1：依次读入每个字符串，按非数字/字母字符进行分割。</p><p>Step2：计算每个字符串的得分，并统计。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string str;<br><span class="hljs-type">int</span> ans,lens,sum;<br>vector&lt;string&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">while</span>(i &lt; len)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s[i]) != <span class="hljs-number">4</span>)&#123;<br><span class="hljs-type">int</span> j = i;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">judge</span>(s[j]) != <span class="hljs-number">4</span>)&#123;<br>res = res + s[j];<br>j++;<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(res); <br>i = j;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">bool</span> f1 = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> f2 = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> f3 = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">1</span>) f1 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">2</span>) f2 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">3</span>) f3 = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; f2 &amp;&amp; f3) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>((f1 || f2) &amp;&amp; f3) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; f2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;str)&#123;<br>str = <span class="hljs-string">&quot; &quot;</span> + str + <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">process</span>(str);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>ans += <span class="hljs-built_in">getScore</span>(it);<br>lens += it.<span class="hljs-built_in">length</span>();<br>sum += <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>cout&lt;&lt;lens&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="rc-u2-谁进线下了ii模拟">RC-u2 谁进线下了？II（模拟）</h1><blockquote><p>分数 20 作者 DAI, Longao 单位 杭州百腾教育科技有限公司</p></blockquote><p><em>Xepa Legends</em>是一个第一人称射击类大逃杀（“吃鸡”）游戏，每局游戏共有 20 支 3人小队参加，最后获胜的队伍被称为“捍卫者”。</p><p>最近 <em>Xepa Legends</em> 举行了亚太地区南赛区的线上比赛，争夺 7个前往德国曼海姆参加线下赛的资格，国内共有 14支队伍参与到了其中。因为比赛十分激烈，直到最后谁进了线下仍有巨大的疑问。小K 喜欢的国内知名战队 <em>DreamTear</em>因其队内选手<em>杀马特</em>表现不佳，正好卡在出线分数前后，请你赶紧帮帮小K，计算一下最后的分数情况，看看他喜欢的战队出线了没有吧！</p><p><em>Xepa Legends</em> 的常规赛共有 30 支队伍参加，被分为三组，进行<em>N</em> 轮比赛，每轮由三组中的两组组成 20支队伍的参赛阵容，进行若干场比赛，最后每个队伍会获得一个当轮比赛的排名。</p><p>对于每轮比赛，队伍会根据排名获得一个在当轮比赛的<strong>赋分</strong>：</p><table><thead><tr><th>排名</th><th>分数</th></tr></thead><tbody><tr><td>第一名</td><td>25 分</td></tr><tr><td>第二名</td><td>21 分</td></tr><tr><td>第三名</td><td>18 分</td></tr><tr><td>第四名</td><td>16 分</td></tr><tr><td>第五名</td><td>15 分</td></tr><tr><td>第六名</td><td>14 分</td></tr><tr><td>第七名</td><td>13 分</td></tr><tr><td>第八名</td><td>12 分</td></tr><tr><td>第九名</td><td>11 分</td></tr><tr><td>第十名</td><td>10 分</td></tr><tr><td>第十一名</td><td>9 分</td></tr><tr><td>第十二名</td><td>8 分</td></tr><tr><td>第十三名</td><td>7 分</td></tr><tr><td>第十四名</td><td>6 分</td></tr><tr><td>第十五名</td><td>5 分</td></tr><tr><td>第十六名</td><td>4 分</td></tr><tr><td>第十七名</td><td>3 分</td></tr><tr><td>第十八名</td><td>2 分</td></tr><tr><td>第十九名</td><td>1 分</td></tr><tr><td>第二十名</td><td>0 分</td></tr></tbody></table><p>给定若干轮比赛队伍获得的当轮比赛排名，请你计算出队伍的赋分，并在若干轮比赛后计算出总赋分，从而最终确定<em>DreamTear</em> 战队能否进入线下，还是只能耍耍花招了。</p><p>例如，</p><ul><li><em>DreamTear</em> 战队在第一轮比赛中获得了第 17名，第三轮比赛中获得了第 11 名，第四轮比赛中获得了第 11 名，那么<em>DreamTear</em> 战队可获 3 + 9 + 9 = 21 分的赋分；</li><li><em>KV</em> 战队在第一轮比赛中获得了第 10 名，第三轮比赛中获得了第 2名，第四轮比赛中获得了第 6 名，那么他们可获得 10 + 21 + 14 = 45分的赋分。</li></ul><p><em>注：本题与实际情况无关，所有比赛规则、队伍、队员名称均为虚构。</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (≤20)，表示有 <em>N</em>轮比赛。</p><p>接下来有 <em>N</em>部分输入，每部分是一轮比赛的情况。对每一场比赛，信息共分 20 行，第<em>i</em> 行（<em>i</em>=1,⋯,20）给出的两个非负整数 <em>c</em> 和<em>p</em> 表示编号为 <em>c</em> 的队伍在这轮比赛里获得了第 <em>p</em>名。</p><p>数据保证所有给定的情况中，排名永远大于等于 1 且小于等于20，队伍编号由 1 开始，不超过 30。</p><h3 id="输出格式-1">输出格式</h3><p>输出若干行，按分数从大到小依次输出队伍的编号及该队所有轮次游戏结束后的总分。如分数相同，队伍编号较小的先输出。</p><p>注意由于统计的时候比赛可能并没有完全结束，所以每个队伍参加的比赛轮数不一定相同，此时仍然正常计分统计即可。不要输出未参赛的队伍分数。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>1 1<br>2 2<br>9 3<br>6 4<br>7 5<br>11 6<br>3 7<br>13 8<br>8 9<br>16 10<br>4 11<br>19 12<br>17 13<br>5 14<br>12 15<br>15 16<br>14 17<br>10 18<br>20 19<br>18 20<br>5 11<br>10 12<br>30 13<br>22 14<br>1 1<br>28 20<br>21 16<br>26 17<br>2 2<br>24 3<br>4 4<br>29 5<br>8 6<br>7 15<br>6 7<br>3 8<br>9 9<br>25 10<br>23 19<br>27 18<br>19 20<br>26 19<br>27 18<br>18 17<br>21 16<br>12 15<br>28 14<br>20 13<br>17 12<br>14 11<br>13 10<br>23 9<br>29 8<br>22 7<br>30 6<br>15 5<br>24 4<br>25 3<br>16 2<br>11 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs out">1 50<br>2 42<br>11 39<br>24 34<br>16 31<br>6 29<br>9 29<br>25 28<br>29 27<br>3 25<br>4 25<br>8 25<br>13 22<br>30 21<br>7 20<br>15 19<br>22 19<br>5 15<br>17 15<br>14 12<br>23 12<br>10 10<br>12 10<br>19 8<br>20 8<br>21 8<br>28 6<br>26 4<br>27 4<br>18 3<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>依题意构造出team结构体，进行排序并输出。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">team</span>&#123;<br><span class="hljs-type">int</span> score;<br><span class="hljs-type">int</span> id;<br><br><span class="hljs-built_in">team</span>(<span class="hljs-type">int</span> score_,<span class="hljs-type">int</span> id_)&#123;<br>score = score_;<br>id = id_;<br>&#125;;<br><br><span class="hljs-built_in">team</span>()&#123;<br>score = <span class="hljs-number">0</span>;<br>id = <span class="hljs-number">-1</span>;<br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(team a, team b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.score != b.score) <span class="hljs-keyword">return</span> a.score &gt; b.score;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><br>vector&lt;team&gt; v;<br>team te[MAX];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> sco[<span class="hljs-number">21</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">18</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">20</span> ; j ++)&#123;<br><span class="hljs-type">int</span> c,p;cin&gt;&gt;c&gt;&gt;p;<br>te[c].id = c;<br>te[c].score += sco[p];<br>len = <span class="hljs-built_in">max</span>(c,len);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(te[i].id != <span class="hljs-number">-1</span>)&#123;<br>v.<span class="hljs-built_in">push_back</span>(te[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<br><span class="hljs-type">int</span> lenv = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lenv ; i ++)&#123;<br>cout&lt;&lt;v[i].id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[i].score&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-势均力敌dfs">RC-u3 势均力敌（DFS）</h1><blockquote><p>分数 25 作者 陈越 单位 浙江大学</p></blockquote><p>用 <em>n</em>&gt;2 个不同的个位数字组成一个 <em>n</em> 位数，显然有<em>n</em>! 个不同的结果。可以证明，这 <em>n</em>!个数字可以被分为<strong>势均力敌</strong>的两组 ——即平方和相等、且个数也相等的两组。 本题就请你用程序验证一下这个结论。因为本题是一道简单题，所以规模很小，只考虑 <em>n</em>≤4 的情况。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行给出正整数 <em>n</em>（2&lt;<em>n</em>≤4），随后一行给出<em>n</em> 个不同的、在区间 [1, 9] 内的个位数字，其间以空格分隔。</p><h3 id="输出格式-2">输出格式</h3><p>将所有组成的 <em>n</em>! 个不同的 <em>n</em>位数分为平方和相等、且个数也相等的两组。但你只需要输出其中一组就可以了。每个数字占一行，共输出<em>n</em>!/2 行。 注意：解可能不唯一，输出任何一组解就可以。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5 2 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">125<br>512<br>251<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>依题n&lt;=4，数据量较小，可用DFS枚举。</p><p>Step1：枚举出所有可能的数字。</p><p>Step2：枚举所有可能的分组，找到第一种可行解后输出。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,string s)</span></span>&#123; <span class="hljs-comment">//枚举出所有可能的数字</span><br><span class="hljs-keyword">if</span>(dep == n)&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br>res = res*<span class="hljs-number">10</span> + (it - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(res);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i])&#123;<br>vis[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(dep + <span class="hljs-number">1</span>, s + <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + a[i]));<br>vis[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> sum1, <span class="hljs-type">int</span> sum2)</span></span>&#123; <span class="hljs-comment">//枚举所有可能的分组</span><br><span class="hljs-keyword">if</span>(dep == (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">if</span>(sum1 == sum2)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : temp)&#123;<br>cout&lt;&lt;it&lt;&lt;endl;<br>&#125;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>temp.<span class="hljs-built_in">push_back</span>(v[dep]);<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>,sum1 + v[dep]*v[dep],sum2);<br>temp.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>,sum1,sum2 + v[dep]*v[dep]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-city-不-citydijkstra">RC-u4 City 不 City（Dijkstra）</h1><blockquote><p>分数 30 作者 陈越 单位 浙江大学</p></blockquote><p>“City 不 City”因为一位外国友人保保熊直播旅游时总是用奇怪的腔调说“好city，啊！”而走红中国社交网络，成为网络热梗。事实上，有一些叛逆的年轻人在旅行时会刻意避开网红打卡点，选择一些小众的特色地方小城镇，不追求city，而喜欢说“好 country，啊”。下面给定各个城镇的旅游热度和城镇间的旅行花销，请你为前来咨询的旅行者规划一条最经济的路线，并且尽可能避开热度很高的网红点。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行首先给出 4 个正整数：<em>n</em> 和<em>m</em>（1&lt;<em>n</em>≤103，1≤<em>m</em>≤5<em>n</em>），依次为城镇数量（于是城镇编号从1 到 <em>n</em>）和城镇间的通路条数；<em>s</em> 和 <em>t</em>依次为旅行者的出发地和目的地的城镇编号。 随后一行给出 <em>n</em>个不超过 100 的正整数，依次为 <em>n</em> 个城镇的旅游热度。 再后面是<em>m</em>行，每行给出一条通路连接的两个城镇的编号、这条通路的最小花销（其数值为不超过103 的正整数）。通路是双向的，题目保证任一对城镇间至多给出一条通路。同一行的数字间均以空格分隔。</p><h3 id="输出格式-3">输出格式</h3><p>题目要求从 <em>s</em> 到 <em>t</em>的最小花销路线；若这样的路线不唯一，则取<strong>途径</strong>城镇的最高旅游热度值最小的那条路线。在一行中输出从 <em>s</em> 到 <em>t</em>的最小花销、以及途经城镇的最高旅游热度值（若没有途经的城镇，则热度值为0）。数值间以 1 个空格分隔，行首尾不得有多余空格。 若从 <em>s</em>根本走不到 <em>t</em>，则在一行中输出 <code>Impossible</code>。</p><h3 id="输入样例-1-1">输入样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs in">8 14 7 8<br>100 20 30 10 50 80 100 100<br>7 1 1<br>7 2 2<br>7 3 1<br>7 4 2<br>1 2 1<br>1 5 2<br>2 5 1<br>3 4 1<br>3 5 3<br>3 6 2<br>4 6 1<br>5 6 1<br>5 8 1<br>6 8 2<br></code></pre></td></tr></table></figure><h3 id="输出样例-1-1">输出样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4 50<br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p>从 7 到 8 的最短路径有 3 条，其中 2 条都经过城镇1，于是对应的最高旅游热度值是城镇 1 的热度值 100。解路径为7-&gt;2-&gt;5-&gt;8，途径城镇 2 和 5，对应的最高旅游热度值是城镇 5的热度值50。在最短路径长度相等的情况下，取热度值小的解，故输出的热度值为50。</p><h3 id="输入样例-2-1">输入样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">3 1 1 2<br>10 20 30<br>1 3 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-2-1">输出样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">Impossible<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>本题是多权值的单源最短路问题，考虑使用Dijkstra来做。</p><p>需要更新路径的条件为：</p><p>A. 新路径比老路径更短</p><p>B. 新路径和老路径一样长，但是途径点的最大热度更小</p><blockquote><p>Dijkstra状态转移方程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>&gt;dist[j] = dist[f] + edge[f][j];<br>&gt;val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&gt;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j] &amp;&amp; val[j] &gt; <span class="hljs-built_in">max</span>(val[f],w[j]))&#123;<br>&gt;dist[j] = dist[f] + edge[f][j];<br>&gt;val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,m,s,t;<br><span class="hljs-type">int</span> w[MAX];<br><span class="hljs-type">int</span> edge[MAX][MAX];<span class="hljs-comment">// n &lt;= 1000, 用邻接矩阵即可</span><br><span class="hljs-type">int</span> val[MAX],dist[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i];<br><span class="hljs-keyword">if</span>(edge[s][i] != INF) val[i] = w[i];<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j] &amp;&amp; val[j] &gt; <span class="hljs-built_in">max</span>(val[f],w[j]))&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>&#125;<br>w[s] = w[t] = <span class="hljs-number">0</span>; <span class="hljs-comment">//依题意，不考虑起点和终点的热度</span><br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-built_in">memset</span>(val,INF,<span class="hljs-built_in">sizeof</span>(val));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>edge[a][b] = c;<br>edge[b][a] = c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-keyword">if</span>(dist[t] == INF)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Impossible&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[t]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;val[t];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-贪心消消乐">RC-u5 贪心消消乐</h1><blockquote><p>分数 30 作者 陈越 单位 浙江大学</p></blockquote><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/a607e42e-9f51-43a1-b430-0ca9f3e99e74.jpg" class="" title="f1.jpg"><p>“消消乐”是以消去方块赢取分数的游戏。这里介绍一种超级简单的玩法：玩家每次按住并拖动鼠标，在屏幕上划出一个矩形，则矩形内的方块就被消去，玩家得到所有被消去的方块的分数之和。每个方块上的小动物对应不同的得分，例如消去上图中的绿色青蛙得 2分、消去紫色猫头鹰得 5 分、消去黄色小鸡得 9 分、消去蓝色小牛得 1分、消去红色狐狸得 3 分、消去棕色小熊得 8分。有些方块是冰块，消去冰块会被扣分，所以冰块上标注了负分。有些方块是黑洞，玩家的矩形内不能包含任何黑洞，否则所有分数都被黑洞吸走。在一个矩形被消去后，其上方的方块会掉落以填补空缺，而多出的空缺被黑洞填补。本题请你帮助玩家实现一个基于贪心策略的自动消除程序，每次都争取获得最多的分数，直到无法继续获得更多的分数。</p><h3 id="输入格式-4">输入格式</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出一个不超过 100的正整数 <em>N</em>，对应正方形游戏屏幕的高度和宽度。随后 <em>N</em>行，每行给出 <em>N</em> 个数字，代表对应方块的分数，其中黑洞用 0表示，小动物用正整数分表示，冰块用负整数分表示。数值均在 [−100,100]区间内。</p><h3 id="输出格式-4">输出格式</h3><p>每一步的消除策略占一行，格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-built_in">x1</span>, y1) (<span class="hljs-built_in">x2</span>, y2) 得分<br></code></pre></td></tr></table></figure><p>其中 <code>(x1, y1)</code>为矩形左上角的横纵坐标，<code>(x2, y2)</code>为矩形右下角的横纵坐标，<code>得分</code>为消去这个矩形的得分。这里我们将游戏屏幕的左上角坐标定义为(1,1)，右下角坐标定义为 (<em>N</em>,<em>N</em>)。 最后一行给出总分。注意：当有多个矩形同时对应最大得分时，优先选择 <code>x1</code>最小的；如果 <code>x1</code> 一样，则优先选择 <code>y1</code>最小的；如果 <code>y1</code> 也一样，则优先选择 <code>x2</code>最小的；如果 <code>x2</code> 还是一样，则优先选择 <code>y2</code>最小的。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">4<br>0 2 5 0<br>9 2 -6 2<br>-4 1 -4 3<br>-1 8 0 -2<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs out">(1, 2) (2, 4) 15<br>(3, 1) (3, 1) 5<br>(4, 2) (4, 3) 5<br>(2, 4) (2, 4) 2<br>27<br></code></pre></td></tr></table></figure><h3 id="样例解释-1">样例解释</h3><p>游戏的初始界面如题面所示。消去过程如下： <img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/5c78dd3c-b9c3-47cf-bd31-957a3b3476ff.jpg" class="" title="f2.jpg"><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/28536b9d-440b-4421-8bdc-3fd97bff6023.jpg" class="" title="f3.jpg"> <img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/a38050b9-c411-4e06-b0ef-c6fa9b9a26e4.jpg" class="" title="f4.jpg"></p><h3 id="解法-4">解法</h3><h3 id="代码-4">代码</h3><blockquote><p>以后补：）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2024-省赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-热热热">RC-u1 热҈热҈热҈</h1><p>热҈热҈热҈……最近热得打的字都出汗了！</p><p>幸好某连锁餐厅开启了气温大于等于 35度即可获得一杯免费雪碧的活动。但不知为何，在每个星期四的时候，这个活动会暂停一天……</p><p>现在给定连续的若干天的气温情况以及给定的第一天是星期几，请你算出有多少天你可以喝到免费的雪碧，又有多少天是因为星期四而导致你喝不到雪碧的。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>, <em>W</em>(1≤<em>N</em>≤50,1≤<em>W</em>≤7)，表示给定连续的 <em>N</em>天，下面给定的第一天是星期 <em>W</em>（7 等于星期天）。</p><p>接下来的一行给出 <em>N</em> 个用一个空格隔开的、小于 60 的整数，第<em>i</em> 个数表示第 <em>i</em> 天的温度。保证温度大于等于 -273度。</p><h3 id="输出格式">输出格式</h3><p>输出两个数，第一个是你能喝到免费雪碧的天数，第二个是你本来能喝到免费雪碧、但因为是星期四而无法喝到的天数。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">15 3<br>33 35 34 36 37 40 32 31 30 29 28 29 33 38 40<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">5 1<br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,d;<br><span class="hljs-type">int</span> sum,res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">35</span> &amp;&amp; d != <span class="hljs-number">4</span>) sum++;<br><span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">35</span> &amp;&amp; d == <span class="hljs-number">4</span>) res++;<br><span class="hljs-keyword">if</span>(d + <span class="hljs-number">1</span> == <span class="hljs-number">8</span>) d = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> d++;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-谁进线下了">RC-u2 谁进线下了？</h1><p><em>Xepa Legends</em>是一个第一人称射击类大逃杀（“吃鸡”）游戏，每轮游戏共有 20 支 3人小队参加，最后获胜的队伍被称为“捍卫者”。</p><p>最近 <em>Xepa Legends</em> 举行了亚太地区南赛区的线上比赛，争夺 7个前往德国曼海姆参加线下赛的资格，国内共有 14支队伍参与到了其中。因为比赛十分激烈，直到最后谁进了线下仍有巨大的疑问。小K 喜欢的国内知名战队 DreamTear因其队内选手<em>杀马特</em>表现不佳，正好卡在出线分数前后，请你赶紧帮帮小K，计算一下最后的分数情况，看看他喜欢的战队出线了没有吧！</p><p><em>Xepa Legends</em> 的比赛共进行 <em>N</em>场游戏，在每场游戏中，每支队伍在游戏中会获得一个排名和一个杀敌数（击败其他队伍玩家的数量），一支队伍在一场游戏的得分为<strong>杀敌数+排名分</strong>，排名分由队伍当场的排名根据以下表格求得：</p><table><thead><tr><th>排名</th><th>分数</th></tr></thead><tbody><tr><td>第一名</td><td>12 分</td></tr><tr><td>第二名</td><td>9 分</td></tr><tr><td>第三名</td><td>7 分</td></tr><tr><td>第四名</td><td>5 分</td></tr><tr><td>第五名</td><td>4 分</td></tr><tr><td>第六名至第七名</td><td>3 分</td></tr><tr><td>第八名至第十名</td><td>2 分</td></tr><tr><td>第十一名至第十五名</td><td>1 分</td></tr><tr><td>第十六名至第二十名</td><td>0 分</td></tr></tbody></table><p>例如，</p><ul><li><em>DreamTear</em> 战队在第三场比赛获得了第三名、有 6个杀敌数，那么他们将获得 7 + 6 = 13 分；</li><li><em>KV</em> 战队在第二场比赛获得了第 19 名、有 1个杀敌数，那么他们将获得 0 + 1 = 1 分；</li><li><em>SRN</em> 战队在第四场比赛获得了第 1 名、有 9个杀敌数，那么他们将获得 12 + 9 = 21 分。</li></ul><p><em>注：本题与实际情况无关，所有比赛规则、队伍、队员名称均为虚构。</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (≤20)，表示有 <em>N</em>场比赛。</p><p>接下来有 <em>N</em>部分输入，每部分是一场比赛的情况。对每一场比赛，信息共分 20 行，第<em>i</em> 行（<em>i</em>=1,⋯,20）给出的两个非负整数 <em>p</em> 和<em>k</em> 表示第 <em>i</em> 支队伍在这场比赛里获得了第 <em>p</em>名、杀敌数为 <em>k</em>。</p><p>数据保证所有给定的情况中，排名永远大于等于 1 且小于等于20，杀敌数小于等于 57。</p><h3 id="输出格式-1">输出格式</h3><p>输出 20行，按编号从小到大依次输出队伍的编号及该队全部游戏结束时的总分。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>6 2<br>7 3<br>11 5<br>10 1<br>2 9<br>5 8<br>14 3<br>4 3<br>1 6<br>18 1<br>12 1<br>20 0<br>13 0<br>3 2<br>16 4<br>8 1<br>19 0<br>9 4<br>17 1<br>15 0<br>8 2<br>19 1<br>12 2<br>1 9<br>10 1<br>7 5<br>18 0<br>14 0<br>5 2<br>4 4<br>2 5<br>6 2<br>16 3<br>13 1<br>20 0<br>3 7<br>9 3<br>15 0<br>17 5<br>11 3<br>18 0<br>5 2<br>2 9<br>9 4<br>4 7<br>10 3<br>16 0<br>1 6<br>20 0<br>15 1<br>6 0<br>3 6<br>14 3<br>7 4<br>19 0<br>17 0<br>8 9<br>11 0<br>13 5<br>12 0<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs out">1 9<br>2 13<br>3 27<br>4 30<br>5 33<br>6 25<br>7 4<br>8 27<br>9 24<br>10 12<br>11 19<br>12 18<br>13 8<br>14 18<br>15 4<br>16 17<br>17 16<br>18 8<br>19 12<br>20 6<br></code></pre></td></tr></table></figure><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> sco[<span class="hljs-number">21</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">6</span> &amp;&amp; r &lt;= <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">8</span> &amp;&amp; r &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">11</span> &amp;&amp; r &lt;= <span class="hljs-number">15</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">20</span> ; j ++)&#123;<br><span class="hljs-type">int</span> p,k;cin&gt;&gt;p&gt;&gt;k;<br>sco[j] += <span class="hljs-built_in">getScore</span>(p);<br>sco[j] += k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">20</span> ; i ++)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sco[i]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-暖炉与水豚模拟">RC-u3 暖炉与水豚（模拟）</h1><p>PapiCon（<span class="citation"data-cites="PapilloteContet">@PapilloteContet</span>）出了许多有意思的谜题，其中有一道关于水豚的谜题是这样的：</p><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2024-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/92d6785e-10a2-4673-af83-e2aaad99de57.jpeg" class="" title="GGwLLL_bwAA8cC4.jpeg"><p><em>来源：x.com/PapilloteContet</em></p><p>在一个 <em>N</em>×<em>M</em>的矩阵中有若干水豚以及暖炉，暖炉可以辐射以它自身为中心的 3×3范围里的水豚，使其变得暖呼呼的。谜题里存在一只冷的要命的水豚，你需要移动其中的一个暖炉，使所有水豚都变得暖呼呼的。</p><p>在往下读题前，如果你有兴趣的话，不妨思考一下如何解答这个谜题。（思考结果与题目无关，可跳过。）</p><p>这个谜题的关键在于，单纯从图中能看到的暖炉来说是无解的，但如果注意到，第3 行第 6列的水豚明明周围没有暖炉，却也处于暖呼呼的状态，就能推测出来图中的那个对话框挡住了一个暖炉，只要移动这个暖炉就可以完成题目的要求。</p><p>现在我们将谜题一般化，对于给定的一个 <em>N</em>×<em>M</em>的矩阵、对应的所有水豚状态、以及<strong>能看到的</strong>暖炉摆放情况，已知最多只有一只水豚的状态不太对劲（周围没有暖炉却暖呼呼的），你需要推测有哪些格子<strong>可能</strong>藏了暖炉。一个空格<strong>可能</strong>藏了暖炉可以理解为：当前空格设置暖炉后整个矩阵的状态会从不合法变为合法。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>, <em>M</em>(1≤<em>N</em>,<em>M</em>≤1000)，表示矩阵的大小。</p><p>接下来的 <em>N</em> 行，每行有 <em>M</em> 个字符，第 <em>i</em>行的第 <em>j</em> 个字符表示矩阵中对应位置的状态，其中：</p><ul><li><code>.</code> 表示空格（或者说，看上去是空格的格子）；</li><li><code>c</code> 表示很冷的水豚；</li><li><code>w</code> 表示暖呼呼的水豚；</li><li><code>m</code> 表示暖炉。</li></ul><h3 id="输出格式-2">输出格式</h3><p>输出若干行，每行两个正整数 <em>r</em> 和 <em>c</em>，表示第<em>r</em> 行第 <em>c</em> 列有可能藏了一个暖炉，有多个可能时，先按<em>r</em> 从小到大输出，<em>r</em> 相同时再按 <em>c</em>从小到大输出。如果没有一个格子可能藏了暖炉，则在一行中输出<code>Too cold!</code>。 行与列均从 1 开始编号。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8<br>wm....mw<br>.w..ww..<br>..wm.wwm<br>w.w....w<br>.m.c.m..<br>w.....w.<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">2 7<br>3 5<br>4 6<br>4 7<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>Step1：找到不合法的豚鼠：温暖，但是没被暖炉照到</p><p>Step2：找到该豚鼠周围，所有可放置暖炉的位置，并判断是否合法</p><p>Step3：存储所有暖炉的合法位置，逐个输出</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> a[MAX][MAX];<br><span class="hljs-type">bool</span> isWarm[MAX][MAX];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">putLight</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//放下暖炉后温暖9格区域</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br>isWarm[nx][ny] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//放置的暖炉是否合法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br><span class="hljs-keyword">if</span>(a[nx][ny] == <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//找到所有可放置暖炉的位置并判断</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br><span class="hljs-keyword">if</span>(a[nx][ny] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; <span class="hljs-built_in">judge</span>(nx,ny))&#123;<br>ans.<span class="hljs-built_in">push_back</span>(&#123;nx,ny&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-string">&#x27;m&#x27;</span>) <span class="hljs-built_in">putLight</span>(i,j);<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//找到不合法的豚鼠：温暖，但是没被暖炉照到</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-string">&#x27;w&#x27;</span> &amp;&amp; !isWarm[i][j])&#123;<br><span class="hljs-built_in">findPos</span>(i,j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Too cold!&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;it.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.second&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-章鱼图的判断并查集bfs">RC-u4章鱼图的判断（并查集+BFS）</h1><p>对于无向图<em>G</em>=(<em>V</em>,<em>E</em>)，我们将有且只有一个环的、大于 2个顶点的无向连通图称之为<strong>章鱼图</strong>，因为其形状像是一个环（身体）带着若干个树（触手），故得名。</p><p>给定一个无向图，请你判断是不是只有一个章鱼子图存在。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是一个正整数 <em>T</em>(1≤<em>T</em>≤5)，表示数据的组数。</p><p>每组数据的第一行是两个正整数 <em>N</em>,<em>M</em>(1≤<em>N</em>,<em>M</em>≤105)，表示给定的无向图有 <em>N</em>个点，<em>M</em> 条边。</p><p>接下来的 <em>M</em>行，每行给出一条边两个端点的顶点编号。注意：顶点编号从 1开始，并且题目保证任何边不会重复给出，且没有自环。</p><h3 id="输出格式-3">输出格式</h3><p>对于每组数据，如果给定的图里只有一个章鱼子图，则在一行中输出<code>Yes</code> 和章鱼子图环的大小（及环中顶点数），其间以 1个空格分隔。</p><p>否则，则在一行中输出 <code>No</code> 和图中章鱼子图的个数，其间以 1个空格分隔。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>1 2<br>2 4<br>2 6<br>3 8<br>9 10<br>1 9<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>9 1<br>1 2<br>2 4<br>4 8<br>8 10<br>10 1<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>9 1<br>2 4<br>4 8<br>8 10<br>10 2<br>10 6<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes 5<br>No 0<br>No 2<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><blockquote><p>题中说的“章鱼子图”，实际上是：“是章鱼图的连通分量”</p><p>如果出现两个环，要么有两张章鱼子图，要么原图不是章鱼子图，一定不符合题目条件</p></blockquote><p>Step1：并查集求每个连通分量的环的个数，并记录环的两个端点</p><p>Step2：BFS求环的长度</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m,t;<br><span class="hljs-type">int</span> r1,r2; <span class="hljs-comment">//环的两个端点</span><br><span class="hljs-type">int</span> pre[MAX],cnt[MAX],d[MAX]; <span class="hljs-comment">//cnt -- 连通子图 i 内环的个数</span><br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == pre[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<span class="hljs-comment">//给两个端点，求环的长度</span><br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[f])&#123;<br><span class="hljs-keyword">if</span>(!visited[it])&#123;<br><span class="hljs-keyword">if</span>(it == t &amp;&amp; f == s) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//切断环的两个端点之边</span><br>d[it] = d[f] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(it);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[t]<span class="hljs-number">+1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>e[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>e[a].<span class="hljs-built_in">push_back</span>(b);<br>e[b].<span class="hljs-built_in">push_back</span>(a);<br><br><span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(a);<br><span class="hljs-type">int</span> fb = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-keyword">if</span>(fa == fb)&#123; <span class="hljs-comment">//若已经连通的两点之间，存在一条边，那么存在环</span><br>cnt[fb]++;<br>r1 = a;<br>r2 = b;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//合并</span><br>pre[fa] = fb;<br>cnt[fb] += cnt[fa];<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i) == i &amp;&amp; cnt[i] == <span class="hljs-number">1</span>)&#123;<br>sum++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sum == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes &quot;</span>&lt;&lt;<span class="hljs-built_in">bfs</span>(r1,r2)&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;No &quot;</span>&lt;&lt;sum&lt;&lt;endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-工作安排01背包">RC-u5 工作安排（01背包）</h1><p>小 K 有 <em>N</em> 项工作等待完成，第 <em>i</em> 项工作需要花 *t**i*单位时间，必须在 *d**i* 时刻或之前完成，报酬为 *p**i*。假设小 K工作时刻从 0开始，且同一时刻只能做一项工作、工作一旦开始则不可中断或切换至其他工作，请你帮小K 规划一下如何选择合适的工作，使小 K 可以获得最多的报酬。</p><h3 id="输入格式-4">输入格式</h3><p>输入第一行是一个正整数 <em>T</em> (≤5)，表示数据的组数。</p><p>接下来有 <em>T</em> 组数据，每组数据第一行是一个正整数 <em>N</em>(≤5000)，表示待完成工作的数量。接下来的 <em>N</em> 行，每行三个非负整数<em>t<strong>i<em>、</em>d</strong>i</em>、*p**i* (均≤5000；1≤<em>i</em>≤<em>N</em>)，表示第 <em>i</em>项工作需要花费的时间、截止时间以及报酬。</p><h3 id="输出格式-4">输出格式</h3><p>对于每组数据，输出小 K 能获得最多的报酬是多少。</p><h3 id="输入样例-4">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5<br>1 2 50<br>3 3 100<br>1 5 1<br>3 2 5000<br>4 5 30<br>5<br>1 2 50<br>3 3 20<br>1 5 1<br>3 2 5000<br>4 5 30<br>5<br>1 2 50<br>3 3 100<br>1 5 1<br>3 2 5000<br>5 5 800<br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">101<br>80<br>800<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>状态转移方程：<span class="math inline">\(dp[j] = max(dp[j], dp[t -ta[i].d] + ta[i].p)\)</span></p><blockquote><p>dp[j] : 到达时间j时，能做获得的最大报酬</p><p>ta[i].d：任务i的截止时间</p><p>ta[i].p：任务i的报酬</p></blockquote><p>与普通的01背包不同的地方在于，</p><p>这题为每个任务规定的能采用的时间上限，即：截止时间 - 任务时间，</p><p>因此，为了保证每个任务都在优化的考虑范围内，需要根据截止时间对任务进行排序。</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5050</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>&#123;<br><span class="hljs-type">int</span> t,d,p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> task &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> d &lt; rhs.d;<br>&#125;<br>&#125;ta[MAX];<br><br><span class="hljs-type">int</span> t,n;<br><span class="hljs-type">int</span> dp[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;ta[i].t&gt;&gt;ta[i].d&gt;&gt;ta[i].p;<br>&#125;<br><span class="hljs-built_in">sort</span>(ta,ta+n);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = ta[i].d ; j &gt;= ta[i].t ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j - ta[i].t] + ta[i].p);<br>ans = <span class="hljs-built_in">max</span>(dp[j],ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2023-省赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2023-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2023-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-亚运奖牌榜模拟">RC-u1 亚运奖牌榜（模拟）</h1><p>2022 年第 19届亚运会即将在杭州召开，杭州已经做好准备欢迎全亚洲的观众一同参与亚运盛会了！</p><p>你正在开发一款跟亚运奖牌计算相关的App。给定两个国家的获奖情况，你的任务是计算这两个国家/地区的奖牌情况，并确定哪个国家/地区要排在奖牌榜的前面。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (1≤<em>N</em>≤1000)，表示总共有<em>N</em> 条获奖记录。</p><p>接下来的每一行都是形如以下的一条记录：</p><p><em>C<strong>i<em>,</em>P</strong>i</em></p><p>其中 <em>C<strong>i<em>=0,1，0 表示是第一个国家/地区，1表示是第二个国家/地区；</em>P</strong>i</em>=1,2,3，1 表示金牌，2表示银牌，3 表示铜牌。</p><h3 id="输出格式">输出格式</h3><p>首先输出两行，第一行是第一个国家/地区的金牌、银牌、铜牌获得数，用空格隔开；第二行是第二个国家/地区的奖牌获奖情况，要求与格式同第一个国家/地区。</p><p>最后一行，如果是第一个国家/地区排在前面，输出<code>The first win!</code>，否则输出 <code>The second win!</code>。</p><p>排在前面的定义是：先比较金牌数，金牌数较大的排在前面；如金牌数相等，比较银牌数，银牌数较大的在前面；如金牌银牌数都相等，则比较铜牌数，铜牌数较大的在前面。</p><p>保证数据不存在奖牌数完全相同的情况。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs in">15<br>0 1<br>0 2<br>0 3<br>0 1<br>0 1<br>0 2<br>0 3<br>1 3<br>1 3<br>1 3<br>1 3<br>1 2<br>1 1<br>1 1<br>1 1<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">3 2 2<br>3 1 4<br>The first win!<br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> type[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] != type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] != type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> c,p;<br>cin&gt;&gt;c&gt;&gt;p;<br>type[c][p]++;<br>&#125;<br>cout&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]&lt;&lt;endl;<br>cout&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]&lt;&lt;endl;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) cout&lt;&lt;<span class="hljs-string">&quot;The first win!&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;The second win!&quot;</span>&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-出院字符串处理">RC-u2 出院（字符串处理）</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>：最近出了一个饮料营养等级你们知道吗？例如无糖的饮料是 <span class="hljs-selector-tag">A</span> 级，可乐是 D 级……<br><span class="hljs-selector-tag">B</span>：那……无糖可乐是什么级别？<br>C：AD 级吧。<br><span class="hljs-selector-tag">A</span>：出院！<br><span class="hljs-selector-tag">B</span>：出什么院，你也给我进去！<br></code></pre></td></tr></table></figure><p>以上是某群中一段有趣的对话。请你按照里面的逻辑，在已知某些饮料的等级的情况下，给饮料定级。定级的方法是：</p><ul><li>如果是已知等级的饮料，直接输出等级；</li><li>对于一个新饮料的名字，你需要将名字拆成两个已知等级的部分，然后输出这个级别。例如：Diet是A，Coke是D，那么DietCoke就是AD；</li><li>如果新饮料无法拆解或者有多种拆解方法，统一定为 D 级。</li></ul><h3 id="输入格式-1">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>,<em>M</em>(1≤<em>N</em>,<em>M</em>≤100)，表示已知的饮料有 <em>N</em>种，需要定级的饮料有 <em>M</em> 种。</p><p>接下来首先是 <em>N</em>行，每行是一个字符串和一个字符，表示一种饮料的名字和对应的等级，等级只有<em>A</em>,<em>B</em>,<em>C</em>,<em>D</em> 四种。</p><p>然后是 <em>M</em>行，每行是一个字符串，表示需要定级的饮料的名字。</p><p>所有饮料名字只包含有大小写字母，长度不超过30，给定拥有等级的饮料的名字不会重复。</p><h3 id="输出格式-1">输出格式</h3><p>对于每一个需要定级的饮料，输出定好的定级。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">5 6<br>Diet A<br>LowSugarTea B<br>Milk C<br>Coke D<br>Water A<br>DietCoke<br>Pepsi<br>Milk<br>CokeWater<br>GoodMilk<br>dietCoke<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">AD<br>D<br>C<br>DA<br>D<br>D<br></code></pre></td></tr></table></figure><p><strong>题目引用自睿抗机器人开发者大赛真题（2023年）。</strong></p><h3 id="解法">解法</h3><p>使用哈希表（unordered_map）映射饮料名-&gt;饮料类型。</p><p>按两种情况讨论，如果直接存在该饮料，输出名字即可；</p><p>如果不存在，寻找有多少种组合（2种，饮料名可复用），为1种时输出复合名称，否则输出D。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string,string&gt; mp;<br><span class="hljs-type">int</span> n,m,cnt;<br>string res;<br>vector&lt;string&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>string name,type;<br>cin&gt;&gt;name&gt;&gt;type;<br>v.<span class="hljs-built_in">push_back</span>(name);<br>mp[name] = type;<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>string s;cin&gt;&gt;s;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s) != <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;mp[s]&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] + v[j] == s)&#123;<br>res = mp[v[i]] + mp[v[j]];<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;D&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-骰子游戏dfs">RC-u3 骰子游戏（DFS）</h1><p>在某个游戏中有一个骰子游戏。在游戏中，你需要投掷 5个标准六面骰子（骰子为一个正方体，6个面上分别有1、2、3、4、5、6中的一个数字，骰子的质量均匀），投出的点数根据组合会获得一个“获胜等级”。获胜等级从高到低如下：</p><ul><li>五个同点数 - 五个骰子显示相同的点数</li><li>四个同点数 - 四个骰子显示相同的点数</li><li>葫芦 - 一对和一个三个同点数（如1、1、3、3、3）</li><li>六高顺子 - 投出的点数为 2、3、4、5、6</li><li>五高顺子 - 投出的点数为 1、2、3、4、5</li><li>三个同点数 - 三个骰子显示相同的点数（如1、1、1、2、3）</li><li>两对 - 投出的点数中有两对是相同的（如 1、1、2、2、3）</li><li>一对 - 投出的点数有一对是相同的（如 1、1、2、3、4）</li><li>无 - 除去以上的其他情况</li></ul><p>给定你已经投出的一次结果，现在假设你可以选择任意个骰子重投一次，请问怎么样操作，才能最大化在重骰后获得更好的获胜等级的概率呢？</p><p>注意：更好的获胜等级需要严格地比当前的获胜等级更好，例如1、1、2、2、3 如果重骰后变为 1、1、3、3、4并不比当前的获胜等级更好。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行是一个正整数 <em>T</em>(1≤<em>T</em>≤10)，表示接下来有多少组数据。 每组数据只有一行 5个数字，表示第一次投出的 5 个骰子的点数。</p><h3 id="输出格式-2">输出格式</h3><p>对于每组数据输出三个整数，其中第一个整数为为了获得最大的概率需要重新骰几个骰子，后面的两个整数为重骰骰子后概率的最简分数，其中第二个整数为分子，第三个整数为分母。如果分子为0，分母为 1。</p><p>如果有多种获得最大概率的情况，取重骰的骰子数最少的方案。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>1 1 2 2 3<br>1 1 2 3 4<br>1 1 1 2 3<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">3 4 9<br>3 13 18<br>2 4 9<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>这题的数据较小，使用二重DFS来搜索每一种情况</p><p>首先枚举可能选择的骰子数量cnt</p><p>dfs1 ---- 搜索可能重投的位置（例如：cnt =2时，可能选择1，2，也可能选2，3等等）</p><p>dfs2 ---- 在dfs1的基础上，搜索重投后所有可能的情况。</p><p>最后使用辗转相除法求最大公约数，来简化分子分母。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">//存储选择的骰子位置</span><br><span class="hljs-type">int</span> t,cnt,type;<br><span class="hljs-type">int</span> resCases,cases,total; <span class="hljs-comment">//正在计算的事件总数，</span><br><span class="hljs-type">int</span> ans1,ans2,ans3; <span class="hljs-comment">//最优解</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> (y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y,x%y));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> t[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br>t[i] = a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(t,t<span class="hljs-number">+5</span>);<br><span class="hljs-comment">//五个同点数 9</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;<br><span class="hljs-comment">//四个同点数 8</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>&#125;<br><span class="hljs-comment">//葫芦 7</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;<br><span class="hljs-comment">//六高顺子 6</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> &amp;&amp; t[<span class="hljs-number">1</span>] == <span class="hljs-number">3</span> &amp;&amp; t[<span class="hljs-number">2</span>] == <span class="hljs-number">4</span> &amp;&amp; t[<span class="hljs-number">3</span>] == <span class="hljs-number">5</span> &amp;&amp; t[<span class="hljs-number">4</span>] == <span class="hljs-number">6</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>&#125;<br><span class="hljs-comment">//五高顺子 5 </span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; t[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span> &amp;&amp; t[<span class="hljs-number">2</span>] == <span class="hljs-number">3</span> &amp;&amp; t[<span class="hljs-number">3</span>] == <span class="hljs-number">4</span> &amp;&amp; t[<span class="hljs-number">4</span>] == <span class="hljs-number">5</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">//三个同点数 4</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-comment">//两对 3</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-comment">//一对 2</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] || t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] || t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] || t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//无 1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == cnt)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getType</span>() &gt; type)&#123;<br>cases++;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-type">int</span> tep = a[v[dep]];<br>a[v[dep]] = i;<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>);<br>a[v[dep]] = tep;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == cnt)&#123;<br>cases = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//计算cases</span><br><span class="hljs-type">int</span> sum = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>,cnt);<br><span class="hljs-keyword">if</span>(cases*total &gt;= resCases*sum)&#123;<br>resCases = cases;<br>total = sum;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>vis[i] = <span class="hljs-literal">true</span>;<br>v.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs1</span>(dep<span class="hljs-number">+1</span>);<br>vis[i] = <span class="hljs-literal">false</span>;<br>v.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>        <br>type = <span class="hljs-built_in">getType</span>();<br>ans1 = ans2 = <span class="hljs-number">0</span>;<br>ans3 = <span class="hljs-number">1</span>;<br>vector&lt;<span class="hljs-type">int</span> &gt; tep;<span class="hljs-comment">//所有可能的重投数</span><br><span class="hljs-keyword">if</span>(type == <span class="hljs-number">9</span>) tep = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">else</span> tep = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : tep)&#123; <span class="hljs-comment">//枚举选择几个骰子</span><br>cnt = it;<br>resCases = <span class="hljs-number">0</span>;<br>total = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//计算resCases</span><br><span class="hljs-keyword">if</span>(resCases*ans3 &gt;= ans2*total)&#123;<br>ans1 = cnt;<br>ans2 = resCases;<br>ans3 = total;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans2/<span class="hljs-built_in">gcd</span>(ans2,ans3)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans3/<span class="hljs-built_in">gcd</span>(ans2,ans3)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-相对论大师dfs剪枝">RC-u4 相对论大师（DFS剪枝）</h1><p>在某个直播间里，观众常常会发送类似这样的弹幕：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">鱼越大，鱼刺越大；鱼刺越大，肉越少；肉越少，鱼越小；所以鱼越大，鱼越小<br></code></pre></td></tr></table></figure><p>这样通过一连串推导得出一个搞笑的结论的弹幕发送者被称为“相对论大师”。</p><p>现在给定一系列已有的推论，请你从给定的推论中挑选一些，组成一条类似于上面的弹幕，成为一名“相对论大师”。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤1000），表示总共有多少条推论。</p><p>接下来的 <em>N</em> 行，每行有两对四个元素，形如下：</p><p><code>A 0 B 1</code> 每对元素表示一个论点：第一个是一个长度不大于 5的、只包含大小写字母的字符串，称为论点的核心；第二个数字固定为 0 或者1，代表论点核心的方向属性。为简单理解，你可以将 0 理解为正面方向，1理解为负面方向。例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">YuCi</span> <span class="hljs-number">0</span> Rou <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>就可以理解为<code>鱼刺大，肉少</code> 。</p><p>于是一行中的两个论点就形成一条推论，表示第一个核心某个方向的属性能推出第二个核心的某个方向的属性，即<code>鱼刺越大，肉越少</code>。</p><h3 id="输出格式-3">输出格式</h3><p>按照弹幕格式输出一行，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Yu</span> <span class="hljs-number">0</span> YuCi <span class="hljs-number">0</span> YuCi <span class="hljs-number">0</span> Rou <span class="hljs-number">1</span> Rou <span class="hljs-number">1</span> Yu <span class="hljs-number">1</span> = Yu <span class="hljs-number">0</span> Yu <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>具体格式要求为：在一行中输出从起始论点到最终论点的所有推论，论点格式与输入相同，论点间以1个空格分隔。随后输出等号（等号前后均有1个空格），最后是相互矛盾的起始和终止论点。</p><p>如果有多种方案，选择使用推论最少的；推论条数相同的输出任意一种方案均可。</p><p>在方案中每条推论仅可使用一次。保证有解，且给定的推论中没有相同的推论。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5<br>Yu 0 Yuci 0<br>Rou 1 Yu 1<br>Yuci 0 Rou 1<br>Yuci 0 Gutou 0<br>Gutou 0 Rou 0<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">Yu 0 Yuci 0 Yuci 0 Rou 1 Rou 1 Yu 1 = Yu 0 Yu 1<br></code></pre></td></tr></table></figure><h3 id="提示">提示</h3><p>本题返回结果若为<strong>格式错误</strong>均可视为<strong>答案错误</strong>。</p><h3 id="解法-2">解法</h3><p>使用DFS递归搜索所有的组合，</p><p>在组合时，需要判断当前字符串是否合法，进行剪枝。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">order</span>&#123;<br>string s1,s2;<br><span class="hljs-type">bool</span> f1,f2;<br>&#125;orders[MAX];<br><br>vector&lt;<span class="hljs-type">int</span> &gt; ans,res;<br>string sts;<br><span class="hljs-type">bool</span> stf;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>sts = orders[i].s1;<br>stf = orders[i].f1;<br>res.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>);<br>res.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(dep &gt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!ans.<span class="hljs-built_in">empty</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &gt; ans.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">int</span> b = res.<span class="hljs-built_in">back</span>();<br><span class="hljs-keyword">if</span>(sts == orders[b].s2 &amp;&amp; !(stf == orders[b].f2) )&#123;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>() || res.<span class="hljs-built_in">size</span>() &lt; ans.<span class="hljs-built_in">size</span>())&#123;<br>ans = res;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(orders[i].s1 == orders[b].s2 &amp;&amp; orders[i].f1 == orders[b].f2)&#123;<br>res.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>);<br>res.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;orders[i].s1&gt;&gt;orders[i].f1&gt;&gt;orders[i].s2&gt;&gt;orders[i].f2;<br>&#125;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;orders[it].s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].f1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].s2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].f2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-type">int</span> fr = ans.<span class="hljs-built_in">front</span>();<br><span class="hljs-type">int</span> ba = ans.<span class="hljs-built_in">back</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;= &quot;</span>&lt;&lt;orders[fr].s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[fr].f1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[ba].s2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[ba].f2&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-相对成功与相对失败最长不下降子序列">RC-u5相对成功与相对失败（最长不下降子序列）</h1><p><em>注意：题面内容表达纯属娱乐，与现实无关！</em></p><p>网上常有人说：看 XX只能度过一个相对成功/失败的人生。不妨假设把这个句式套用在“参加睿抗比赛“以及“玩手机游戏”上，那么有：</p><ul><li>“参加睿抗比赛”必然比“不参加睿抗比赛”要成功；</li><li>“玩手机游戏“必然比“不玩手机游戏”要失败。</li></ul><p>现在有 <em>N</em>个人，已知这些人自己填写的是否参加了睿抗比赛以及是否玩手机游戏的情况，以及他们实际上的成功程度的排序顺序，请问最少有多少人在填写情况时说谎了？</p><h3 id="输入格式-4">输入格式</h3><p>输出第一行为一个正整数 <em>T</em>(1≤<em>T</em>≤5)，表示数据组数。</p><p>每组数据第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤105)，表示总共的人数。</p><p>接下来的 <em>N</em> 行，第 <em>i</em> 行有两个数字<em>A<strong>i<em>,</em>B</strong>i</em>，表示第 <em>i</em>位参赛选手是否参加了睿抗比赛以及是否玩手机游戏，0 为没有参加/没有玩，1为参加了/玩了。</p><p>最后一行有 <em>N</em> 个数，为一个选手编号 1 到 <em>N</em>的排列，表示选手成功程度的排序。排序顺序从最成功到最失败。</p><p>选手编号从 1 开始。</p><h3 id="输出格式-4">输出格式</h3><p>对于每组数据，输出一个整数，表示最少的说谎人数。</p><h3 id="输入样例-4">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5<br>1 0<br>1 0<br>0 0<br>0 0<br>0 1<br>1 2 3 4 5<br>5<br>1 0<br>1 0<br>0 0<br>0 0<br>0 1<br>5 4 3 2 1<br>5<br>1 0<br>0 1<br>0 0<br>0 1<br>1 1<br>4 2 1 3 5<br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">0<br>3<br>2<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>要求最短的不合法的序列，等效于最长的合法序列，</p><p>又有，最长的合法序列 == 最长的不下降子序列。</p><p>而根据题目给定的排序方法，可将对象分别赋值为1，2，3（此处也可以用结构体排序方法），并用LIS模板求出最长不下降子序列。</p><p>最后，答案 == 总长度 - 最长不下降子序列长度。</p><p>注意：此题的最长不下降子序列需要使用 二分+贪心优化为 O(N*logN)</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> t,n,cnt;<br><span class="hljs-type">int</span> tep[MAX],a[MAX],query[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">bool</span> f1,f2;cin&gt;&gt;f1&gt;&gt;f2;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; !f2) tep[i] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!f1 &amp;&amp; f2) tep[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> tep[i] = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>a[n<span class="hljs-number">-1</span>-i] = tep[x<span class="hljs-number">-1</span>];<br>&#125;<br>cnt = <span class="hljs-number">0</span>;<br>query[cnt++] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt;= query[cnt<span class="hljs-number">-1</span>])&#123;<br>query[cnt++] = a[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-built_in">upper_bound</span>(query,query+cnt,a[i]) - query;<br>query[f] = a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;n-cnt&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2022-国赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-智能红绿灯">RC-u1 智能红绿灯</h1><p>为了最大化通行效率同时照顾老年人穿行马路，在某养老社区前，某科技公司设置了一个智能红绿灯。</p><p>这个红绿灯是这样设计的：</p><ol type="1"><li>路的两旁设置了一个按钮，老年人希望通行马路时会按下按钮；</li><li>在没有人按按钮的时候，红绿灯一直为绿灯；</li><li>当红绿灯为绿灯时，有人按下按钮，第一次按下按钮的 15秒后绿灯会转红；</li><li>转红后，红灯会持续 30 秒，方便老年人穿行马路；</li><li>在 30 秒的红灯期间，假如有人再次按下按钮，则红灯会再延续 15秒；</li><li>延续一次后不会再次延续。</li></ol><p>现在给定按钮被按下的时间点，请你输出这个智能红绿灯的红灯时间区间。</p><p>注意：我们假设同一秒内，红绿灯先变化，然后按钮再被按下。每 1秒理解为一个时间点。例如：在第 1 秒按下按钮，则第 16秒开始变红；如果没有人在第 16 - 45 秒这个闭区间内按下按钮，则到第 46秒开始变绿。而在第 46 秒按下按钮的人，需要等 15 秒后才有红灯。</p><h2 id="输入格式">输入格式</h2><p>输入第一行为 <em>N</em>(1≤<em>N</em>≤1000)，表示按钮被按下的次数。</p><p>接下来一行 <em>N</em>个非负整数，表示按钮被按下的时间点。一个时间点按钮有可能会被多次按下，给出的时间点保证是不递减的。</p><p>时间点的范围不超过 <span class="math inline">\(10^4\)</span>。</p><h2 id="输出格式">输出格式</h2><p>输出若干行，按起始时间从小到大输出互不相交的红灯的时间区间。</p><h2 id="输入样例">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10<br>3 4 5 6 33 45 49 70 90 100<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">18 62<br>85 129<br></code></pre></td></tr></table></figure><h2 id="解法">解法</h2><p>用l,r两个变量维护一个红灯区间，每次输入判断一下。</p><p>注意：这里红灯区间只能叠加一次15s，需要用f记录一下。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,t,l,r; <span class="hljs-comment">//[l,r-1]红灯区间</span><br><span class="hljs-type">bool</span> f;<span class="hljs-comment">//保证红灯范围内最多加一次15s</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>cin&gt;&gt;t;<br>l = t<span class="hljs-number">+15</span>;<br>r = t<span class="hljs-number">+45</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(!f &amp;&amp; t &gt;= l &amp;&amp; t &lt; r)&#123;<br>r += <span class="hljs-number">15</span>;<br>f = <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt;= r)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l,r<span class="hljs-number">-1</span>));<br>l = t<span class="hljs-number">+15</span>;<br>r = t<span class="hljs-number">+45</span>;<br>f = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l,r<span class="hljs-number">-1</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;it.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.second&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-女王的大敕令">RC-u2 女王的大敕令</h1><p>副本是游戏里的一个特色玩法，主要为玩家带来装备、道具、游戏资源的产出，满足玩家的游戏进程。</p><p>在 MMORPG《最终幻想14》里，有一个攻略人数最大达到 48人的副本“零式贡希尔德神庙”，其中守关 BOSS“天佑女王”有一个很有趣的技能：“女王的大敕令”。</p><p>技能在一个 5×5的棋盘上展开。每位玩家根据给定的两个步长，从某个方格出发，在棋盘上先走<em>D</em>1 步，再走 <em>D</em>2步。其中“步长”指的是<strong>曼哈顿距离</strong>，即：设两个方格的坐标分别为<span class="math inline">\((X_i,Y_i)\)</span> 以及 <spanclass="math inline">\((X_j,Y_j)\)</span>，则这两个方格的曼哈顿距离 <spanclass="math inline">\(D=|X_i - X_j|+|Y_i - Y_j|\)</span>。</p><p>例如下图中的 A 点与 B 点的曼哈顿距离为 5：</p><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/0641c1d8-cf11-4012-b132-60162aed4c06.png" class="" title="image.png"><p>技能开始时，场地外围会出现 4只小怪，东南西北（即棋盘的右、下、左、上）方向各出现一只小怪，且小怪一定出现在某行或某列对应的位置上。第<em>i</em> 只小怪会顺时针朝固定方向移动 <spanclass="math inline">\(n_i\)</span>步（题目保证不会移出界，即移动后仍然在对应着某行/某列的位置上），且：</p><ul><li>北边的小怪固定向右移动</li><li>东边的小怪固定向下移动</li><li>南边的小怪固定向左移动</li><li>西边的小怪固定向上移动</li></ul><p>小怪出现后，棋盘上还会出现一个发光的格子，这是玩家移动的目标点，如图所示：</p><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/838a75ee-7c3b-4be1-9030-0f5b5a07be37.png" class="" title="image.png"><p>玩家必须在不被小怪杀死的前提下，按规定步长，用两个回合到达目标点。技能流程如下：</p><p>1、玩家先选择一个起始方格；</p><p>2、东、西两侧的小怪开始按照固定方向移动，移动完毕后 <strong>4只</strong>小怪会<strong>同时</strong>开展攻击，其中东、西两侧的小怪攻击自己所对应的一整行，南、北两侧的小怪攻击自己所对应的一整列。玩家若处在攻击区内则任务失败。</p><p>3、玩家移动 <em>D</em>1 步，到达某个方格；</p><p>4、南、北两侧的小怪开始按照固定方向移动，移动完毕后 <strong>4只</strong>小怪会<strong>同时</strong>开展攻击，同第 2 步；</p><p>5、玩家移动 <em>D</em>2 步，此时必须到达目标点，否则任务失败。</p><p>以下是上面的 4 只小怪都移动后的攻击范围的示意图：</p><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/0dcdaa5c-361c-4d81-8d81-a9c34f32a237.png" class="" title="image.png"><p>给定小怪起始位置以及移动步数 *n**i*和目标点位置，请输出所有安全的移动方案，包括起始点以及第一次移动的目的地。</p><h2 id="输入格式-1">输入格式</h2><p>输入第一行是四个数<em>C</em>1,<em>C</em>2,<em>R</em>1,<em>R</em>2，分别表示：</p><ul><li>北边（上面）的小怪 1 在第 <em>C</em>1 列的位置上；</li><li>南边（下面）的小怪 2 在第 <em>C</em>2 列的位置上；</li><li>西边（左边）的小怪 3 在第 <em>R</em>1 行的位置上；</li><li>东边（右边）的小怪 4 在第 <em>R</em>2 行的位置上。</li></ul><p>输入第二行是四个数 <spanclass="math inline">\(n_i（i=1,⋯,4）\)</span>，按照上面的顺序给出小怪移动的步数，保证小怪移动后仍然处于某行或某列对应的位置上。</p><p>输入第三行是四个数 <spanclass="math inline">\(row,col,D1,D2\)</span>，依次表示目标点的位置，以及玩家要走的两个步长。这里某方格的“位置<span class="math inline">\((row,col)\)</span>指的是该方格的行号、列号组成的二元组。</p><p>我们假设左上角的方格位置为 <span class="math inline">\((1,1)\)</span>。</p><h2 id="输出格式-1">输出格式</h2><p>输出安全移动的方案，方案由两个位置共四个数组成，前两个数为初始选择的方格的位置，后两个数为第一次停留的位置。</p><p>对于多个方案的情况，先按初始方格位置从小到大输出，初始方格相同时按第一次停留位置从小到大输出。一个坐标<span class="math inline">\((r_i,c_i)\)</span> 比另一个坐标 <spanclass="math inline">\((r_j,c_j)\)</span> 小，当且仅当 <spanclass="math inline">\(r_i&lt;r_j\)</span>，或 <spanclass="math inline">\(r_i=r_j\)</span> 的同时有 <spanclass="math inline">\(c_i&lt;c_j\)</span>。</p><h2 id="输入样例-1">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">2 4 4 2<br>1 2 3 2<br>5 3 3 4<br></code></pre></td></tr></table></figure><h2 id="输出样例-1">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">2 1 2 4<br>2 3 3 1<br>2 3 3 5<br></code></pre></td></tr></table></figure><h2 id="解法-1">解法</h2><p>我的程序用了一个DFS，</p><p>第一步：按曼哈顿距离D1，遍历一下中间节点</p><p>第二步：判断能不能从中间节点，以D2的距离，走到终点</p><blockquote><p>这题其实没那么复杂，用四重循环遍历两个点坐标，再判断曼哈顿距离就可以。</p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> c1,c2,r1,r2;<span class="hljs-comment">//北，南，西，东</span><br><span class="hljs-type">int</span> t1,t2,t3,t4;<br><span class="hljs-type">int</span> fx,fy,d1,d2;<br><span class="hljs-type">int</span> sx,sy,mx,my;<br><br><span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">res</span>&#123;<br><span class="hljs-type">int</span> x1,y1,x2,y2;<br><span class="hljs-built_in">res</span>(<span class="hljs-type">int</span> x1_,<span class="hljs-type">int</span> y1_,<span class="hljs-type">int</span> x2_,<span class="hljs-type">int</span> y2_)&#123;<br>x1 = x1_;<br>y1 = y1_;<br>x2 = x2_;<br>y2 = y2_;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> res &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(x1 != rhs.x1) <span class="hljs-keyword">return</span> x1 &lt; rhs.x1;<br><span class="hljs-keyword">if</span>(y1 != rhs.y1) <span class="hljs-keyword">return</span> y1 &lt; rhs.y1;<br><span class="hljs-keyword">if</span>(x2 != rhs.x2) <span class="hljs-keyword">return</span> x2 &lt; rhs.x2;<br><span class="hljs-keyword">if</span>(y2 != rhs.y2) <span class="hljs-keyword">return</span> y2 &lt; rhs.y2;<br>&#125;<br><br>&#125;;<br>vector&lt;res&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">2</span>)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">res</span>(sx,sy,mx,my));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(sx == r1 - t3 || sx == r2 + t4 || sy == c1 || sy == c2)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= d1 ; i ++)&#123;<br><span class="hljs-type">int</span> j = d1 - i;<br><span class="hljs-type">int</span> s = <span class="hljs-number">4</span>; <span class="hljs-comment">//如果i,j为0，有重复的情况，用s去重。</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) s = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; s ; k ++)&#123; <span class="hljs-comment">//遍历中间节点</span><br>mx = sx + i*dirx[k];<br>my = sy + j*diry[k];<br><span class="hljs-keyword">if</span>(mx &gt;= <span class="hljs-number">1</span> &amp;&amp; mx &lt;= <span class="hljs-number">5</span> &amp;&amp; my &gt;= <span class="hljs-number">1</span> &amp;&amp; my &lt;= <span class="hljs-number">5</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(mx == r1 - t3 || mx == r2 + t4 || my == c1 + t1 || my == c2 - t2)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">bool</span> arv = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= d2 ; i ++)&#123;<br><span class="hljs-type">int</span> j = d2 - i;<br><span class="hljs-type">int</span> s = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) s = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; s ; k ++)&#123; <span class="hljs-comment">//判断能不能走到终点</span><br><span class="hljs-keyword">if</span>(mx + i*dirx[k] == fx &amp;&amp; my + j*diry[k] == fy)&#123;<br>arv = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(arv) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;r1&gt;&gt;r2;<br>cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;<br>cin&gt;&gt;fx&gt;&gt;fy&gt;&gt;d1&gt;&gt;d2;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">5</span> ; j ++)&#123;<br>sx = i;<br>sy = j;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(res it : ans)&#123;<br>cout&lt;&lt;it.x1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.y1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.x2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.y2&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-战利品分配">RC-u3 战利品分配</h1><p>在某个战争游戏中，多个玩家组成一个大型军团，攻下若干城池，并获得战利品。</p><p>具体而言，游戏中有 <em>N</em> 个城市，并以 <em>M</em> 条长度为 1的无向道路连接，玩家们组成的军团从 <em>S</em> 号城市开始进攻，目的地是<em>T</em> 号城市，每个城市攻下后的战利品价值为 <spanclass="math inline">\(p_i\)</span>。</p><p>为了合理地分配战利品，军团们定下了规矩：假设军团里有 <em>K</em>位玩家，那么从 <em>S</em> 号城市开始，第 1 个攻下的城市分配给第 1位玩家，第 2 个攻下的分配给第 2 位玩家，……，第 <em>K</em>个攻下的分配给第 <em>K</em> 位玩家，第 <em>K</em>+1个攻下的则重新开始计算，分配给第 1 位玩家，以此类推。</p><p>军团很强，路上所有的城市都可以轻松进攻下来。你作为军团的指挥，可以指定玩家的进攻路线。但玩家们都希望尽快结束游戏，因此<em>S</em> 到 <em>T</em>的距离必须是最短的。你需要做的是在最短距离的限制下选择对自己最好的线路，获得尽可能高的战利品价值。请输出你的答案。</p><h2 id="输入格式-2">输入格式</h2><p>输入第一行是四个数 <em>N</em>,<em>M</em>,<em>K</em>,<em>P</em>(1≤<em>N</em>,<em>M</em>≤105,1≤<em>K</em>≤104,1≤<em>P</em>≤<em>K</em>)，表示城市数量（于是城市从1 到 <em>N</em> 编号）、连接道路数量以及你在军团中的 <em>K</em>位玩家中排第 <em>P</em> 位（即你战利品分配在第 <em>P</em> 位）。</p><p>第二行是 <em>N</em> 个被空格隔开的非负整数，第 <em>i</em> 个数对应*p**i* (0≤*p**i<em>≤104)，表示编号为 </em>i*的城市的战利品价值（<em>i</em>=1,⋯,<em>N</em>）。</p><p>然后的 <em>M</em> 行，每行给出两个用空格分隔的正整数 <em>U</em> 和<em>V</em>，表示编号为 <em>U</em> 和 <em>V</em>的城市之间有道路连接。</p><p>最后的一行是两个正整数<em>S</em>,<em>T</em>，表示开始的城市编号与目的地的城市编号。开始和目的地的城市也是可以进攻并获取战利品的。</p><h2 id="输出格式-2">输出格式</h2><p>输出一行，表示你可以取得的最大价值。</p><h2 id="输入样例-2">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs in">9 11 2 2<br>100 150 130 50 30 20 200 0 70<br>1 2<br>1 3<br>2 3<br>2 4<br>2 5<br>3 6<br>4 7<br>5 7<br>6 8<br>7 9<br>8 9<br>1 9<br></code></pre></td></tr></table></figure><h2 id="输出样例-2">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">350<br></code></pre></td></tr></table></figure><h2 id="解法-2">解法</h2><p>无权图的单源最短路问题，考虑使用BFS来做</p><p>在层序遍历时，维护路径的价值sum，从多条最短路中选择一条价值最高的，即为答案。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,m,k,p,s,t,ans;<br><span class="hljs-type">int</span> val[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span> &gt; edge[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">step</span>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> dep;<br><span class="hljs-type">int</span> sum;<br><br><span class="hljs-built_in">step</span>(<span class="hljs-type">int</span> x_,<span class="hljs-type">int</span> dep_,<span class="hljs-type">int</span> sum_)&#123;<br>x = x_;<br>dep = dep_;<br>sum = sum_;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;step&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">step</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> min_ = INT_MAX;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().x;<br><span class="hljs-type">int</span> dep = q.<span class="hljs-built_in">front</span>().dep;<br><span class="hljs-type">int</span> sum = q.<span class="hljs-built_in">front</span>().sum;<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">if</span>(dep &gt; min_) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span>(dep % k == <span class="hljs-number">0</span> &amp;&amp; k == p) sum += val[x]; <span class="hljs-comment">//k==p需要特判</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dep%k == p) sum += val[x];<br><br><span class="hljs-keyword">if</span>(x == t &amp;&amp; dep &lt;= min_)&#123;<br>ans = <span class="hljs-built_in">max</span>(sum,ans);<br>min_ = dep;<br>&#125;<br>        <br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : edge[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it]) q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">step</span>(it,dep<span class="hljs-number">+1</span>,sum));<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;val[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>edge[a].<span class="hljs-built_in">push_back</span>(b);<br>edge[b].<span class="hljs-built_in">push_back</span>(a);<br>&#125;<br>cin&gt;&gt;s&gt;&gt;t;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-变牛的最快方法">RC-u4 变牛的最快方法</h1><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/3b6f7584-a4ba-4d73-a4f5-49b956dd3604.png" class="" title="shu.png"><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E5%9B%BD%E8%B5%9B%E9%A2%98%E8%A7%A3/9d18450d-de04-4437-9da4-22f633b8f806.png" class="" title="niu.png"><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><h2 id="输入格式-3">输入格式</h2><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><h2 id="输出格式-3">输出格式</h2><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><h2 id="输入样例-3">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><h2 id="输出样例-3">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><h2 id="样例解释">样例解释</h2><p>1、13 更改为 3，随后 5、6、20 不变 2、2 更改为 6，下一个 20 不变 3、1更改为 3 4、第二个 13 更改为 5，随后 9 不变 5、删除下一个 20，后面的 3不变 6、在 28 的前面插入 9 7、28 更改为 20，后面的 3 不变 8、34 更改为6，后面的 6、25、233 不变</p><h2 id="解法-3">解法</h2><p>动态规划经典 之 最短编辑距离+路径回溯</p><p>递推式：<span class="math inline">\(dp[i][j] = min(dp[i-1][j] +1,dp[i][j-1] + 1,dp[i-1][j-1] + (a1[i] != a2[j]))\)</span></p><p>当前最优的状态 = 删除/插入/不变/变换这四种操作执行后，耗费次数最小的。</p><p>路径回溯需要在dp数组生成过程中维护pre（路径）数组和op（操作）数组。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> l1,l2;<br><span class="hljs-type">int</span> a1[MAX],a2[MAX];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pre[MAX][MAX];<br><span class="hljs-type">int</span> op[MAX][MAX],dp[MAX][MAX];<br><br><span class="hljs-comment">//删除 0 改变 1 不变 2 插入 3</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><br><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br><span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br><span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>dp[i][<span class="hljs-number">0</span>] = i;<br>op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>dp[<span class="hljs-number">0</span>][i] = i;<br>op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br><span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br><span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br><br><span class="hljs-keyword">if</span>(min_ == add)&#123;<br>dp[i][j] = add;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>op[i][j] = <span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>dp[i][j] = del;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>op[i][j] = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = rpl;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><span class="hljs-comment">//路径回溯</span><br><span class="hljs-type">int</span> x = l1;<br><span class="hljs-type">int</span> y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x||y)&#123;<br>ans.<span class="hljs-built_in">push</span>(op[x][y]);<br><span class="hljs-keyword">auto</span> back = pre[x][y];<br>x = back.first;<br>y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-养老社区">RC-u5 养老社区</h1><p>作为智能看护的一部分，你需要评估某个养老社区是否适合开展智能看护的服务。</p><p>这个养老社区有若干幢住宅楼，每个住宅楼有一个种类，住宅楼之间由长度为1 的道路连接，道路都是双向道路且没有构成环 ——你可以简单地认为养老社区的路构成了一棵树。</p><p>假设我们能找到三个住宅楼，这三个住宅楼两两之间的最短距离相等，并且三个住宅楼的种类不一样，那么我们称这三个住宅楼组成的三元组为<strong>适合智能看护的</strong>，指的是为了服务这三个住宅楼，我们可能可以方便地找到适合建设服务中心的地方。一个社区的<strong>适合度</strong>指的是能够找到多少本质不同的<strong>适合智能看护的</strong>住宅楼三元组。</p><p>本质不同两个的三元组指的是：三元组内元素任意排列后，两个三元组仍然不相等。</p><p>给定这个养老社区的情况，请你求出这个社区的适合度。</p><h2 id="输入格式-4">输入格式</h2><p>输入第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤2×103)，表示养老社区里住宅楼的数量（于是住宅楼从 1 到<em>N</em> 编号）。</p><p>接下来 <em>N</em>−1 行，每行给出空格分隔的两个正整数 <em>U</em> 和<em>V</em>，表示编号为 <em>U</em> 和 <em>V</em> 的住宅楼之间有一条长度为1 的道路。</p><p>最后一行给出 <em>N</em> 个数，第 <em>i</em> 个数表示编号为 <em>i</em>的住宅楼的种类为<em>T<strong>i<em>（1≤</em>T</strong>i</em>≤<em>N</em>）。</p><p>保证给定的数据会将所有住宅楼连接成一棵完整的树。</p><h2 id="输出格式-4">输出格式</h2><p>输出一行一个正整数，表示社区的适合度。</p><h2 id="输入样例-4">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">11<br>1 2<br>1 3<br>1 4<br>2 5<br>2 6<br>3 7<br>3 8<br>4 9<br>4 10<br>1 11<br>1 2 3 4 5 6 7 8 9 9 10<br></code></pre></td></tr></table></figure><h2 id="输出样例-4">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">14<br></code></pre></td></tr></table></figure><h2 id="解法-4">解法</h2><p>多源无权图最短路问题（n &lt;= 2000），考虑使用n次的BFS。</p><p>首先，使用n次BFS，得到每个点的最短路径数组。</p><p>然后，三重循环遍历每个三元组，判断是否符合条件即可。</p><blockquote><p>一次写的时候，用Floyd去做:），实测能过 5/8个样例。</p></blockquote><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">2e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> type[MAX];<br><span class="hljs-type">int</span> dist[MAX][MAX];<span class="hljs-comment">//dist[i][j]:i-&gt;j的最短路</span><br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br>q.<span class="hljs-built_in">push</span>(&#123;st,<span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<span class="hljs-type">int</span> dep = q.<span class="hljs-built_in">front</span>().second;q.<span class="hljs-built_in">pop</span>();<br>dist[st][x] = <span class="hljs-built_in">min</span>(dist[st][x],dep);<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : edge[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it]) q.<span class="hljs-built_in">push</span>(&#123;it,dep<span class="hljs-number">+1</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>edge[x].<span class="hljs-built_in">push_back</span>(y);<br>edge[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;type[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-built_in">bfs</span>(i);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(type[i] == type[j] || dist[i][j] == INF) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里必须优化，不然过不了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = j<span class="hljs-number">+1</span> ; u &lt;= n ; u ++)&#123;<br><span class="hljs-keyword">if</span>(type[i] != type[j] &amp;&amp; type[j] != type[u] &amp;&amp; type[i] != type[u]<br>&amp;&amp; dist[i][j] != INF &amp;&amp; dist[i][j] == dist[j][u] &amp;&amp; dist[i][j] == dist[i][u])&#123;<br>ans++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2022-省赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2022-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-不要浪费金币模拟">RC-u1 不要浪费金币（模拟）</h1><p>哲哲最近在玩一个游戏，击杀怪物能获得金币 —— 这里记击杀第 <em>i</em>个怪物获得的金币数量为 *P**i*。</p><p>然而这个游戏允许拥有的金币数量是有上限的，当超过时，超过上限的部分就会被系统光明正大地吃掉，哲哲就拿不到了。</p><p>为了不浪费金币，哲哲决定，当下一个要击杀的怪物可获得的金币会导致自己拥有的金币数量超过上限时，就去消费一次，把自己已有的金币全部用完。</p><p>现在给定哲哲将要击杀的一系列怪物对应的金币数量，请你计算一下哲哲去消费了几次。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个整数 <em>N</em>,<em>M</em>（1≤<em>N</em>≤103,1≤<em>M</em>≤106），表示击杀的怪物数量以及系统允许拥有金币数量的上限。</p><p>接下来一行是由空格隔开的 <em>N</em> 个数*P**i<em>（</em>i<em>=1,⋯,</em>N<em>），依次表示击杀第 </em>i*个怪物能获得的金币数量。假设哲哲是按输入顺序击杀怪物的，并且每个 *P**i*都是 不超过 106 的非负整数。</p><h3 id="输出格式">输出格式</h3><p>在一行中输出哲哲去消费的次数。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10 10<br>1 2 3 4 1 2 3 5 11 1<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p>消费时间点为：第四个怪物击杀后、第七个怪物击杀后、第八个怪物击杀后、第九个怪物击杀后。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> ans,sum;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> t; cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(sum + t &gt; m)&#123;<br>ans++;<br>sum = <span class="hljs-number">0</span>;<br>&#125;<br>sum += t;<br>&#125;<br>cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-智能服药助手模拟">RC-u2 智能服药助手（模拟）</h1><p>智能看护中很重要的环节是安排需要服药的老年人的服药计划。</p><p>已知机器人需要照顾的某位老年人需要服用 <em>N</em>种药物，但某些药物不宜间隔过短服用 —— 比如降糖药一般遵医嘱日服 3次，两次之间需要间隔至少 4小时。当需要服用的药物比较多，医嘱比较复杂时，如何保证每位老人的服药计划是安全合理的，就成为一个挑战。</p><p>本题给定一套服药计划，请你检查一下计划是否存在问题。</p><h3 id="输入格式-1">输入格式</h3><p>输入第一行给出两个整数<em>N</em>,<em>M</em>（1≤<em>N</em>,<em>M</em>≤103），表示老人需要服用<em>N</em> 种药物（药物种类从 1 到 <em>N</em> 编号），对应的服药计划有<em>M</em> 条记录。</p><p>接下来首先在一行中给出 <em>N</em> 个用空格隔开的整数 *T**i*（−1≤<em>T<strong>i<em>≤100,</em>T</strong>i</em>\=0)，表示编号为<em>i</em> 的药物需要间隔至少 *T**i* 个单位时间服用。如果 *T**i* 为−1，则说明这种药物没有间隔要求。</p><p>接下来的 <em>M</em>行，每行给出一条服药计划中的记录，格式为：首先给出两个非负整数<em>t</em> 和 <em>k</em>(0≤<em>t</em>≤109,0≤<em>k</em>≤<em>N</em>)，表示服药的时刻为<em>t</em>，服用了 <em>k</em> 种药物；然后紧接着列出 <em>k</em>个数，每个数对应 <em>t</em>时刻要吃的药物种类的编号。一行中的数字之间以空格分隔。</p><p>题目保证：记录按照服药时刻 <em>t</em>的递增顺序给出；每一时刻服用的药物种类各不相同。注意：同一种药物可能需要在不同的时刻重复服用。如果一位老人在*t**i* 时刻和 *t**j* 时刻服用了同一种药物，则他服用的间隔时间为∣<em>t<strong>i<em>−</em>t</strong>j</em>∣。</p><h3 id="输出格式-1">输出格式</h3><p>按照输入顺序检查每一条记录中的每一种药物。如果在 <code>Y</code>时刻不宜服用药物 <code>X</code>，则在一行中输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Don<span class="hljs-symbol">&#x27;t</span> take X <span class="hljs-keyword">at</span> Y!<br></code></pre></td></tr></table></figure><p>注意：老人收到提醒后会按照提醒不服用指定的药物。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">10 6<br>1 2 3 4 5 -1 -1 -1 -1 -1<br>0 1 1<br>1 2 1 2<br>2 1 2<br>3 2 1 3<br>5 3 1 3 4<br>6 2 1 4<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Don&#x27;t take 2 at 2!<br>Don&#x27;t take 3 at 5!<br>Don&#x27;t take 4 at 6!<br></code></pre></td></tr></table></figure><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> last[MAX],gap[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;gap[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(last,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(last));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> t,k;cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br><span class="hljs-type">int</span> pi;cin&gt;&gt;pi;<br><span class="hljs-keyword">if</span>(last[pi] != <span class="hljs-number">-1</span> &amp;&amp; t - last[pi] &lt; gap[pi])&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Don&#x27;t take &quot;</span>&lt;&lt;pi&lt;&lt;<span class="hljs-string">&quot; at &quot;</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">&quot;!&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span> last[pi] = t;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-跑团机器人字符串处理">RC-u3 跑团机器人（字符串处理）</h1><p>在桌面角色扮演游戏（TRPG，俗称“跑团”）中，玩家需要掷出若干个骰子，根据掷出的结果推进游戏进度。在线上同样可以跑团，方法是由玩家们向机器人发出指令，由机器人随机产生每个需要掷出的骰子的结果。</p><p>玩家向机器人发出的指令是一个仅涉及加法和减法的表达式，即对若干个数字进行一系列加法或减法计算。这些数字可以是直接给出的非负整数（数字不超过1000），也可以是若干个骰子掷出的结果。</p><p>“掷骰子”这个动作对应的指令格式为 <em>x</em>d<em>y</em>，表示摇动<em>x</em> 个 <em>y</em>面的骰子（1≤<em>x</em>≤1000,2≤<em>y</em>≤1000）。当 <em>x</em> 为 1时，1 可以省略。</p><p>例如指令 <code>2d3+3-d4</code> 的意思是：先掷出 2 个 3面骰子（你不必考虑现实中是否存在这样的骰子），不妨假设结果为 1 和 3，则<code>2d3</code> 的结果就是两个骰子的面值之和 4；然后计算 4 +3，得到结果为 7；再掷出 1 个 4 面骰子，不妨假设结果为 2，则计算 7 - 2得到最终结果 5。</p><p>本题就请你计算玩家输入的指令里，不同种类的骰子需要掷出几个，以及可能得到的结果在什么区间范围内。</p><h3 id="输入格式-2">输入格式</h3><p>输入在一行中给出一条符合题目描述的玩家输入机器人的指令。题目保证指令长度不超过2∗104。</p><h3 id="输出格式-2">输出格式</h3><p>首先输出不同种类的骰子分别需要掷出几个。每种骰子的信息占一行，依次输出骰子的面数和投掷的数量，按面数从小到大输出。</p><p>输入指令保证至少有一个骰子需要掷出。</p><p>最后一行输出两个数，表示根据输入指令可以得到的最小结果和最大结果。</p><p>同一行数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">d6+3d5+2-2d3+2d5<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">3 2<br>5 5<br>6 1<br>2 31<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>预处理：输入字符串左侧连接+号</p><p>从左到右读字符串，每次读到+/-号，往后读取直到下一个+/-为止的字符串，存储为res；</p><p>根据d在res中的位置（如果没有，为常量，需要特判）分类讨论。</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>string s;<br>string res;<br><span class="hljs-type">int</span> min_;<br><span class="hljs-type">int</span> max_;<br><span class="hljs-type">int</span> cnt[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hasD</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> idxD = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;d&#x27;</span>)&#123;<br>idxD = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> idxD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stoi</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>ans = ans*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br>s = <span class="hljs-string">&quot;+&quot;</span> + s;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>())&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br><span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>;<br>res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(k &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() &amp;&amp; s[k] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[k] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>res = res + s[k++];<br>&#125;<br>i = k;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">hasD</span>(res);<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>)&#123;<br>min_ += <span class="hljs-built_in">Stoi</span>(res);<br>max_ += <span class="hljs-built_in">Stoi</span>(res);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>));<br>max_ += type;<br>min_ += <span class="hljs-number">1</span>;<br>cnt[type] ++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p));<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(p<span class="hljs-number">+1</span>,res.<span class="hljs-built_in">length</span>()-p));<br>max_ += type*num;<br>min_ += num;<br>cnt[type] += num;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br><span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>;<br>res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(k &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() &amp;&amp; s[k] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[k] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>res += s[k++];<br>&#125;<br>i = k;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">hasD</span>(res);<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>)&#123;<br>min_ -= <span class="hljs-built_in">Stoi</span>(res);<br>max_ -= <span class="hljs-built_in">Stoi</span>(res);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>));<br>max_ -= <span class="hljs-number">1</span>;<br>min_ -= type;<br>cnt[type] ++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p));<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(p<span class="hljs-number">+1</span>,res.<span class="hljs-built_in">length</span>()-p));<br>max_ -= num;<br>min_ -= type*num;<br>cnt[type] += num;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">1000</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(cnt[i] != <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br>cout&lt;&lt;min_&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;max_&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-攻略分队dfs">RC-u4 攻略分队（DFS）</h1><p>副本是游戏里的一个特色玩法，主要为玩家带来装备、道具、游戏资源的产出，满足玩家的游戏进程。</p><p>在 MMORPG《最终幻想14》里，有一个攻略人数最大达到 56人的副本“巴尔德西昂兵武塔”，因为有在副本里死亡不能复活、机制比较整蛊等特点，一度被玩家视作洪水猛兽。</p><p>在副本的开始，我们会遇到第一个难关：攻略的玩家要分为两组，同时讨伐副本BOSS “欧文”和“亚特”。</p><p>已知以下信息：</p><ol type="1"><li>玩家会组成 6 支队伍进入副本，其中第 <em>i</em> 队有 *V**i*位玩家（<em>i</em>=1,⋯,6）。</li><li>每支队伍可能会有一些特殊角色：MT（主坦克）、工兵（负责探测陷阱）和指挥（负责指挥玩家）。</li></ol><p>我们的任务是合理安排玩家的分组，以最大程度增加副本通过概率。分组的原则如下：</p><ol type="1"><li>要将所有队伍分成 2 组，每支队伍必须且仅属于其中一组；</li><li>每组<strong>必须</strong>有至少一个 MT（主坦克）。</li></ol><p>如果满足上述原则的分组方案不唯一，则按照下列规则确定唯一解：</p><ol type="1"><li>优先选择每组有至少一个指挥和至少一个工兵的方案；</li><li>如果规则 1 无法满足，则优先选择每组至少有一个指挥的方案；</li><li>如果所有方案都不满足规则 2，或经过前 2个规则筛选后，分组方案仍不唯一，则选择两边人数尽可能接近（即两边人数差尽可能小）的方案；</li><li>如果满足规则 3的方案还不唯一，选择讨伐“欧文”的人数<strong>大于等于</strong>讨伐“亚特”的人数的方案；</li><li>如果满足规则 4的方案还不唯一，选择讨伐“欧文”的队伍编号方案中最小的一个。</li></ol><p>注：一个队伍编号方案<em>A</em>={<em>a</em>1&lt;⋯&lt;<em>a<strong>m<em>} 比</em>B<em>={</em>b<em>1&lt;⋯&lt;</em>b</strong>n</em>} 小，当且仅当存在1≤<em>k</em>≤min(<em>m</em>,<em>n</em>) 使得<em>a<strong>i<em>=</em>b</strong>i</em> 对所有0&lt;<em>i</em>&lt;<em>k</em> 成立，且<em>a<strong>k<em>&lt;</em>b</strong>k</em>。</p><p>本题就请你给出满足所有分组原则的分配方案。</p><p><em>感谢 王宪泉 同学对规则 4 的指正，于 2022-08-04 修改</em></p><h3 id="输入格式-3">输入格式</h3><p>输入第一行给出 6 支队伍的玩家数量，即 6 个非负整数 *V**i*(0≤*V**i<em>≤8,1≤</em>i*≤6)。队伍人数为 0 时表示队伍不存在。</p><p>随后 6 行，按队伍编号顺序，每行给出一支队伍的特殊角色，格式为<code>ABC</code>，其中 <code>A</code> 对应 MT，<code>B</code>对应工兵，<code>C</code> 对应指挥。三种角色对应取值 0 或 1，0表示没有该角色，1 表示有。</p><p>注：由于可能存在一人兼任多个特殊角色的情况，所以一支队伍中的特殊角色数量有可能大于该队伍的玩家数量。</p><h3 id="输出格式-3">输出格式</h3><p>输出分两行，第一行输出讨伐“欧文”的队伍编号，第二行输出讨伐“亚特”的队伍编号。同一行中的编号按升序输出，以1 个空格分隔，行首尾不得有多余空格。</p><p>如果不存在合法的方案，输出<code>GG</code>。</p><h3 id="输入样例1">输入样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8 7 5 3 0<br>010<br>101<br>110<br>001<br>111<br>000<br></code></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">2 3<br>1 4 5<br></code></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8 7 5 3 0<br>010<br>101<br>010<br>001<br>011<br>000<br></code></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">GG<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>使用DFS生成每一种解，6个队伍，一共是2^6种解。</p><p>创建结构体Solusion，存储每一种解，根据题目给定的条件，对数组排序。</p><p>数组[0]即为最优解，若最优解无法满足：每组都有MT这个初始条件，则无解，输出GG。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">6</span>];<br><span class="hljs-type">bool</span> hasType[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solusion</span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ou;<br>vector&lt;<span class="hljs-type">int</span> &gt; ya;<br><span class="hljs-type">bool</span> hasType0; <span class="hljs-comment">//有MT</span><br><span class="hljs-type">bool</span> hasType2;<span class="hljs-comment">//每组至少有一个指挥</span><br><span class="hljs-type">bool</span> hasType1_2;<span class="hljs-comment">//每组至少有一个工兵和指挥</span><br><span class="hljs-type">int</span> gap; <span class="hljs-comment">//差距</span><br><span class="hljs-type">bool</span> isOuMore; <span class="hljs-comment">//ou数量 &gt;= ya数量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">bool</span> ouType[<span class="hljs-number">3</span>];<br><span class="hljs-type">bool</span> yaType[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">memset</span>(ouType,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(ouType));<br><span class="hljs-built_in">memset</span>(yaType,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(yaType));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ou)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">3</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(hasType[it][j])&#123;<br>ouType[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ya)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">3</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(hasType[it][j])&#123;<br>yaType[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>hasType0 = ouType[<span class="hljs-number">0</span>]&amp;&amp;yaType[<span class="hljs-number">0</span>];<br>hasType2 = ouType[<span class="hljs-number">2</span>]&amp;&amp;yaType[<span class="hljs-number">2</span>];<br>hasType1_2 = ouType[<span class="hljs-number">2</span>]&amp;&amp;ouType[<span class="hljs-number">1</span>]&amp;&amp;yaType[<span class="hljs-number">2</span>]&amp;&amp;yaType[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> ouSize = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> yaSize = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ou)&#123;<br>ouSize += cnt[it];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ya)&#123;<br>yaSize += cnt[it];<br>&#125;<br>gap = <span class="hljs-built_in">abs</span>(ouSize - yaSize);<br>isOuMore = (ouSize &gt;= yaSize);<br>&#125;<br>&#125;sol;<br>vector&lt;Solusion&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, Solusion tep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">6</span>)&#123;<br>tep.<span class="hljs-built_in">init</span>();<br>ans.<span class="hljs-built_in">push_back</span>(tep);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt[dep] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tep.ou.<span class="hljs-built_in">push_back</span>(dep);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br>tep.ou.<span class="hljs-built_in">pop_back</span>();<br>tep.ya.<span class="hljs-built_in">push_back</span>(dep);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br>tep.ya.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpSol</span><span class="hljs-params">(<span class="hljs-type">const</span> Solusion&amp; a,<span class="hljs-type">const</span> Solusion&amp; b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.hasType0 != b.hasType0) <span class="hljs-keyword">return</span> a.hasType0 &gt; b.hasType0;<br><span class="hljs-keyword">if</span>(a.hasType1_2 != b.hasType1_2) <span class="hljs-keyword">return</span> a.hasType1_2 &gt; b.hasType1_2;<br><span class="hljs-keyword">if</span>(a.hasType2 != b.hasType2) <span class="hljs-keyword">return</span> a.hasType2 &gt; b.hasType2;<br><span class="hljs-keyword">if</span>(a.gap != b.gap) <span class="hljs-keyword">return</span> a.gap &lt; b.gap;<br><span class="hljs-keyword">if</span>(a.isOuMore != b.isOuMore) <span class="hljs-keyword">return</span> a.isOuMore &gt; b.isOuMore;<br><span class="hljs-keyword">return</span> a.ou &lt; b.ou;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span> ; i ++)&#123;<br>cin&gt;&gt;cnt[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span> ; i ++)&#123;<br>string s;cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;0&#x27;</span>) hasType[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;1&#x27;</span>) hasType[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,sol);<br><span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>(),cmpSol);<br><br><span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>].hasType0 == <span class="hljs-literal">false</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;GG&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ou.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;ans[<span class="hljs-number">0</span>].ou[i]<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(i != (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ou.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ya.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;ans[<span class="hljs-number">0</span>].ya[i]<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(i != (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ya.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-树与二分图二分图">RC-u5 树与二分图（二分图）</h1><p>设 <em>G</em>=(<em>V</em>,<em>E</em>) 是一个无向图，如果顶点集合<em>V</em> 可分割为两个互不相交的子集(<em>A</em>,<em>B</em>)，并且每条边 (<em>i</em>,<em>j</em>)∈<em>E</em>的两个端点 <em>i</em> 和 <em>j</em> 分别属于这两个不同的顶点子集，则称图<em>G</em> 为一个二分图。</p><p>现在给定一棵树<em>T</em>，要求选择树中两个<strong>没有边相连</strong>的结点 <em>i</em>和 <em>j</em>，使得将无向边 (<em>i</em>,<em>j</em>) 加进 <em>T</em>后能够构成二分图。你的任务是计算满足这个要求的选择方案有多少种。</p><h3 id="输入格式-4">输入格式</h3><p>输入第一行给出一个正整数 <em>N</em>(2≤<em>N</em>≤106)，表示树中结点的个数。</p><p>接下来 <em>N</em>−1行，每行给出树中一条边的两端结点编号，以空格分隔。结点编号从 1开始。题目保证输入给出的是一棵树中所有的边。</p><h3 id="输出格式-4">输出格式</h3><p>在一行中输出方案数。注意：连接 (1,2) 和 (2,1) 视作同一个方案。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">7<br>1 2<br>2 3<br>2 4<br>2 5<br>2 6<br>4 7<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>要解这道题，首先要知道：</p><p>1.树本身是一个按层序奇偶划分的二分图。</p><p>2.完全二分图边的个数为：N * M ，即将两个集合中点数量之积</p><p>这道题的本质是求：将一颗给定的树构造成完全二分图需要几条边。</p><p>即：完全二分图的边 - 给定树的边。</p><h3 id="代码-4">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br>ll n;<br>ll cnt[<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> vis[MAX];<br>vector&lt;ll&gt; sons[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count</span><span class="hljs-params">(ll node,ll type)</span></span>&#123;<br>cnt[type]++;<br>vis[node] = <span class="hljs-literal">true</span>;<br>ll next = type ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : sons[node])&#123;<br><span class="hljs-keyword">if</span>(!vis[it]) <span class="hljs-built_in">count</span>(it,next);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>ll x,y;cin&gt;&gt;x&gt;&gt;y;<br>sons[x].<span class="hljs-built_in">push_back</span>(y);<br>sons[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;cnt[<span class="hljs-number">0</span>]*cnt[<span class="hljs-number">1</span>] - (n<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2021-省赛题解</title>
    <link href="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2021-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2021-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="懂的都懂dfs">1：懂的都懂（DFS）</h1><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2021-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/adc22dc9-7cd0-417c-9274-3d0678474c6e.jpg" class="" title="b3ceb051352ac65c29767cc3ecf2b21192138add.jpg"><p>众所周知，在互联网上有很多话是不好直接说出来的，不过一些模糊的图片仍然能让网友看懂你在说什么。然而对这种言论依然一定要出重拳，所以请你实现一个简单的匹配算法。</p><p>现在我们采集了原图的一些特征数据，由 <em>N</em> 个小于 255的非负整数组成，假设对于给定的若干张由 *M**i* 个同样小于 255的非负整数组成的新图的特征数据，每个数据都可以由原图中任意四个不同数据的平均值计算而来，则称新图为原图的相似图片。对于给出的数据，请你判断是不是相似图片。</p><p>注意，不同数据指的并非是数据的值不同，而是不能取同一个数据多次。对于两个相同值的数据，如果给出两次，则可以取两次。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个整数 <em>N</em>,<em>K</em> (1 ≤ <em>N</em> ≤ 50, 1 ≤<em>K</em> ≤ 200)，表示采集的原图的特征数据个数和新图的张数。接下来一行为 <em>N</em> 个小于 255 的非负整数，表示原图的特征数据。最后的 <em>K</em> 行，每行第一个数是 <em>Mi</em> (1 ≤ <em>Mi</em> ≤200)，表示新图的特征数据个数。然后是 <em>Mi</em> 个小于 255的非负整数，表示新图的特征数据。</p><h3 id="输出格式">输出格式</h3><p>对于每一张新图，如果为相似图片，则在一行中输出 Yes，否则输出 No。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">5 3<br>4 8 12 20 40<br>3 11 16 19<br>3 12 16 19<br>10 11 11 11 11 11 11 11 11 11 11<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes<br>No<br>Yes<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>使用DFS枚举每一种可能平均数，使用set去重并存储。（也可以用四重循环枚举）</p><p>最后，对每次输入的值进行判断。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[MAX];<br>set&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getSet</span><span class="hljs-params">(<span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">4</span>)&#123;<br>st.<span class="hljs-built_in">insert</span>(sum);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == n || cnt &gt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">getSet</span>(sum + a[dep],dep<span class="hljs-number">+1</span>,cnt<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">getSet</span>(sum,dep<span class="hljs-number">+1</span>,cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">getSet</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">int</span> m;cin&gt;&gt;m;<br>string ans = <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> tep;cin&gt;&gt;tep;<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(tep*<span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) ans = <span class="hljs-string">&quot;No&quot;</span>; <br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="芬兰木棋几何">2：芬兰木棋（几何）</h1><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2021-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/62b483d4-0b40-41bd-a8b1-be4a0aeae56a.png" class="" title="WX20200212-152528.png"><p>芬兰木棋（Mölkky，又称芬兰木柱）是源自芬兰的一项运动。哲哲将这个运动改造成了赛博朋克单人版，现在场上一开始有<em>N</em>根立起的小木棋（上面分别标有一个非负整数），哲哲投掷一根大木棋去击倒这些小木棋以获得分数。分数规则如下：</p><ul><li>如果仅击倒 1 根木棋，则得木棋上的分数。</li><li>如果击倒 2 根或以上的木棋，则只得击倒根数的分数。（例如击倒 5根，则得 5 分。）</li></ul><p>哲哲固定站在 (0,0) 点上，四周放着若干个小木棋(<em>X<strong>i<em>,</em>Y</strong>i</em>)，坐标均为整数。每次哲哲可以朝一个方向扔出大木棋，大木棋会打倒这个方向上离哲哲最近的<em>k</em> 个小木棋。哲哲游戏水平很高超，所以这个 <em>k</em>可以自由控制。</p><p>请问哲哲最多能拿多少分，在获得最多分数的情况下最少需要扔出多少次大木棋？</p><p><em>规则与真实规则有较大出入，真实游玩时请以国际莫尔基组织的规则为准</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (1 ≤ <em>N</em> ≤105)，表示场上一开始有 <em>N</em> 个木棋。</p><p>接下来 <em>N</em> 行，每行 3 个整数<em>X<strong>i<em>,</em>Y</strong>i</em>,<em>P<strong>i<em>，分别表示木棋放置在(</em>X</strong>i</em>,<em>Y<strong>i<em>)，木棋上的分数是</em>P</strong>i</em>。坐标在 32 位整数范围内，分数为小于等于 1000的正整数。</p><p>保证 (0,0) 点没有木棋，也没有木棋重叠放置。</p><h3 id="输出格式-1">输出格式</h3><p>输出一行两个数，表示最多分数以及获得最多分数最少需要投掷大木棋多少次。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">11<br>1 2 2<br>2 4 3<br>3 6 4<br>-1 2 2<br>-2 4 3<br>-3 6 4<br>-1 -2 1<br>-2 -4 1<br>-3 -6 1<br>-4 -8 2<br>2 -1 999<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">1022 9<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>对于每个点，用结构体存储信息。</p><p>计算（0，0）- （a,b）的斜率k，使用map&lt;double,a&gt;映射到某个集合上。</p><p>每个集合代表一条直线。</p><p>对同一条直线上的每个点，进行遍历计算：</p><p>对于1的序列，一次全部打倒最优；对于其他数字，逐个击倒最优。</p><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,idx,sum,cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-type">int</span> x,y,w;<br><br><span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x_,<span class="hljs-type">int</span> y_,<span class="hljs-type">int</span> w_)&#123;<br>x = x_;<br>y = y_;<br>w = w_;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(x != rhs.x) <span class="hljs-keyword">return</span> x &lt; rhs.x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> y &lt; rhs.y;<br>&#125;<br>&#125;;<br><br>vector&lt;Point&gt; v[MAX];<br>unordered_map&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span> &gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>idx = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;<br>v[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(x,y,w));<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-type">double</span> k = (<span class="hljs-number">1.0</span>*y)/x;<br><span class="hljs-keyword">if</span>(!mp[k]) mp[k] = idx++;<br>v[mp[k]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(x,y,w));<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; idx ; i ++)&#123;<br><span class="hljs-built_in">sort</span>(v[i].<span class="hljs-built_in">begin</span>(),v[i].<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(Point it : v[i])&#123;<br>sum += it.w;<br><span class="hljs-keyword">if</span>(it.w == last &amp;&amp; it.w == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> cnt++;<br>last = it.w;<br>&#125;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="打怪升级floyddijkstra">3：打怪升级（Floyd+Dijkstra）</h1><img src="/2025/01/13/RAICOM-CAIP/RAICOM-CAIP-2021-%E7%9C%81%E8%B5%9B%E9%A2%98%E8%A7%A3/f21ac592-3c21-4205-aa10-cb39d706afb4.jpeg" class="" title="dgsj.JPG"><p>很多游戏都有打怪升级的环节，玩家需要打败一系列怪兽去赢取成就和徽章。这里我们考虑一种简单的打怪升级游戏，游戏规则是，给定有<em>N</em>个堡垒的地图，堡垒之间有道路相连，每条道路上有一只怪兽把守。怪兽本身有能量，手里的武器有价值。打败怪兽需要的能量等于怪兽本身的能量，而怪兽一旦被打败，武器就归玩家所有—— 当然缴获的武器价值越高，玩家就越开心。</p><p>你的任务有两件：</p><ul><li><ol type="1"><li>帮助玩家确定一个最合算的空降位置，即空降到地图中的某个堡垒，使得玩家从这个空降点出发，到攻下最难攻克（即耗费能量最多）的那个堡垒所需要的能量最小；</li></ol></li><li><ol type="1"><li>从这个空降点出发，帮助玩家找到攻克任意一个其想要攻克的堡垒的最省能量的路径。如果这种路径不唯一，则选择沿途缴获武器总价值最高的解，题目保证这种解是唯一的。</li></ol></li></ul><h3 id="输入格式-2">输入格式</h3><p>输入第一行给出两个正整数 <em>N</em> (≤1000) 和 <em>M</em>，其中<em>N</em> 是堡垒总数，<em>M</em> 是怪兽总数。为简单起见，我们将堡垒从 1到 <em>N</em> 编号。随后 <em>M</em> 行，第 <em>i</em> 行给出了第<em>i</em> 只怪兽的信息，格式如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">B1 </span><span class="hljs-keyword">B2 </span>怪兽能量 武器价值<br></code></pre></td></tr></table></figure><p>其中 <code>B1</code> 和 <code>B2</code>是怪兽把守的道路两端的堡垒编号。题目保证每对堡垒之间只有一只怪兽把守，并且<code>怪兽能量</code> 和 <code>武器价值</code> 都是不超过 100的正整数。</p><p>再后面是一个正整数 <em>K</em>（≤<em>N</em>）和玩家想要攻克的<em>K</em> 个目标堡垒的编号。</p><h3 id="输出格式-2">输出格式</h3><p>首先在一行中输出玩空降的堡垒编号<code>B0</code>。如果有多种可能，则输出编号最小的那个。</p><p>随后依次为玩家想要攻克的每个堡垒 <code>B</code>推荐最省能量的攻克路径，并列出需要耗费的能量值和沿途缴获武器的总价值。注意如果最省力的路径不唯一，则选择沿途缴获武器总价值最高的解。格式为：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">B0-&gt;途经堡垒<span class="hljs-number">1</span>-&gt;...-&gt;B<br>总耗费能量 武器总价值<br></code></pre></td></tr></table></figure><h3 id="输入样例-2">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs in">6 12<br>1 2 10 5<br>2 3 16 20<br>3 1 4 2<br>2 4 20 22<br>4 5 2 2<br>5 3 12 6<br>4 6 8 5<br>6 5 10 5<br>6 1 20 25<br>1 5 8 5<br>2 5 2 1<br>2 6 8 5<br>4<br>2 3 6 5<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs out">5<br>5-&gt;2<br>2 1<br>5-&gt;1-&gt;3<br>12 7<br>5-&gt;4-&gt;6<br>10 7<br>5<br>0 0<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>使用Floyd找到起点，根据该起点，使用双权值的Dijkstra求"最短路"，并记录路径。</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> d;<br><span class="hljs-type">int</span> w;<br><br><span class="hljs-built_in">Edge</span>()&#123;<br>d = INF;<br>w = -INF;<br>&#125;<br><span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> d_,<span class="hljs-type">int</span> w_)&#123;<br>d = d_;<br>w = w_;<br>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m,k,s;<br>Edge edge[MAX][MAX];<br><span class="hljs-type">int</span> dist[MAX],val[MAX],path[MAX];<br><span class="hljs-type">int</span> flEdge[MAX][MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>flEdge[i][j] = edge[i][j].d;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= n ; t ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(flEdge[i][t] == INF) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>flEdge[i][j] = <span class="hljs-built_in">min</span>(flEdge[i][j],flEdge[i][t] + flEdge[t][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> max_ = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(j != i) max_ = <span class="hljs-built_in">max</span>(max_,flEdge[i][j]);<br>&#125;<br><span class="hljs-keyword">if</span>(max_ &lt; min_)&#123;<br>min_ = max_;<br>res = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i].d;<br>val[i] = edge[s][i].w;<br>path[i] = s;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ;i ++)&#123;<br><span class="hljs-type">int</span> now = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>now = j;<br>&#125; <br>&#125;<br>visited[now] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[now] + edge[now][j].d)&#123;<br>dist[j] = dist[now] + edge[now][j].d;<br>val[j] = val[now] + edge[now][j].w;<br>path[j] = now;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[now] + edge[now][j].d &amp;&amp; val[j] &lt; val[now] + edge[now][j].w)&#123;<br>dist[j] = dist[now] + edge[now][j].d;<br>val[j] = val[now] + edge[now][j].w;<br>path[j] = now;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,d,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;d&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">Edge</span>(d,w);<br>edge[y][x] = <span class="hljs-built_in">Edge</span>(d,w);<br>&#125;<br>s = <span class="hljs-built_in">floyd</span>();<br>cout&lt;&lt;s&lt;&lt;endl;<br><span class="hljs-built_in">dijkstra</span>();<br>cin&gt;&gt;k;<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">int</span> to;cin&gt;&gt;to;<br><span class="hljs-type">int</span> tep = to;<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><span class="hljs-keyword">while</span>(tep != s)&#123;<br>st.<span class="hljs-built_in">push</span>(tep);<br>tep = path[tep];<br>&#125;st.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;st.<span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() != to) cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;cout&lt;&lt;endl;<br><span class="hljs-type">int</span> res1 = dist[to] == INF?<span class="hljs-number">0</span>:dist[to];<br><span class="hljs-type">int</span> res2 = val[to] == -INF?<span class="hljs-number">0</span>:val[to];<br>cout&lt;&lt;res1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res2&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="疫情防控并查集">4：疫情防控（并查集）</h1><p>疫情尚未结束，严防疫情反复。为了做好疫情防控工作，国内设置了地区风险等级，对于中高风险地区的人员采取限制移动、居家隔离等手段。</p><p>为了研究疫情防控对于跨地区交通运输的影响，假设现在有 <em>N</em>个机场，<em>M</em>条航线，每天都会新增一个防控地区，一个防控地区会导致一个机场无法正常运作，航线也自然无法正常运行，每天会有*Q**i* 对旅客从 *X**i* 机场前往 *Y**i*机场，请计算有多少对旅客会受到影响无法完成行程。</p><p>旅客只要能直达或通过若干次中转，且乘坐的所有航线的出发和到达机场都正常运作，即视作可完成行程。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是三个整数 <em>N</em>,<em>M</em>,<em>D</em>(1≤<em>N</em>≤5×104, 1≤<em>M</em>≤2×105, 1≤<em>D</em>≤103),表示机场数、航线数以及新增防控地区的天数。</p><p>接下来首先有 <em>M</em> 行，每行给出空格分隔的两个数字 <em>A</em> 和<em>B</em>，表示编号为 <em>A</em> 和 <em>B</em>的机场之间有一条航线。航线是双向的，机场编号从 1 到 <em>N</em>。</p><p>然后是 <em>D</em> 块输入，每块输入内第一行为空格分隔的两个整数<em>C</em> 和 <em>Q</em> （1≤<em>Q</em>≤103)，表示新增机场编号为<em>C</em> 所在的城市为防控地区，今天有 <em>Q</em>段行程。数据保证新增的城市之前一定不是防控地区。</p><p>接下来的 <em>Q</em> 行，每行是空格分隔的两个数字 <em>X</em> 和<em>Y</em>，表示编号为 <em>X</em> 和 <em>Y</em>的机场的一段行程。行程有可能包括之前就已经成为防控地区的城市。</p><h3 id="输出格式-3">输出格式</h3><p>对于每天的询问，请在一行中输出在新增了一个防控地区后当天的行程有多少不能成行。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs in">5 5 3<br>1 2<br>1 3<br>1 5<br>2 5<br>3 4<br>4 3<br>1 3<br>1 4<br>2 3<br>5 3<br>3 4<br>2 3<br>3 5<br>1 3<br>2 3<br>2 5<br>3 4<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">1<br>2<br>3<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>本质是：需要多次判断两点是否连通，在这个过程中，逐步从图中删除点，维护连通性。</p><p>考虑使用并查集，并查集在查找过程中会优化路径，进行删除操作后无法保证图联通的正确性。</p><p>但是，加入新边的操作能够保证连通性正确。</p><p>因此，可以在创建图时只保留始终未被删除的点，并将每次的操作存储。</p><p>从后往前遍历每次操作，查询连通性并统计，并不断恢复被删除的点。</p><h3 id="代码-3">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5e4</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m,d;<br><span class="hljs-type">int</span> pre[MAX],back[MAX];<br><span class="hljs-type">bool</span> deleted[MAX];<br>stack&lt;<span class="hljs-type">int</span> &gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[MAX];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; querys[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initSet</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy) pre[fx] = fy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;<br><span class="hljs-built_in">initSet</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>e[x].<span class="hljs-built_in">push_back</span>(y);<br>e[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; d ; i ++)&#123;<br><span class="hljs-type">int</span> cnt;<br>cin&gt;&gt;back[i]&gt;&gt;cnt;<br>deleted[back[i]] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(cnt--)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>querys[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(a,b));<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(deleted[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to : e[i])&#123;<br><span class="hljs-keyword">if</span>(deleted[to]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">Union</span>(i,to);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = d<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; q : querys[i])&#123;<br><span class="hljs-type">int</span> x = q.first;<br><span class="hljs-type">int</span> y = q.second;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) res++;<br>&#125;<br>ans.<span class="hljs-built_in">push</span>(res);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to : e[back[i]])&#123;<br><span class="hljs-keyword">if</span>(deleted[to]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">Union</span>(back[i],to);<br>&#125;<br>deleted[back[i]] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-BFS</title>
    <link href="/2025/01/13/DFS-BFS/DFS-BFS/"/>
    <url>/2025/01/13/DFS-BFS/DFS-BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs模板">DFS模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">for</span>(...)&#123;<br>        <span class="hljs-comment">//judge next node</span><br>        <span class="hljs-keyword">if</span>(!visited[nx] &amp;&amp; ...)&#123;<br>            <span class="hljs-built_in">dfs</span>(nx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bfs模板">BFS模板</h1><p>写法1：由于在插入队列时，没有标记visited，导致queue中出现重复点，但是可被continue过滤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(visited[f]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// must write</span><br>        visited[f] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// do something</span><br>        <span class="hljs-keyword">for</span>(...)&#123;<br>            <span class="hljs-comment">// judge next node</span><br>            <span class="hljs-keyword">if</span>(!visited[f] &amp;&amp; ...)&#123;<br>                q.<span class="hljs-built_in">push</span>(nx)  <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：在输入时就标记新点，queue中无重复点，这种写法更好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    visited[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// must write</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//do something</span><br>        <br>        <span class="hljs-keyword">for</span>(...)&#123;<br>            <span class="hljs-comment">//judge next node</span><br>            <span class="hljs-keyword">if</span>(!visited[nx] &amp;&amp; ...)&#123;<br>                visited[nx] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(nx);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD-LCM</title>
    <link href="/2025/01/13/%E6%95%B0%E8%AE%BA/GCD-LCM/"/>
    <url>/2025/01/13/%E6%95%B0%E8%AE%BA/GCD-LCM/</url>
    
    <content type="html"><![CDATA[<h1 id="gcd-最大公约数">GCD-最大公约数</h1><p>辗转相除法：两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数</p><p>假设有两个数字[12921，4234]。将两数中较大的那一个看作是被除数A，将较小的那一个看作是除数B二者相除的商记作C，余数记作D。这样我们就可以得到一个等式：</p><p>​ A = B×C + D</p><p>而辗转相除法的所要用到的原理则是：(A , B) = (B , D)</p><p>(12921,4234) -&gt; (4234,219) -&gt; (219,73) -&gt; (73,0)</p><p>当较小的那个数为0时，较大的那个数就是最大公约数</p><p>c++函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//适当的时候，int换成ll</span><br><span class="hljs-keyword">if</span> (x &lt; y)<br><span class="hljs-built_in">swap</span>(x,y); <span class="hljs-comment">//确保x大于y</span><br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> x; <span class="hljs-comment">//y == 0时，返回x</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(y,x%y); <span class="hljs-comment">//y ！= 0，继续运算</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lcm-最小公倍数">LCM-最小公倍数</h1><p>若要求最小公倍数，只需要将两数的乘积除以最大公约数就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;  <span class="hljs-comment">//两个数的最小公倍数等于乘积/最大公约数</span><br><span class="hljs-keyword">return</span> (x*y)/<span class="hljs-built_in">gcd</span>(x,y); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛通用技巧</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="inf">1.INF</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br></code></pre></td></tr></table></figure><p>INF这个常量表示最大值</p><p>通常令INF = 0x3f3f3f3f</p><p>相比于INT_MAX，这个值有3个好处：</p><ol type="1"><li>0x3f3f3f3f的十进制是1061109567，也就是10<sup>9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10</sup>9的，所以它==可以作为无穷大使用而不致出现数据大于无穷大的情形。==</li><li>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bitint的表示范围，所以0x3f3f3f3f还==满足了我们“无穷大加无穷大还是无穷大”的需求==。</li><li>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以==要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))==。</li></ol><h1 id="llull">2.LL/ULL</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br></code></pre></td></tr></table></figure><h1 id="debug函数">3.debug函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="hljs-string">&quot; == &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br></code></pre></td></tr></table></figure><h1 id="cincout加速">4.cin/cout加速</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>)<br><span class="hljs-comment">//这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。</span><br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//解除cin与cout的绑定</span><br>cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-comment">//效率比cout&lt;&lt;endl更高</span><br></code></pre></td></tr></table></figure><p>cin cout 和 scanf printf：</p><p>==做题的时候尽量使用scanf printf==，因为cin cout 比 scanfprintf慢20倍左右！</p><p>一旦遇到大数据量，光是读入就有可能跪掉。</p><p>可以使用std::ios::sync_with_stdio(false)这条语句关掉scanf 和cin的同步加快效率。</p><p>但==cin 仍然慢 5倍左右==，而且一旦使用了这条语句，scanf和cin混用可能就会造成一些奇怪的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和、差分</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>对于一个普通的数组而言，求区间和效率----O(n)；区间修改效率----O(n)；单点修改效率----O(1)</p><p>为了更方便地进行区间操作，我们需要构造前后缀数组。</p><h1 id="前缀和">前缀和</h1><p>前缀和指的是用使用一个数组表示另一个数组1-i下标的和。</p><p>例如：int arr[n]，Prefix[i] 表示 1-i 的arr[i]的和</p><p>前缀和数组：求区间和效率----O(1)；区间修改效率----O(n)；单点修改效率----O(n)</p><ul><li>前缀和数组的思想也可以拓展到求 数组 1-i 下标的最大值/最小值</li><li>求后缀数组和求前缀数组是相同操作</li></ul><h2 id="例题1最大数组和">例题1：最大数组和</h2><p><ahref="https://www.lanqiao.cn/problems/3260/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=最大数组和">1.最大数组和- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll t,n,k;<br>ll a[MAX];<br>ll leftsum[MAX],rightsum[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-built_in">memset</span>(leftsum,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(leftsum));<br><span class="hljs-built_in">memset</span>(rightsum,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(rightsum));<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>ll total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>total += a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>leftsum[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span> leftsum[i] = leftsum[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(i == n)&#123;<br>rightsum[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span> rightsum[i] = rightsum[i<span class="hljs-number">+1</span>] + a[i];<br>&#125;<br>ll ans = LONG_LONG_MIN;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br><span class="hljs-type">int</span> j = k - i;<br>ans = <span class="hljs-built_in">max</span>(ans,total - leftsum[<span class="hljs-number">2</span>*i] - rightsum[n<span class="hljs-number">+1</span>-j]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2大石头的搬运工">例题2：大石头的搬运工</h2><p><ahref="https://www.lanqiao.cn/problems/3829/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=大石头的搬运工">1.大石头的搬运工- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br>ll Left[MAX];<br>ll Right[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rock</span>&#123;<br><span class="hljs-type">int</span> w;<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> rock &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(w != rhs.w) <span class="hljs-keyword">return</span> p &lt; rhs.p;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> w &lt; rhs.w;<br>&#125;<br>&#125;r[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_prefix</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ll s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) Left[i] = Left[i<span class="hljs-number">-1</span>] + s*(r[i].p - r[i<span class="hljs-number">-1</span>].p);<br>s += r[i].w;<br>&#125;<br>s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(i &lt; n<span class="hljs-number">-1</span>) Right[i] = Right[i<span class="hljs-number">+1</span>] + s*(r[i<span class="hljs-number">+1</span>].p - r[i].p);<br>s += r[i].w;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>r[i].w = x;<br>r[i].p = y;<br>&#125;<br><span class="hljs-built_in">sort</span>(r,r+n);<br><span class="hljs-built_in">make_prefix</span>();<br>ll min_ = LONG_LONG_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>min_ = <span class="hljs-built_in">min</span>(min_,Left[i]+Right[i]);<br>&#125;<br>cout&lt;&lt;min_;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题3四元组问题">例题3：四元组问题</h2><p>----单调栈+前缀和</p><p>----单调栈可以用来求1-i的 最大 和 次大</p><p><ahref="https://www.lanqiao.cn/problems/3416/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=四元组问题">1.四元组问题- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[MAX],min_[MAX];<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>min_[n<span class="hljs-number">-1</span>] = a[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br>min_[i] = (min_[i<span class="hljs-number">+1</span>],a[i]);<br>&#125;<br><span class="hljs-type">int</span> A = <span class="hljs-number">-999</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-comment">//判断是否符合最终条件</span><br><span class="hljs-keyword">if</span>(A &gt; a[i] &amp;&amp; a[i] &gt; min_[i<span class="hljs-number">+1</span>])&#123; <span class="hljs-comment">// A &gt; C &gt; D ,利用后缀最小值,求出三等于关系</span><br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//对A和B值的更新</span><br>        <span class="hljs-comment">//如果出现一个新的最大值，上次的最大值就会被弹出并保存，也就是次大</span><br>        <span class="hljs-comment">//但这里a[i]不是B的值，我们并不记录B的值，因为后续比较A、C、D无需使用</span><br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt; a[i])&#123; <span class="hljs-comment">// B &gt; A ,利用单调栈求出最大和次大</span><br>A = <span class="hljs-built_in">max</span>(st.<span class="hljs-built_in">top</span>(),A);<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>st.<span class="hljs-built_in">push</span>(a[i]);<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="差分">差分</h1><p>差分数组就是用一个数组表示另一个数据的相邻差，以便进行区间修改操作。</p><p>差分数组的 前缀和 就是 原数组。</p><p>在需要恢复原数组时，需要求差分数组求前缀和。</p><p>前缀和数组：</p><p>1）求区间和效率----O(2*n)</p><p>2）区间修改效率----O(1)</p><p>3）单点修改效率----O(n)</p><h2 id="例题1肖恩的投球游戏">例题1：肖恩的投球游戏</h2><p><ahref="https://www.lanqiao.cn/problems/3693/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的投球">2.肖恩的投球游戏- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll diff[MAX];<br>ll arr[MAX];<br>ll n,q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//从1开始，arr[0] == 0</span><br>cin&gt;&gt;arr[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<span class="hljs-comment">//生成差分数组</span><br>diff[i] = arr[i] - arr[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(q--)&#123;  <span class="hljs-comment">//区间修改</span><br>ll l,r,m;cin&gt;&gt;l&gt;&gt;r&gt;&gt;m;<br>diff[l] += m;<br>diff[r<span class="hljs-number">+1</span>] -= m;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//数组还原</span><br>diff[i] += diff[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;diff[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2泡澡">例题2：泡澡</h2><p><ahref="https://www.lanqiao.cn/problems/3898/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=泡澡">1.泡澡- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span>*(<span class="hljs-number">1e5</span>) + <span class="hljs-number">10</span>;<br>ll arr[MAX];<br>ll diff[MAX];<br>ll n,max_water,rside,lside;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;max_water;<br><span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(arr));<br><span class="hljs-keyword">while</span>(n--)&#123;<br>ll l,r,w;<br>cin&gt;&gt;l&gt;&gt;r&gt;&gt;w;<br>        <span class="hljs-comment">//注意：本题的区间是[l，r)</span><br>diff[l] += w;<br>diff[r] -= w; <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= N ; i ++)&#123;<br>diff[i] += diff[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//恢复原数组</span><br><span class="hljs-keyword">if</span>(diff[i] &gt; max_water)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维差分">二维差分</h1><p>主要用来进行二维数组的正方形区间修改操作，可优化时间复杂度为O(1)</p><p>二维差分数组的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">diff[i][j] = arr[i][j] - arr[i<span class="hljs-number">-1</span>][j] - arr[i][j<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//主对角线两点 - 副对角线两点</span><br></code></pre></td></tr></table></figure><p>二维前缀和数组的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + sum[i][j];<br><span class="hljs-comment">//借此用差分数组恢复原数组</span><br>diff[i][j] = diff[i<span class="hljs-number">-1</span>][j] + diff[i][j<span class="hljs-number">-1</span>] - diff[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br></code></pre></td></tr></table></figure><h2 id="例题1地毯">例题1：地毯</h2><p><a href="https://www.luogu.com.cn/problem/P3397">P3397 地毯 - 洛谷 |计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll arr[MAX][MAX];<br>ll diff[MAX][MAX];<br>ll n,t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(arr));<br><span class="hljs-built_in">memset</span>(diff,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(diff));<br>cin&gt;&gt;n&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>ll x1,x2,y1,y2;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-comment">//主对角线两点++</span><br>diff[x1][y1] ++;<br>diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] ++;<br><span class="hljs-comment">//副对角线两点--</span><br>        diff[x2<span class="hljs-number">+1</span>][y1] --;<br>diff[x1][y2<span class="hljs-number">+1</span>] --;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>            <span class="hljs-comment">//数组还原公式</span><br>arr[i][j] = arr[i<span class="hljs-number">-1</span>][j] + arr[i][j<span class="hljs-number">-1</span>] - arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>cout&lt;&lt;arr[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2肖恩的投球游戏加强版">例题2：肖恩的投球游戏（加强版）</h2><p><ahref="https://www.lanqiao.cn/problems/3694/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的投球">竞赛中心- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll diff[MAX][MAX];<br>ll arr[MAX][MAX];<br>ll n,m,t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;arr[i][j];<br>&#125;<br>&#125; <span class="hljs-comment">//输入原数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>diff[i][j] = arr[i][j] - arr[i<span class="hljs-number">-1</span>][j] - arr[i][j<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125; <span class="hljs-comment">//构造二维差分数组</span><br><span class="hljs-keyword">while</span>(t--)&#123; <span class="hljs-comment">//区域增减操作</span><br>ll x1,y1,x2,y2,v;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;v;<br>diff[x1][y1] += v;<br>diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] += v;<br>diff[x1][y2<span class="hljs-number">+1</span>] -= v;<br>diff[x2<span class="hljs-number">+1</span>][y1] -= v;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//二维差分求前缀和，得到修改后的数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>diff[i][j] = diff[i<span class="hljs-number">-1</span>][j] + diff[i][j<span class="hljs-number">-1</span>] - diff[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br>cout&lt;&lt;diff[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短编辑距离</title>
    <link href="/2025/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2025/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="最短编辑距离levenshtein-distance">最短编辑距离：LevenshteinDistance</h1><h1 id="ld模板">1-LD模板</h1><p><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h2 id="题目描述">题目描述</h2><p>设 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>是两个字符串。我们要用最少的字符操作次数，将字符串 <spanclass="math inline">\(A\)</span> 转换为字符串 <spanclass="math inline">\(B\)</span>。这里所说的字符操作共有三种：</p><ol type="1"><li>删除一个字符；</li><li>插入一个字符；</li><li>将一个字符改为另一个字符。</li></ol><p><span class="math inline">\(A, B\)</span> 均只包含小写字母。</p><h2 id="输入格式">输入格式</h2><p>第一行为字符串 <span class="math inline">\(A\)</span>；第二行为字符串<span class="math inline">\(B\)</span>；字符串 <spanclass="math inline">\(A, B\)</span> 的长度均小于 <spanclass="math inline">\(2000\)</span>。</p><h2 id="输出格式">输出格式</h2><p>只有一个正整数，为最少字符操作次数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sfdqxbw</span><br><span class="hljs-attribute">gfdgw</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于 <span class="math inline">\(100 \%\)</span> 的数据，<spanclass="math inline">\(1 \le |A|, |B| \le 2000\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">2050</span>;<br><br><span class="hljs-type">int</span> dp[MAX][MAX];<br>string s1,s2;<br><span class="hljs-type">int</span> l1,l2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>l1 = s<span class="hljs-number">1.l</span>ength();<br>l2 = s<span class="hljs-number">2.l</span>ength();<br>s1 = <span class="hljs-string">&quot; &quot;</span> + s1;<br>s2 = <span class="hljs-string">&quot; &quot;</span> + s2;<br>    <span class="hljs-comment">//初始化边界</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>dp[i][<span class="hljs-number">0</span>] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2; i ++)&#123;<br>dp[<span class="hljs-number">0</span>][i] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s1[i] == s2[j])&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//跳过</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//插入，删除</span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//修改</span><br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ld路径回溯">2-LD+路径回溯</h1><h2 id="caip-2022-rc-u4-变牛的最快方法">CAIP 2022 RC-u4变牛的最快方法</h2><img src="/2025/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/3b6f7584-a4ba-4d73-a4f5-49b956dd3604.png" class="" title="shu.png"><img src="/2025/01/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/9d18450d-de04-4437-9da4-22f633b8f806.png" class="" title="niu.png"><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><h2 id="输入格式-1">输入格式</h2><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><h2 id="输出格式-1">输出格式</h2><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><h2 id="输入样例">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><h2 id="样例解释">样例解释</h2><p>1、13 更改为 3，随后 5、6、20 不变 2、2 更改为 6，下一个 20 不变 3、1更改为 3 4、第二个 13 更改为 5，随后 9 不变 5、删除下一个 20，后面的 3不变 6、在 28 的前面插入 9 7、28 更改为 20，后面的 3 不变 8、34 更改为6，后面的 6、25、233 不变</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> l1,l2;<br><span class="hljs-type">int</span> a1[MAX],a2[MAX];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pre[MAX][MAX];<br><span class="hljs-type">int</span> op[MAX][MAX],dp[MAX][MAX];<br><br><span class="hljs-comment">//删除 0</span><br><span class="hljs-comment">//改变 1</span><br><span class="hljs-comment">//不变 2</span><br><span class="hljs-comment">//插入 3</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><br><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br><span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br><span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>dp[i][<span class="hljs-number">0</span>] = i;<br>op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>dp[<span class="hljs-number">0</span>][i] = i;<br>op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br><span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br><span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br><br><span class="hljs-keyword">if</span>(min_ == add)&#123;<br>dp[i][j] = add;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>op[i][j] = <span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>dp[i][j] = del;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>op[i][j] = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = rpl;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><br><span class="hljs-type">int</span> x = l1;<br><span class="hljs-type">int</span> y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>|| y &gt; <span class="hljs-number">0</span>)&#123;<br>ans.<span class="hljs-built_in">push</span>(op[x][y]);<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; back = pre[x][y];<br>x = back.first;<br>y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/2025/01/13/%E6%A8%A1%E6%8B%9F/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="进制转换">进制转换</h2><h3 id="k进制转化为10进制">1.k进制转化为10进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//读入一个存储为k进制的数组a，返回一个10进制x</span><br>ll x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; len ; i ++)&#123;<br>x = x*k + a[i]; <span class="hljs-comment">//x = a[0]*k^n + a[1]*k*(n-1)...+a[len]</span><br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进制转化为k进制">2.10进制转化为k进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(ll x,<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//读入一个10进制x，转化为k进制数组a，返回a的长度</span><br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x % k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题_进制转换">3.例题_进制转换</h3><p><a href="https://www.lanqiao.cn/problems/1230/learning/">进制转换 -蓝桥云课 (lanqiao.cn)</a></p><ul><li>把这个k1进制的数转化为k2进制的数，需要10进制来过渡</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans = ans*k + a[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k,ll x)</span></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x%k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-type">int</span> t,k1,k2;<br>string s;<br><span class="hljs-type">int</span> num[<span class="hljs-number">1000</span>],ans[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;k1&gt;&gt;k2;<br>cin&gt;&gt;s;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num[i] = <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) num[i] = <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;A&#x27;</span> ) + <span class="hljs-number">10</span>;<br>&#125;<br>ll temp = <span class="hljs-built_in">k_to_ten</span>(num,len,k1);<br><span class="hljs-type">int</span> ans_len = <span class="hljs-built_in">ten_to_k</span>(ans,k2,temp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ans_len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ans[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; ans[i] &lt;= <span class="hljs-number">9</span>) cout&lt;&lt;ans[i];<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">char</span>( <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;A&#x27;</span>) + ans[i] - <span class="hljs-number">10</span>);<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.例题_Alice和Bob的爱恨情仇</p><ul><li>博弈论+进制转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans = ans*k + a[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k,ll x)</span></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x%k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br><br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> GET[<span class="hljs-number">100000</span>];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-type">int</span> temp;cin&gt;&gt;temp;<br>ans += temp;<br><span class="hljs-keyword">if</span>(ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>ll num;<br>cin&gt;&gt;num;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">ten_to_k</span>(GET,k,num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans += GET[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/2025/01/13/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2025/01/13/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>二分思想可以理解成是对枚举的一种优化，假设一个问题的解分布在01区间里，而这种解与某种递增变量有联系。那么，我们可以通过枚举这个变量来得到正解。暴力枚举的方法效率较低，而二分查找优化了这一枚举过程。</p><ul><li>二分题目的关键词：最xx的最xx，比如：最大的最近距离是多少?</li></ul><h1 id="整数二分模板">整数二分模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//关于模板的一些说明：</span><br><span class="hljs-comment">//对于数组 arr[10] = &#123;1,4,5,6,6,6,7,8,9,10&#125;;</span><br><span class="hljs-comment">//若要找到同样满足check的情况下，下标较大者，应该以l为答案</span><br><span class="hljs-comment">//此时查找区间为[l,r-1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[mid] &lt;= x) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l; <span class="hljs-comment">//5</span><br>&#125;<br><span class="hljs-comment">//若要找到同样满足check的情况下，下标较小者，应该以r为答案</span><br><span class="hljs-comment">//此时查找区间为[l+1,r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[mid] &gt;= x) r = mid;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r; <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="浮点二分模板">浮点二分模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>; <span class="hljs-comment">//设置精度</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp;x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x*x + <span class="hljs-number">2</span>*x <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-comment">// f = x^2 + 2x -1;</span><br><span class="hljs-comment">// 求f(x) = m 的 x 的值</span><br><span class="hljs-type">double</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> r = <span class="hljs-number">1e10</span>;<br><span class="hljs-type">double</span> m;cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(r-l &gt;= eps)&#123;<br><span class="hljs-type">double</span> mid = (r+l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid) &gt; m)&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r; <span class="hljs-comment">//输出l或者r可以，没有太大区别</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题1跳石头">例题1：跳石头</h1><p><ahref="https://www.lanqiao.cn/problems/364/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=跳石头">1.跳石头- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll len,n,m;<br>ll rock_pos[MAX];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br>ll last_pos = <span class="hljs-number">0</span>;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(rock_pos[i] - last_pos &lt; x)&#123;<br>ans++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>last_pos = rock_pos[i];<br>&#125;<br><span class="hljs-keyword">if</span>(len - last_pos &lt; x) ans++;<br><span class="hljs-keyword">return</span> ans &gt;= m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;len&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;rock_pos[i];<br>&#125;<br>ll l = <span class="hljs-number">0</span>;<br>ll r = <span class="hljs-number">1e9</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br>ll mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题2肖恩的苹果林">例题2：肖恩的苹果林</h1><p><ahref="https://www.lanqiao.cn/problems/3683/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的苹果林">1.肖恩的苹果林- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll n,m;<br>ll tree_pos[MAX];<br><br><span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br>ll ans = <span class="hljs-number">1</span>;<br>ll last = tree_pos[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(tree_pos[i] - last &gt;= x)&#123;<br>ans++;<br>last = tree_pos[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)&#123;<br>cin&gt;&gt;tree_pos[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(tree_pos<span class="hljs-number">+1</span>,tree_pos<span class="hljs-number">+1</span>+n);<br>ll l = <span class="hljs-number">0</span>;<br>ll r = <span class="hljs-number">1e9</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br>ll mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid) &gt;= m)&#123;<br>l = mid;<br>&#125;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="prim算法">prim算法</h2><img src="/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/v2-a5bb266f04bb7368d08fbe7c950b3924_720w.webp" class="" title="img"><p><a href="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> head[MAX],idx,n,m,dist[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> w;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; from,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; to,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; val)</span></span>&#123;<br>edge[idx].next = head[from];<br>edge[idx].to = to;<br>edge[idx].w = val;<br>head[from] = idx;<br>idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>idx = <span class="hljs-number">0</span>;ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br><span class="hljs-built_in">addEdge</span>(y,x,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> dis = pq.<span class="hljs-built_in">top</span>().first;<br><span class="hljs-type">int</span> pos = pq.<span class="hljs-built_in">top</span>().second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis[pos]) <span class="hljs-keyword">continue</span>;<br>vis[pos] = <span class="hljs-literal">true</span>;<br>ans += dis;<br>cnt ++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[pos] ; j != <span class="hljs-number">-1</span> ; j = edge[j].next)&#123;<br><span class="hljs-type">int</span> t = edge[j].to;<br><span class="hljs-keyword">if</span>(dist[t] &gt; edge[j].w)&#123;<br>dist[t] = edge[j].w;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[t],t));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">prim</span>()) cout&lt;&lt;ans;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kruskal算法">Kruskal算法</h2><h1 id="section"><img src="/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/v2-584bc7761471fd9835cde91b303935ac_720w.webp" class="" title="img"></h1><p><a href="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&quot;\n&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,m,f[MAX],ans;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> x, y, w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> w &lt; rhs.w;<br>    &#125;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(f[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">sort</span>(edge<span class="hljs-number">+1</span>,edge<span class="hljs-number">+1</span>+m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>f[i] = i;<br>&#125;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> scc1 = <span class="hljs-built_in">find</span>(edge[i].x);<br><span class="hljs-type">int</span> scc2 = <span class="hljs-built_in">find</span>(edge[i].y);<br><span class="hljs-keyword">if</span>(scc1 == scc2) <span class="hljs-keyword">continue</span>;<br>ans += edge[i].w;<br>cnt ++;<br>f[scc2] = scc1;<br><span class="hljs-keyword">if</span>(cnt == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == n<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">Kruskal</span>()) cout&lt;&lt;ans;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路问题</title>
    <link href="/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/13/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra">Dijkstra</h1><ul><li>单源最短路径问题</li><li>无法处理负权图</li><li>时间复杂度O（n^2）</li></ul><h3 id="邻接矩阵-无堆优化">（1）邻接矩阵 + 无堆优化</h3><p>（点的数量较少, &lt; 1e5 ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> edge[MAX][MAX];<br><span class="hljs-comment">//如果是无向图，edge[x][y]可优化为edge[x*(x+1)/2 + y];(x&gt;y)</span><br><span class="hljs-type">int</span> dist[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> path[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; <span class="hljs-comment">//初始化</span><br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="hljs-comment">//可改</span><br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123; <span class="hljs-comment">//可改</span><br><span class="hljs-type">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">min</span>(edge[x][y],w);<span class="hljs-comment">//去重</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<span class="hljs-comment">//主干算法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i];<br>path[i] = s;<span class="hljs-comment">//可删</span><br>&#125;<br>visited[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-type">int</span> f;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125; <br>&#125;<br>visited[f] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; edge[s][f] + edge[f][j] &lt; dist[j])&#123;<br>dist[j] = edge[s][f] + edge[f][j];<br>path[j] = f;<span class="hljs-comment">//可删</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表-无堆优化">（2）邻接表 + 无堆优化</h3><p><a href="https://www.luogu.com.cn/problem/P3371">P3371【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> nex,to,w;<br>&#125;e[maxn];<br><br><span class="hljs-type">int</span> head[maxn],dist[maxn];<br><span class="hljs-type">bool</span> visited[maxn];<br><span class="hljs-type">int</span> n,m,s,idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w)</span></span>&#123;<br>e[idx].to = t;<br>e[idx].w = w;<br>e[idx].nex = head[f];<br>head[f] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,inf,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[s] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> t = e[j].to;<br>dist[t] = <span class="hljs-built_in">min</span>(dist[t], e[j].w);<br>&#125;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = inf;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[f] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> to = e[j].to;<br><span class="hljs-keyword">if</span>(!visited[to] &amp;&amp; dist[to] &gt; dist[f] + e[j].w)&#123;<br>dist[to] = dist[f] + e[j].w;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> def = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;(dist[i] == inf ? def:dist[i]);<br><span class="hljs-keyword">if</span>(i != n) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接表-堆优化">（3）邻接表 + 堆优化</h3><p><a href="https://www.luogu.com.cn/problem/P4779">P4779【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> nex,to,w;<br>&#125;e[maxn];<br><br><span class="hljs-type">int</span> head[maxn],dist[maxn];<br><span class="hljs-type">bool</span> visited[maxn];<br><span class="hljs-type">int</span> n,m,s,idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w)</span></span>&#123;<br>e[idx].to = t;<br>e[idx].w = w;<br>e[idx].nex = head[f];<br>head[f] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,inf,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt; q;<br>dist[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;dist[s],s&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">auto</span> top = q.<span class="hljs-built_in">top</span>();<br><span class="hljs-type">int</span> f = top.second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(visited[f]) <span class="hljs-keyword">continue</span>;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[f] ; i != <span class="hljs-number">-1</span> ; i = e[i].nex)&#123;<br><span class="hljs-type">int</span> to = e[i].to;<br><span class="hljs-keyword">if</span>(!visited[to] &amp;&amp; dist[to] &gt; dist[f] + e[i].w)&#123;<br>dist[to] = dist[f] + e[i].w;<br>q.<span class="hljs-built_in">push</span>(&#123;dist[to],to&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> def = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;(dist[i] == inf ? def:dist[i]);<br><span class="hljs-keyword">if</span>(i != n) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="spfa">Spfa</h1><ul><li>可以理解成图上的一种有条件的BFS算法</li><li>处理带负权的单源最短路径问题</li></ul><p>//邻接表</p><p><a href="https://www.luogu.com.cn/problem/P3371">P3371【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EDGE = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NODE = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> head[MAX_NODE],dist[MAX_NODE];<span class="hljs-comment">//头结点、距离数组</span><br><span class="hljs-type">bool</span> inqueue[MAX_NODE];<span class="hljs-comment">//用于判断是否在队列中</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> w;<br>&#125;edge[MAX_EDGE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> val)</span></span>&#123;<br>edge[idx].next = head[from];<br>edge[idx].to = to;<br>edge[idx].w = val;<br>head[from] = idx;<br>idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(inqueue,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(inqueue));<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">add_edge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br>inqueue[s] = <span class="hljs-literal">true</span>;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>inqueue[f] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[f]; i != <span class="hljs-number">-1</span> ; i = edge[i].next)&#123;<br><span class="hljs-type">int</span> t = edge[i].to;<br><span class="hljs-keyword">if</span>(dist[f] + edge[i].w &lt; dist[t])&#123;<br>dist[t] = dist[f] + edge[i].w;<br><span class="hljs-keyword">if</span>(!inqueue[t]) &#123;<br>q.<span class="hljs-built_in">push</span>(t);<br>inqueue[t] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> NOfound = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dist[i] == INF)&#123;<br>cout&lt;&lt;NOfound&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="floyd">Floyd</h1><ul><li><p>多源最短路径问题</p></li><li><p>可以处理负权边，但不能处理负权回路</p></li><li><p>时间复杂度O(n^3)</p></li></ul><p>板子题：</p><p><a href="https://www.luogu.com.cn/problem/P1629">P1629 邮递员送信 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NODE = <span class="hljs-number">1e3</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EDGE = <span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> edge[MAX_NODE][MAX_NODE];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">min</span>(edge[x][y],w);<span class="hljs-comment">//多重边判重！！！</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= n ; k ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(edge[i][k] == INF) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>edge[i][j] = <span class="hljs-built_in">min</span>(edge[i][j], edge[i][k] + edge[k][j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Floyd</span>();<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>ans += edge[<span class="hljs-number">1</span>][i] + edge[i][<span class="hljs-number">1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="dijkstra拓展-1-杂项">Dijkstra拓展-1-杂项</h1><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805379664297984">1087All Roads Lead to Rome - PAT (Advanced Level) Practice</a></p><p>涉及知识点：统计路径数量，路径回溯，多权值（路径短&gt;&gt;价值高&gt;&gt;节点少）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">//Dijkstra集大成者</span><br><span class="hljs-comment">//统计路径数量，路径回溯，多权值（路径短&gt;&gt;价值高&gt;&gt;节点少）</span><br><span class="hljs-comment">//本题没涉及的知识点：多权值（节点价值最大值）</span><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> w[MAX];<br><span class="hljs-type">int</span> edge[MAX][MAX];<br><span class="hljs-type">int</span> cnt[MAX],path[MAX],dist[MAX],val[MAX],num[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br>string st;<br>string name[MAX];<br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>dist[i] = edge[<span class="hljs-number">0</span>][i];<br><span class="hljs-keyword">if</span>(dist[i] != INF)&#123;<br>path[i] = <span class="hljs-number">0</span>;<br>val[i] = w[i];<br>cnt[i] = <span class="hljs-number">1</span>;<br>num[i] = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>path[i] = i;<br>val[i] = <span class="hljs-number">-1</span>;<br>cnt[i] = <span class="hljs-number">0</span>;<br>num[i] = INF;<br>&#125;<br>&#125;<br>visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = val[f] + w[j];<br>path[j] = f;<br>cnt[j] = cnt[f];<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j])&#123;<br><br><span class="hljs-keyword">if</span>(val[j] &lt; val[f] + w[j])&#123;<br>val[j] = val[f] + w[j];<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>path[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val[j] == val[f] + w[j] &amp;&amp; num[j] &gt; num[f] + <span class="hljs-number">1</span>)&#123;<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>path[j] = f;<br>&#125;<br><br>cnt[j] += cnt[f];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(name[x] == st)&#123;<br>cout&lt;&lt;st;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printPath</span>(path[x]);<br>cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;name[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;st;<br>name[<span class="hljs-number">0</span>] = st;<br>mp[st] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>string s;<span class="hljs-type">int</span> w_;cin&gt;&gt;s&gt;&gt;w_;<br>name[i] = s;<br>mp[s] = i;<br>w[i] = w_;<br>&#125;<br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>string sa,sb;<span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;sa&gt;&gt;sb&gt;&gt;c;<br>a = mp[sa];b = mp[sb];<br>edge[a][b] = edge[b][a] = c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>();<br>cout&lt;&lt;cnt[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dist[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;val[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;val[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]/num[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;endl;<br><span class="hljs-built_in">printPath</span>(mp[<span class="hljs-string">&quot;ROM&quot;</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="dijkstra拓展-2-超点">Dijkstra拓展-2-超点</h1><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1697151678120173571&amp;page=1">1175Professional Ability Test - PAT (Advanced Level) Practice</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> e[MAX][MAX],w[MAX][MAX],val[MAX],dist[MAX],path[MAX];<br><span class="hljs-type">int</span> sup = <span class="hljs-number">1002</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> ind[MAX],indTep[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasLoop</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(indTep[i] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>cnt++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(e[f][i] != INF)&#123;<br>indTep[i]--;<br><span class="hljs-keyword">if</span>(indTep[i] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt != n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ind[i] == <span class="hljs-number">0</span>)&#123;<br>dist[i] = e[sup][i] = <span class="hljs-number">0</span>;<br>val[i] = w[sup][i] = <span class="hljs-number">0</span>;<br>path[i] = sup;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dist[i] = e[sup][i] = INF;<br>val[i] = w[sup][i] = <span class="hljs-number">-1</span>;<br>path[i] = i;<br>&#125;<br>&#125;<br>visited[sup] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[f] + e[f][j] &lt; dist[j])&#123;<br>dist[j] = dist[f] + e[f][j];<br>val[j] = val[f] + w[f][j];<br>path[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[f] + e[f][j] == dist[j] &amp;&amp;<br>val[f] + w[f][j] &gt; val[j])&#123;<br>dist[j] = dist[f] + e[f][j];<br>val[j] = val[f] + w[f][j];<br>path[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(e,INF,<span class="hljs-built_in">sizeof</span>(e));<br><span class="hljs-built_in">memset</span>(w,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,s,d;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;e[a][b]&gt;&gt;w[a][b];<br>ind[b]++;<br>indTep[b]++;<br>&#125;<br><span class="hljs-type">bool</span> f = <span class="hljs-built_in">hasLoop</span>();<br><span class="hljs-keyword">if</span>(!f)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Okay.\n&quot;</span>;<br><span class="hljs-built_in">Dijkstra</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Impossible.\n&quot;</span>;<br>&#125;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-type">int</span> q;cin&gt;&gt;q;<br><span class="hljs-keyword">if</span>(f)&#123;<br><span class="hljs-keyword">if</span>(ind[q] == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;You may take test &quot;</span>&lt;&lt;q&lt;&lt;<span class="hljs-string">&quot; directly.\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error.\n&quot;</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(ind[q] == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;You may take test &quot;</span>&lt;&lt;q&lt;&lt;<span class="hljs-string">&quot; directly.\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> t = q;<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><span class="hljs-keyword">while</span>(t != sup)&#123;<br>st.<span class="hljs-built_in">push</span>(t);<br>t = path[t];<br>&#125;<br>cout&lt;&lt;st.<span class="hljs-built_in">top</span>();st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;st.<span class="hljs-built_in">top</span>();st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="dijkstra拓展-3-两次最短路">Dijkstra拓展-3-两次最短路</h1><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805358663417856&amp;page=1">1111Online Map - PAT (Advanced Level) Practice</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,m,s,t;<br><span class="hljs-type">int</span> len[MAX][MAX],tim[MAX][MAX];<br><span class="hljs-type">int</span> dist1[MAX],cost1[MAX],path1[MAX];<br><span class="hljs-type">int</span> sum2[MAX],cost2[MAX],path2[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>dist1[i] = len[s][i];<br>cost1[i] = tim[s][i];<br><span class="hljs-keyword">if</span>(len[s][i] != INF) path1[i] = s;<br><span class="hljs-keyword">else</span> path1[i] = i;<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] &lt; min_)&#123;<br>min_ = dist1[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] &gt; dist1[f] + len[f][j])&#123;<br>dist1[j] = dist1[f] + len[f][j];<br>cost1[j] = cost1[f] + tim[f][j];<br>path1[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] == dist1[f] + len[f][j]<br>&amp;&amp; cost1[j] &gt; cost1[f] + tim[f][j])&#123;<br>dist1[j] = dist1[f] + len[f][j];<br>cost1[j] = cost1[f] + tim[f][j];<br>path1[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cost2[i] = tim[s][i];<br><span class="hljs-keyword">if</span>(len[s][i] != INF)&#123;<br>path2[i] = s;<br>sum2[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> path2[i] = i;<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] &lt; min_)&#123;<br>min_ = cost2[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] &gt; cost2[f] + tim[f][j])&#123;<br>cost2[j] = cost2[f] + tim[f][j];<br>sum2[j] = sum2[f] + <span class="hljs-number">1</span>;<br>path2[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] == cost2[f] + tim[f][j]<br>&amp;&amp; sum2[j] &gt; sum2[f] + <span class="hljs-number">1</span>)&#123;<br>cost2[j] = cost2[f] + tim[f][j];<br>sum2[j] = sum2[f] + <span class="hljs-number">1</span>;<br>path2[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> ty)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == s)&#123;<br>cout&lt;&lt;s;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(ty == <span class="hljs-number">1</span>) <span class="hljs-built_in">PrintPath</span>(path1[x], ty);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">PrintPath</span>(path2[x], ty);<br>cout&lt;&lt;<span class="hljs-string">&quot; -&gt; &quot;</span>;<br>cout&lt;&lt;x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(len,INF,<span class="hljs-built_in">sizeof</span>(len));<br><span class="hljs-built_in">memset</span>(tim,INF,<span class="hljs-built_in">sizeof</span>(tim));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,f,d,ti;cin&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;d&gt;&gt;ti;<br><span class="hljs-keyword">if</span>(f)&#123;<br>len[a][b] = d;<br>tim[a][b] = ti;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>len[a][b] = len[b][a] = d;<br>tim[a][b] = tim[b][a] = ti;<br>&#125;<br>&#125;<br>cin&gt;&gt;s&gt;&gt;t;<br><span class="hljs-built_in">Dijkstra1</span>();<br><span class="hljs-built_in">Dijkstra2</span>();<br><span class="hljs-type">bool</span> same = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> a = t;<span class="hljs-type">int</span> b = t;<br><span class="hljs-keyword">while</span>(a != s &amp;&amp; b != s)&#123;<br><span class="hljs-keyword">if</span>(a != b)&#123;<br>same = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>a = path1[a];<br>b = path2[b];<br>&#125;<br><span class="hljs-keyword">if</span>(same)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Distance = &quot;</span>&lt;&lt;dist1[t]&lt;&lt;<span class="hljs-string">&quot;; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;Time = &quot;</span>&lt;&lt;cost2[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Distance = &quot;</span>&lt;&lt;dist1[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">1</span>);cout&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;Time = &quot;</span>&lt;&lt;cost2[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">2</span>);cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论杂项</title>
    <link href="/2025/01/13/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A1%B9/"/>
    <url>/2025/01/13/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="哈密顿图">哈密顿图</h1><h2 id="定义">定义</h2><ul><li>哈密顿路（通路）：无向图G中，通过图中每个结点一次而且仅一次的路径。</li><li>哈密顿回路：无向图G中，通过图中每个结点一次而且仅一次的回路。</li><li>哈密顿图：具有哈密顿回路的图。</li><li>半哈密顿图：有哈密顿路径而没有哈密顿回路的图。</li></ul><h2 id="推论">推论</h2><blockquote><p>简单图 :在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</p></blockquote><ul><li>图G具有n个结点的无向简单连通图，G中任意两个不相邻的结点度数之和 ≥n-1，则G是半哈密顿图</li><li>图G具有n个结点的无向简单连通图，如果图G中任意一对不相邻结点的度数之和≥ n，则G是哈密顿图</li></ul><h2 id="判断哈密顿回路">判断哈密顿回路</h2><p>例题：<ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805351814119424&amp;page=1">1122Hamiltonian Cycle - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>根据哈密顿回路的定义证明即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!edge[v[i<span class="hljs-number">-1</span>]][v[i]] || vis[v[i]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[v[i]] = <span class="hljs-literal">true</span>;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">return</span> v[len<span class="hljs-number">-1</span>] == v[<span class="hljs-number">0</span>] &amp;&amp; cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个可用于判断的必要条件：回路长度为n+1。</p><p>此外，还需要注意：编号是否在范围内；边是否存在 等</p><h1 id="欧拉图">欧拉图</h1><h2 id="定义-1">定义</h2><ul><li>欧拉（通路）路径：无向图G中，通过图中每个边一次而且仅一次的路径。</li><li>欧拉回路：无向图G中，通过图中每个边一次而且仅一次的回路。</li><li>欧拉图：具有欧拉回路的图。</li><li>半欧拉图：有欧拉路径而没有欧拉回路的图。</li></ul><h2 id="推论-1">推论</h2><ul><li>图G是无向简单连通图，G中每个节点的度都为偶数，则G是欧拉图。</li><li>图G是无向简单连通图，G中恰好有两个节点的度数为奇数，其他节点的度数都是偶数（这两个奇数度的节点恰是所有欧拉回路的起点S和终点T）。</li></ul><h2 id="判断欧拉图">判断欧拉图</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805349851185152&amp;page=1">1126Eulerian Path - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1-非欧拉图 2-半欧拉图 3-欧拉图</span><br>    <br>    <span class="hljs-comment">//并查集判断是否连通</span><br><span class="hljs-type">int</span> scc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-built_in">find</span>(i)) scc++;<br>&#125;<br><span class="hljs-keyword">if</span>(scc != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//求奇数度的点的个数</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(d[i] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全子图团">完全子图（团）</h1><h2 id="定义-2">定义</h2><ul><li><p>图G的团（完全子图）就是一个两两之间有边的顶点集合</p></li><li><p>极大团：增加任一顶点都不再符合团定义的团</p></li><li><p>最大团：顶点最多的极大团，称之为图G的</p></li></ul><h2 id="判断团">判断团</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805343979159552&amp;page=1">1142Maximal Clique - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br>cin&gt;&gt;k;<br>v.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>v.<span class="hljs-built_in">push_back</span>(t);<br>visited[t] = <span class="hljs-literal">true</span>;<br>&#125;<br>    <span class="hljs-comment">//是否为完全子图</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++)&#123;<br><span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!edge[v[i]][v[j]])&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Not a Clique&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//是否为极大完全子图</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(visited[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!edge[v[j]][i])&#123;<br>f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Not Maximal&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="旅行商环路tsp">旅行商环路（TSP）</h1><h2 id="定义-3">定义</h2><p>给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路</p><blockquote><p>给一张带权边的无向图G，求访问每个节点（可重复走边和点）的最短回路。</p></blockquote><h2 id="判断tsp">判断TSP</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1038430013544464384&amp;page=1">1150Travelling Salesman Problem - PAT (Advanced Level) Practice(pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否能走通，并求路径长度</span><br><span class="hljs-type">int</span> dis = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(dist[v[i<span class="hljs-number">-1</span>]][v[i]] == INF)&#123;<br>        dis = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dis += dist[v[i<span class="hljs-number">-1</span>]][v[i]];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dis == <span class="hljs-number">-1</span>)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: NA&quot;</span>&lt;&lt;<span class="hljs-string">&quot; (Not a TS cycle)&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否为经过每个点的环</span><br><span class="hljs-built_in">memset</span>(visNode,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visNode));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(!visNode[v[i]])&#123;<br>        visNode[v[i]] = <span class="hljs-literal">true</span>;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>] != v[k<span class="hljs-number">-1</span>] || cnt != n)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (Not a TS cycle)&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否存在重边</span><br><span class="hljs-built_in">memset</span>(visEdge,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visEdge));<br><span class="hljs-type">bool</span> isSimple = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(visEdge[v[i]][v[i<span class="hljs-number">-1</span>]] || v[i] == v[i<span class="hljs-number">-1</span>])&#123;<br>        isSimple = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    visEdge[v[i]][v[i<span class="hljs-number">-1</span>]] = visEdge[v[i<span class="hljs-number">-1</span>]][v[i]] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(isSimple)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (TS simple cycle)&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (TS cycle)&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>段错误的可能原因</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/%E6%AE%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/%E6%AE%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="导致段错误的可能原因">导致段错误的可能原因</h1><h2 id="数组越界">1.数组越界</h2><p>1）n = INT_MAX?</p><p>有时题目说的范围是int的取值范围，而不是1-n，</p><p>此时，如果使用bool vis[N]来申请会出错，需要使用unordered_map&lt;int,bool&gt; mp;</p><p>2）<code>unsigned int cnt = v.size() - 1</code></p><p>这种写法看似没有问题，但是当v为空时，cnt会赋值为-1，而unsigned int无法表示负数，</p><p>会变为一个很大的正整数，在后续遍历时导致段错误。</p><h2 id="函数错误">2.函数错误</h2><p>Stoi和Stod使用前需保证传入的字符串是合法的数字/小数。</p><p>STL中的front、back和top函数需要配合empty函数使用，为空时访问会报错。</p><h2 id="栈溢出">3.栈溢出</h2><p>有时使用DFS会导致栈空间溢出，此时应该改用BFS+queue的形式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串处理</title>
    <link href="/2025/01/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2025/01/13/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="c-string字符串">C++ : string字符串</h1><h2 id="运算符特性">运算符特性</h2><p>----支持比较运算符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>。支持<code>string</code>与<code>C-string</code>的比较（如<code>str &lt; "hello"</code>）。</p><p>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按<code>字典顺序</code> 进行逐一得 比较。</p><p>字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>----支持<code>+</code><strong>运算</strong>符，代表拼接字符串：string字符串可以拼接，通过”+”运算符进行拼接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br>string s = s1 + s2;<br>cout &lt;&lt; s;   <span class="hljs-comment">//123456</span><br><br>效率上： s1 += s2 相当于 <span class="hljs-built_in">append</span>()/<span class="hljs-built_in">push_back</span>() 快于 s1 + s2<br></code></pre></td></tr></table></figure><h2 id="插入">插入</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push_back()</code></td><td style="text-align: left;">在末尾插入</td></tr><tr><td style="text-align: left;"><code>s.insert(pos,element)</code></td><td style="text-align: left;">在pos位置插入element</td></tr><tr><td style="text-align: left;"><code>s.append(str)</code></td><td style="text-align: left;">在s字符串结尾添加str字符串</td></tr></tbody></table><h2 id="删除">删除</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>erase(it p)</code></td><td style="text-align: left;">删除迭代器p所指的字符</td></tr><tr><td style="text-align: left;"><code>erase(it1 it2)</code></td><tdstyle="text-align: left;">删除迭代器区间<code>[first,last)</code></td></tr><tr><td style="text-align: left;"><code>erase(pos, n)</code></td><td style="text-align: left;">删除从pos开始n个字符</td></tr></tbody></table><h2 id="替换">替换</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.replace(pos,n,str)</code></td><tdstyle="text-align: left;">把当前字符串从索引pos开始的n个字符替换为str</td></tr><tr><td style="text-align: left;"><code>s.replace(pos,n,n1,c)</code></td><tdstyle="text-align: left;">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td></tr><tr><td style="text-align: left;"><code>s.replace(it1,it2,str)</code></td><tdstyle="text-align: left;">把当前字符串<code>[it1,it2)</code>区间替换为str</td></tr></tbody></table><h2 id="子串">子串</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.substr(pos,n)</code></td><td style="text-align: left;">从pos索引开始的n个字符</td></tr><tr><td style="text-align: left;"><code>s.substr(pos)</code></td><td style="text-align: left;">从pos开始到末尾</td></tr></tbody></table><blockquote><p>用 s = substr(n) 来删除前n个字符</p></blockquote><h2 id="查找">查找</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.find (str, pos)</code></td><tdstyle="text-align: left;">从pos开始（默认0），查找子串str，返回找到的字符串的首字符位置</td></tr><tr><td style="text-align: left;"><code>s.find (c, pos)</code></td><tdstyle="text-align: left;">从pos开始（默认0），查找字符c，返回找到字符位置</td></tr><tr><td style="text-align: left;"><code>s.rfind (str, pos)</code></td><td style="text-align: left;">从pos开始，反向找子串s</td></tr><tr><td style="text-align: left;"><code>s.rfind (c, pos)</code></td><td style="text-align: left;">从pos开始，反向找字符c</td></tr></tbody></table><blockquote><p>若找不到，返回值为string::npos，不是-1</p></blockquote><h1 id="char字符">Char字符</h1><h2 id="判断字母数字大小写">判断字母/数字/大小写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">isalpha</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是字母，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isdigit</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是数字，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isalnum</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是字母或数字，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">islower</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是小写字母，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isupper</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是大写字母，如果是返回true(非0值)，反之返回false；</span><br></code></pre></td></tr></table></figure><h2 id="大小写转换">大小写转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">tolower</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//将字符c转换的小写字母，如果字符c无法转换为小写字母，返回字符c；</span><br><span class="hljs-built_in">toupper</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//将字符c转换的大写字母，如果字符c无法转换为大写字母，返回字符c；</span><br></code></pre></td></tr></table></figure><h1 id="c11-to_string">C++11: to_string</h1><p><code>to_string</code> 是 C++11 中引入的一个标准库函数。</p><p>用于将数值类型转换为字符串。它的作用是将整数、浮点数等数值类型转换成对应的字符串表示形式。</p><blockquote><p>to_string可以将int/long long/double等常用类型，转换为string类型</p><p>对于浮点数，to_string 默认会转换为保留小数点后六位的字符串表示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-type">int</span> neg = <span class="hljs-number">-66</span>;<br><span class="hljs-type">double</span> f = <span class="hljs-number">3.14</span>;<br>string s = <span class="hljs-built_in">to_string</span>(num) + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">to_string</span>(neg) + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">to_string</span>(f);<br><span class="hljs-comment">//123 : -66 : 3.140000</span><br></code></pre></td></tr></table></figure><h1 id="c11-stoistollstod">C++11: stoi/stoll/stod</h1><p><code>stoi</code> 和 <code>stod</code> 是 C++ 11标准库中的两个函数，用于将字符串转换为整数或浮点数。</p><blockquote><p>stoi/stoll/stod/报错的可能原因：</p><p>输入字符串<strong>包含非法字符</strong>，不是合法的整数/浮点数类型。</p><p>输入<strong>字符串为空</strong>。</p><p>输入字符串超出了对应类型的表示范围，导致<strong>溢出</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;2.33&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;-1000&quot;</span>;<br>cout&lt;&lt;<span class="hljs-built_in">stod</span>(s1) + <span class="hljs-built_in">stoi</span>(s2);<br><span class="hljs-comment">//-997.67</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算基础">位运算基础</h1><p>1）与运算 &amp; ：对于每个二进制位，当两个数对应的位都为1时，结果才为 1，否则结果为 0</p><p>例如 ：使用&amp;1来取某个二进制数n的第k位 ： n &amp; (1 &lt;&lt;k)</p><p>2）或运算 | ：对于每个二进制位，当两个数对应的位都为 0时，结果才为0，否则结果为 1</p><p>3）异或运算^：对于每个二进制位，当两个数对应的位相同时，结果为0，否则结果为 1</p><p>例如：使用^1对某个二进制的第k位取反：n = n ^ (1 &lt;&lt; k)</p><p>4）取反运算 ~：唯一的单元运算符，对一个数的每个二进制位进行取反操作，0变成 1，1 变成0</p><h1 id="判断非负数的奇偶">1）判断非负数的奇偶</h1><p>奇数二进制的最后一位为1，而偶数为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Odd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> ( (n&amp;<span class="hljs-number">1</span>) ? : <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1id="快速取得某数二进制表示的后n位-或-消除后n位">2）快速取得某数二进制表示的后n位或 消除后n位</h1><p>取后n位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x&amp;(<span class="hljs-number">001</span>…<span class="hljs-number">11</span>）<br><span class="hljs-comment">//只留下末n位，其余位去掉（都变为0）</span><br></code></pre></td></tr></table></figure><p>消除后n位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x&amp;(<span class="hljs-number">110</span>…<span class="hljs-number">00</span>）<br><span class="hljs-comment">//去掉末n位都为0，前面的位保留</span><br></code></pre></td></tr></table></figure><h1 id="快速乘以除以2">3）快速乘以/除以2</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">n = n/<span class="hljs-number">2</span>;  <br>n = n*<span class="hljs-number">2</span>;<br><span class="hljs-comment">//n为正数时，等效于</span><br>n = n &gt;&gt; <span class="hljs-number">1</span>; <br>n = n &lt;&lt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>效率差异：在编译器不优化的情况下，&gt;&gt;1的效率高，优先使用位运算</p><p>结果差异：只有在负奇数情况下，二者有差异，其他情况下相同</p><p>例如：</p><ul><li><code>n</code>为非负数时，<code>&gt;&gt; 1</code>和<code>/ 2</code>的结果是一样的</li><li><code>n</code>为负数且还是偶数时，<code>&gt;&gt; 1</code>和<code>/ 2</code>的结果是一样的</li><li><strong><code>n</code>为负数且还是奇数时，<code>&gt;&gt; 1</code>和<code>/ 2</code>的结果是不一样的</strong></li></ul><p><strong>原因</strong>是奇数除二会发生<strong>截断</strong>现象。而<code>&gt;&gt; 1</code>和<code>/ 2</code>在<code>n</code>为负奇数时截断的反向不一样。</p><ul><li><code>-5 / 2 = -(int)2.5 = -2</code>，这里是把绝对值变小了，加个负号，结果就变大了。</li><li><code>-5 &gt;&gt; 1 = (1011) &gt;&gt; 1 = (1101) = -3</code>，假设用<code>4-bit</code>表示一个整数，补码表示。发现结果变小了。</li></ul><h1 id="brian-kernighan-算法">4）Brian Kernighan 算法</h1><ul><li>一个二进制数n，与运算n-1的结果是n的二进制最右端的1变为0的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n<span class="hljs-number">-1</span>) <span class="hljs-comment">//n的二进制最右端的1变为0</span><br><span class="hljs-number">12</span> = <span class="hljs-number">1100</span><br><span class="hljs-number">12</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1011</span><br><span class="hljs-number">12</span>&amp;(<span class="hljs-number">12</span><span class="hljs-number">-1</span>) = <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><ul><li>n &amp; (~n + 1) 提取出整数n最后一位为1的数</li></ul><p>一个二进制数，其与 补码+1 （也就是反码）进行一次与运算的结果能够提取出其最后一位 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">n = <span class="hljs-number">01101</span><br><span class="hljs-comment">//~n 是将n按位取反就是10010</span><br>~n + <span class="hljs-number">1</span> = <span class="hljs-number">10011</span><br><span class="hljs-comment">//最后</span><br>n &amp; (~n + <span class="hljs-number">1</span>) = <span class="hljs-number">00001</span><br><span class="hljs-comment">//也相当于n&amp;（-n）</span><br></code></pre></td></tr></table></figure><h1 id="格雷码">5）格雷码</h1><p>格雷码是一种数的二进制表示法，每一个数都与前一个数只相差一个bit位</p><ul><li>格雷码一种求解策略：</li></ul><p>------奇数 == （奇数-1） 的 最后一位取反</p><p>------偶数 == （偶数-1）的 最后一位1的前一位取反</p><p>使用Brian Kernighan算法可以快速实现格雷码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> bits;<br><br><span class="hljs-comment">//将int型转化为二进制</span><br><span class="hljs-function">string <span class="hljs-title">getBitStr</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> msk = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= bits ; i ++)&#123;<br>ans = (num&amp;msk ? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>) + ans;<br>msk = msk &lt;&lt; <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrayCode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;bits)</span></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,bits)<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>cout&lt;&lt;<span class="hljs-built_in">getBitStr</span>(num)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= x ; i++)&#123;<br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>num = num^<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>num = num^( ((num&amp;( (~num) + <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>) );<br>            <span class="hljs-comment">//Brian Kernighan 算法</span><br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">getBitStr</span>(num)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;bits;<br><span class="hljs-built_in">GrayCode</span>(bits);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C输入输出处理</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="scanf">Scanf</h1><p>常见%格式说明符</p><table><thead><tr><th>格式说明符</th><th>作用</th></tr></thead><tbody><tr><td><strong>c</strong></td><td>读入<strong>单个字符</strong>（后面不会加上空字节）</td></tr><tr><td><strong>s</strong></td><td>读入一个的<strong>字符序列</strong>，后面会加上空字节，遇到空白字符(空格等)完成读取。</td></tr><tr><td><strong>d</strong></td><td>读入可选<strong>有符号十进制整数</strong></td></tr></tbody></table><ul><li>%lld -- long long类型</li></ul><p>使用scanf来处理特殊的输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//例如：02:13:00 - 12:00:57</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d - %d:%d:%d&quot;</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2);<br></code></pre></td></tr></table></figure><h1 id="printf">printf</h1><p>printf的格式控制字符串组成如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">%<span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[width]</span><span class="hljs-selector-attr">[.prec]</span><span class="hljs-selector-attr">[length]</span><span class="hljs-selector-tag">type</span><br></code></pre></td></tr></table></figure><p>也就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">%[标志][最小宽度][.精度][类型长度]类型<br></code></pre></td></tr></table></figure><h2 id="标志--flag">1）标志--flag</h2><p>flags规定输出样式，取值和含义如下：</p><table><thead><tr><th style="text-align: left;">字符</th><th style="text-align: center;">名称</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: left;">-</td><td style="text-align: center;">减号</td><tdstyle="text-align: center;">结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td style="text-align: left;">+</td><td style="text-align: center;">加号</td><td style="text-align: center;">输出符号(正号或负号)</td></tr><tr><td style="text-align: left;">space</td><td style="text-align: center;">空格</td><tdstyle="text-align: center;">输出值为正时加上空格，为负时加上负号</td></tr><tr><td style="text-align: left;">#</td><td style="text-align: center;">井号</td><td style="text-align: center;">type是o、x、X时，增加前缀0、0x、0X。type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。</td></tr><tr><td style="text-align: left;">0</td><td style="text-align: center;">数字零</td><tdstyle="text-align: center;">将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><h2 id="width--最小宽度">2）width--最小宽度</h2><p>用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：</p><p>例如：<code>printf("%06d",1000);</code></p><p>输出：<code>001000</code></p><h2 id="precision--精度字符串长度">3）precision--精度/字符串长度</h2><p>主要用于浮点数和字符串，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8d\n&quot;</span>,<span class="hljs-number">1000</span>);          <span class="hljs-comment">//不足指定宽度补前导0，效果等同于%06d</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>,<span class="hljs-number">1000.123456789</span>);<span class="hljs-comment">//超过精度，截断</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>,<span class="hljs-number">1000.123456</span>);   <span class="hljs-comment">//不足精度，补后置0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8g\n&quot;</span>,<span class="hljs-number">1000.123456</span>);   <span class="hljs-comment">//最大有效数字为8位</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8s\n&quot;</span>,“abcdefghij”);  <span class="hljs-comment">//超过指定长度截断</span><br><span class="hljs-comment">//00001000</span><br><span class="hljs-comment">//1000.12345679</span><br><span class="hljs-comment">//1000.12345600</span><br><span class="hljs-comment">//1000.1235</span><br><span class="hljs-comment">//abcdefgh</span><br></code></pre></td></tr></table></figure><h1 id="sprintf">sprintf</h1><p>sprinf用于将其他类型转化成cstr字符串类型</p><p>用法和printf类似</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> cstring[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sprintf</span>(cstring,<span class="hljs-string">&quot;%02d:%02d:%02d&quot;</span>,h,m,s);<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(cstring)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="sscanf">sscanf</h1><p>sscanf用于将已有字符串转化为其他类型，用法和scanf类似</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> cstring[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">strcpy</span>(cstring,<span class="hljs-string">&quot;Saturday March 25 1989&quot;</span>);<br><span class="hljs-built_in">sscanf</span>(cstring, <span class="hljs-string">&quot;%s %s %d %d&quot;</span>, weekday, month, &amp;day, &amp;year );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP输入输出处理</title>
    <link href="/2025/01/13/%E5%85%B6%E4%BB%96/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"/>
    <url>/2025/01/13/%E5%85%B6%E4%BB%96/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>C++默认输出的总位数最大是6位，包括整数和小数，即setprecision(6)</p><p>常用函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">// 设置总位数为3</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 设置小数部分保留3位，不够补0</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::scientific); <span class="hljs-comment">// 浮点表示法，很少用</span><br><br>cout&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;$&#x27;</span>); <span class="hljs-comment">// 设置填充符号为&#x27;$&#x27;,默认为空格</span><br>cout&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>)&lt;&lt;endl;<span class="hljs-comment">// 设置输出宽度为5，右对齐</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::left)<span class="hljs-comment">// 改为左对齐</span><br>    <br><span class="hljs-type">double</span> f = <span class="hljs-number">2.2</span>;<br>cout&lt;&lt;<span class="hljs-built_in">round</span>(f)&lt;&lt;<span class="hljs-built_in">floor</span>(f)&lt;&lt;<span class="hljs-built_in">ceil</span>(f) <span class="hljs-comment">// 分别是按四舍五入/向下/向上 取整到整数</span><br><span class="hljs-comment">//若要保留4位小数，且向下取整，可以这么写：</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-built_in">floor</span>(f*<span class="hljs-number">10000</span>)/<span class="hljs-number">10000</span>;<br></code></pre></td></tr></table></figure><blockquote><p>setw和setfill，每次cout都要设置</p><p>setiosflags和setprecision只需要设置一次</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序汇总</title>
    <link href="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序">冒泡排序</h1><blockquote><p>稳定排序，时间复杂度O(n2)</p></blockquote><p><ahref="https://www.cnblogs.com/wupeixuan/p/8654026.html">排序算法-冒泡排序- 武培轩 - 博客园 (cnblogs.com)</a></p><style>.ssjgxfeymoft{zoom:67%;}</style><img src="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_%E5%86%92%E6%B3%A1.jpg" class="ssjgxfeymoft" alt="冒泡"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Bubble_sort(冒泡排序)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; e - s ; i++) &#123; <span class="hljs-comment">//一共总次数-1 =（e-s+1)-1 = e-s次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s ; j &lt; e - i ; j ++) &#123;<br><span class="hljs-keyword">if</span> (ori[j] &gt; ori[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(ori[j],ori[j<span class="hljs-number">+1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[j] &gt; v[j<span class="hljs-number">+1</span>])&#123;<br><span class="hljs-built_in">swap</span>(v[j], v[j<span class="hljs-number">+1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序">选择排序</h1><blockquote><p>稳定排序，时间复杂度O(n2)</p></blockquote><p><ahref="https://www.cnblogs.com/wupeixuan/p/8654459.html">排序算法-选择排序- 武培轩 - 博客园 (cnblogs.com)</a></p><style>.qpyjlfdbwvfv{zoom:67%;}</style><img src="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_1609bbf94a844522.jpg" class="qpyjlfdbwvfv" alt="选择"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Selection_sort(选择排序)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s ; i &lt; e ; i ++) &#123;<br><span class="hljs-type">int</span> min_ = ori[i]; <span class="hljs-comment">//每次都找到[i,e]内的最小值ori[f]</span><br><span class="hljs-type">int</span> f = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= e ; j ++) &#123;<br><span class="hljs-keyword">if</span> (ori[j] &lt; min_) &#123;<br>min_ = ori[j];<br>f = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(ori[f],ori[i]);<span class="hljs-comment">//交换ori[f]和ori[i]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> f = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[j] &lt; v[f])&#123;<br>f = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(v[f], v[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序">插入排序</h1><blockquote><p>不稳定排序，最佳n(已经排好序)，最差n2（完全相反）</p></blockquote><p><ahref="https://www.cnblogs.com/wupeixuan/p/8654938.html">排序算法-插入排序- 武培轩 - 博客园 (cnblogs.com)</a></p><style>.atoulpgcpmbv{zoom: 60%;}</style><img src="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_1609bbf94aad18b0.jpg" class="atoulpgcpmbv" alt="插入"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Insert_sort插入排序（扑克牌排序）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s + <span class="hljs-number">1</span> ; i &lt;= e; i ++) &#123;<br><span class="hljs-type">int</span> val = ori[i];<br><span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= s &amp;&amp; ori[j] &gt;= val) &#123;<br>ori[j + <span class="hljs-number">1</span>] = ori[j]; <span class="hljs-comment">//数组往后退</span><br>            j--;<br>&#125;<br>ori[j + <span class="hljs-number">1</span>] = val; <span class="hljs-comment">//插入</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> t = v[i];<br><span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; v[j] &gt; t)&#123;<br>v[j<span class="hljs-number">+1</span>] = v[j];<br>j--;<br>&#125;<br>v[j<span class="hljs-number">+1</span>] = t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序">归并排序</h1><blockquote><p>较为稳定，复杂度与原始数据无关；时间复杂度：O(n*log n)</p><p>缺点是要申请一个等大的数组tmp；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> tmp[])</span> </span>&#123;<br><span class="hljs-type">int</span> m = s + (e - s) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> pt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> p1 = s, p2 = m + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= e) &#123; <span class="hljs-comment">//把已经排好序的数组，合并</span><br><span class="hljs-keyword">if</span> (ori[p1] &lt; ori[p2]) tmp[pt++] = ori[p1++];<br><span class="hljs-keyword">else</span> tmp[pt++] = ori[p2++];<br>&#125;<br><span class="hljs-keyword">while</span> (p1 &lt;= m) tmp[pt++] = ori[p1++];<br><span class="hljs-keyword">while</span> (p2 &lt;= e) tmp[pt++] = ori[p2++];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; pt ; i ++)<br>ori[s + i] = tmp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> tmp[])</span> </span>&#123;<br><span class="hljs-type">int</span> m = s + (e - s) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (e &gt; s) &#123; <span class="hljs-comment">//终止条件</span><br><span class="hljs-built_in">merge_sort</span>(ori, s, m, tmp); <span class="hljs-comment">//切成两半，分别排序；</span><br><span class="hljs-built_in">merge_sort</span>(ori, m + <span class="hljs-number">1</span>, e, tmp);<br><span class="hljs-built_in">merge</span>(ori, s, e, tmp); <span class="hljs-comment">//合并排序好的两半</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, vector&lt;<span class="hljs-type">int</span> &gt; &amp; tep, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = (s+e)/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = mid<span class="hljs-number">+1</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= e)&#123;<br><span class="hljs-keyword">if</span>(v[i] &lt; v[j]) tep[k++] = v[i++];<br><span class="hljs-keyword">else</span> tep[k++] = v[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i &lt;= mid) tep[k++] = v[i++];<br><span class="hljs-keyword">while</span>(j &lt;= e) tep[k++] = v[j++];<br><br><span class="hljs-type">int</span> p = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>v[p++] = tep[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, vector&lt;<span class="hljs-type">int</span> &gt; &amp; tep,<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = (s+e)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">mergeSort</span>(v, tep, s, mid);<br><span class="hljs-built_in">mergeSort</span>(v, tep, mid<span class="hljs-number">+1</span>, e);<br><span class="hljs-built_in">merge</span>(v, tep, s, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序">快速排序</h1><blockquote><p>时间复杂度取决于原数组的有序程度，完全有序时恶化到<spanclass="math inline">\(n^2\)</span></p><p>最好是<span class="math inline">\(O(nlogn)\)</span>，最差是<spanclass="math inline">\(O(n^2)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> k = ori[s];<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = e;<br><span class="hljs-keyword">while</span>(i != j)<br>&#123;<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; ori[j] &gt;= k) j--;<br><span class="hljs-built_in">swap</span>(ori[i],ori[j]);<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; ori[i] &lt;= k) i++;<br>        <span class="hljs-built_in">swap</span>(ori[i],ori[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(ori,s,i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quick_sort</span>(ori,i<span class="hljs-number">+1</span>,e);<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> k = v[s];<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = e;<br><span class="hljs-keyword">while</span>(i != j)&#123;<br><span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; v[j] &gt;= k) j--;<br><span class="hljs-built_in">swap</span>(v[j], v[i]);<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; v[i] &lt;= k) i++;<br><span class="hljs-built_in">swap</span>(v[i], v[j]);<br>&#125;<br><span class="hljs-built_in">quickSort</span>(v, s, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quickSort</span>(v, i<span class="hljs-number">+1</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序">堆排序</h1><p><ahref="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序- dreamcatcher-cx - 博客园 (cnblogs.com)</a></p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3378">P3378【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><blockquote><p>堆的定义：一棵完全二叉树，每个节点的值总是 &gt;= 或 &lt;=其父节点的值</p><p>堆排序的时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p></blockquote><style>.lngypyvpyuxp{zoom: 33%;}</style><img src="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/1024555-20161217182750011-675658660.png" class="lngypyvpyuxp" alt="img"><style>.bpkcfmphhbly{zoom: 33%;}</style><img src="/2025/01/13/%E6%A8%A1%E6%8B%9F/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/1024555-20161217182857323-2092264199.png" class="bpkcfmphhbly" alt="img"><blockquote><p>大顶堆：<span class="math inline">\(arr[i] &gt;= arr[2i+1]\)</span>&amp;&amp; <span class="math inline">\(arr[i] &gt;=arr[2i+2]\)</span></p><p>小顶堆：<span class="math inline">\(arr[i] &lt;= arr[2i+1]\)</span>&amp;&amp; <span class="math inline">\(arr[i] &lt;=arr[2i+2]\)</span></p></blockquote><p>堆排序的基本思路：</p><p>1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</p><p>3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><h2 id="手写堆">手写堆</h2><p>以小根堆为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从某点（坐标）向下调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justDown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-type">int</span> now = p;<br><span class="hljs-keyword">while</span>(now &lt;= siz)&#123;<br><span class="hljs-type">int</span> t = now;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*now &lt;= siz &amp;&amp; heap[<span class="hljs-number">2</span>*now] &lt; heap[t]) t = <span class="hljs-number">2</span>*now;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*now<span class="hljs-number">+1</span> &lt;= siz &amp;&amp; heap[<span class="hljs-number">2</span>*now<span class="hljs-number">+1</span>] &lt; heap[t]) t = <span class="hljs-number">2</span>*now<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(t != now)&#123;<br><span class="hljs-built_in">swap</span>(heap[t], heap[now]);<br>now = t;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//从某点（坐标）向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-type">int</span> now = p;<br><span class="hljs-keyword">while</span>(now &gt;= <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> f = now/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(f &gt;= <span class="hljs-number">1</span> &amp;&amp; heap[f] &gt;= heap[now])&#123;<br><span class="hljs-built_in">swap</span>(heap[now], heap[f]);<br>now = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//直接建堆</span><br><span class="hljs-comment">//读入无序数组</span><br><span class="hljs-comment">//从n/2(最后一个非根节点)开始，逐个向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>siz = n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;heap[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n/<span class="hljs-number">2</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-built_in">justDown</span>(i);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//插入操作</span><br><span class="hljs-comment">//插入一个元素到堆末，从新位置向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>heap[++siz] = x;<br><span class="hljs-built_in">justUp</span>(siz);<br>&#125;<br><br><span class="hljs-comment">//得到最小值，即heap[1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//删除最小值</span><br><span class="hljs-comment">//删除后需要将heap[1]置换为堆末元素，并向下调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz)&#123;<br>heap[<span class="hljs-number">1</span>] = heap[siz--];<br><span class="hljs-built_in">justDown</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stlpriority_queue">STL：priority_queue</h2><blockquote><p>一般情况下用STL的pq就可以实现堆</p><p>缺点：只能删除堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">//默认大根堆</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt; pq; <span class="hljs-comment">//大根堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; pq; <span class="hljs-comment">//小根堆;</span><br><br>q.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//取得堆顶元素，并不会弹出</span><br>q.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//弹出堆顶元素</span><br>q.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//往堆里面插入一个元素</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//查询堆是否为空，为空则返回1否则返回0</span><br>q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//查询堆内元素数量</span><br><br><span class="hljs-comment">//存储结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;    <br>    <span class="hljs-type">int</span> x,y;    <br>    <span class="hljs-type">int</span> times;    <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (point a, point b)&#123;    <br>        <span class="hljs-keyword">return</span> a.times &gt; b.times;    <span class="hljs-comment">//重载小于号使得小的先出队列    </span><br>    &#125;<br>&#125;priority_queue&lt;point&gt; q;<br></code></pre></td></tr></table></figure><h2 id="判断堆">判断堆</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805342821531648&amp;page=1">1147Heaps - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1 - 大根堆，2 - 小根堆，3 - 非堆</span><br><span class="hljs-type">bool</span> ma,mi;<br>ma = mi = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> l = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> r = i*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>((l &lt; n &amp;&amp; layer[l] &gt; layer[i]) || (r &lt; n &amp;&amp; layer[r] &gt; layer[i]))&#123;<br>ma = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ma) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> l = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> r = i*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>((l &lt; n &amp;&amp; layer[l] &lt; layer[i]) || (r &lt; n &amp;&amp; layer[r] &lt; layer[i]))&#123;<br>mi = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(mi) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂、矩阵快速幂</title>
    <link href="/2025/01/12/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2025/01/12/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>时间复杂度：O (logN)</p><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149594&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 快速幂 - 蓝桥云课 (lanqiao.cn)</a></p><p>二进制解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll n)</span></span>&#123;<br>ll ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n)&#123;<br><span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) ans = (ans*a)%MOD;<br>a = (a*a)%MOD;<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">const</span> ll &amp; a,<span class="hljs-type">const</span> ll &amp; n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">return</span> (<span class="hljs-built_in">qpow</span>(a,n<span class="hljs-number">-1</span>)*a) % MOD;<br><span class="hljs-keyword">else</span>&#123;<br>ll temp = <span class="hljs-built_in">qpow</span>(a,n/<span class="hljs-number">2</span>) % MOD;<br><span class="hljs-keyword">return</span> (temp*temp) % MOD;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵快速幂">矩阵快速幂</h1><h2 id="基础">基础</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3390">P3390【模板】矩阵快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><strong>矩阵</strong></p><p>要求矩阵的幂，我们首先要有一个 NxN的矩阵结构体，并重定义矩阵的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span>&#123;<br>ll a[maxn][maxn];<br><span class="hljs-built_in">matrix</span>(ll e = <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>a[i][j] = e*(i == j);<br>&#125;<br>&#125;<br>&#125;<br>matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> matrix &amp; rhs)&#123;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; n ; k ++)&#123;<br>res.a[i][j] = (res.a[i][j] + a[i][k]*rhs.a[k][j]) % mod;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>快速幂</strong></p><p>自定义矩阵乘法后，和整数快速幂类似地，我们可以得到如下的快速幂函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix m, ll t)</span></span>&#123;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-keyword">if</span>(t &amp; <span class="hljs-number">1</span>) res = res*m;<br>m = m*m;<br>t &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主函数</strong></p><p>求给定矩阵的k次幂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-function">matrix <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>        cin&gt;&gt;temp.a[i][j];<br>    &#125;<br>&#125;<br>matrix ans = <span class="hljs-built_in">qpow</span>(temp,k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cout&lt;&lt;ans.a[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; n ; j ++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans.a[i][j];<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求斐波那契数列">求斐波那契数列</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149720&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 斐波那契数列 - 蓝桥云课 (lanqiao.cn)</a></p><p>矩阵快速幂可以以 指数级 加速求和操作，例如：求斐波那契数列。</p><p>由</p><img src="/2025/01/12/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/formula.png" class="" title="fib"><p>我们可以得到公式： <span class="math display">\[\begin{bmatrix}F(n)\\F(n-1)\end{bmatrix} =\begin{bmatrix}  1 &amp; 1\\  1 &amp; 0\end{bmatrix}^{n-1} *\begin{bmatrix}  f(1) \\  f(0)  \end{bmatrix}\]</span></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">fib</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> || x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = res.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>res = <span class="hljs-built_in">qpow</span>(res,x<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> (res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>快速幂</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度-加减乘</title>
    <link href="/2025/01/12/%E6%A8%A1%E6%8B%9F/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%8A%A0%E5%87%8F%E4%B9%98/"/>
    <url>/2025/01/12/%E6%A8%A1%E6%8B%9F/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%8A%A0%E5%87%8F%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<ahref="https://blog.csdn.net/Z1tai/article/details/127681983?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127681983-blog-99888441.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127681983-blog-99888441.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=2">【算法模板】高精度模板（带图详解）SuhyOvO的博客-CSDN博客</a></p><h2 id="正整数加法">1.正整数加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>    <br><span class="hljs-type">int</span> la = a.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lb = b.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> lc = <span class="hljs-built_in">max</span>(la, lb); <span class="hljs-comment">//加起来的数的长度不会超过原先两个数的长度最大值</span><br>    <br><span class="hljs-comment">//逆置字符串，从低位到高位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lc; i++) &#123; <span class="hljs-comment">//其实就是竖式计算</span><br>c[i] += a[i] + b[i]; <span class="hljs-comment">//两数相加，再加上前面计算的进位</span><br>c[i + <span class="hljs-number">1</span>] += c[i]/<span class="hljs-number">10</span>; <span class="hljs-comment">//把进位存到i+1位上</span><br>c[i] %= <span class="hljs-number">10</span>;<br>&#125;<br><br>lc++;<span class="hljs-comment">//如果有进位就多显示一位</span><br><span class="hljs-keyword">while</span> (lc &gt; <span class="hljs-number">1</span> &amp;&amp; c[lc<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) lc--;<span class="hljs-comment">//去除前面的前导零,防止后面逆置输出多余的零</span><br><br><span class="hljs-comment">//重新逆置,从高位到低位</span><br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正整数减法">2.正整数减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">sub</span><span class="hljs-params">(string sa, string sb)</span></span>&#123;<br>    <br>   <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>la = sa.<span class="hljs-built_in">length</span>();<br>lb = ab.<span class="hljs-built_in">length</span>();<br>    lc = <span class="hljs-built_in">max</span>(la, lb);<span class="hljs-comment">//相减的数的长度不会超过原先两个数的长度最大值</span><br>    <br>    string sub = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(la &lt; lb || (la == lb &amp;&amp; (x[la<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span> &lt; y[lb<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)))&#123;<br><span class="hljs-built_in">swap</span>(la, lb);<br><span class="hljs-built_in">swap</span>(sa, sb);<br>sub = <span class="hljs-string">&quot;-&quot;</span>;<br>&#125;<br>    <br><span class="hljs-comment">//逆置字符串，从低位到高位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lc; i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] &lt; b[i]) &#123;<br>a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<span class="hljs-comment">//向高一位借位</span><br>a[i] += <span class="hljs-number">10</span>;<span class="hljs-comment">//给当前位加10</span><br>&#125;<br>c[i] = a[i] - b[i];<span class="hljs-comment">//再两数相减</span><br>&#125;<br><br><span class="hljs-keyword">while</span> ((c[lc - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (lc &gt; <span class="hljs-number">1</span>)) lc--;<span class="hljs-comment">//去除前面的前导零,防止后面逆置输出多余的零</span><br><br><span class="hljs-comment">//重新逆置,从高位到低位</span><br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>res.<span class="hljs-built_in">push_back</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> sub + res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精乘低精">3.高精乘低精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">mul</span><span class="hljs-params">(string x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>la = x.<span class="hljs-built_in">length</span>();<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//对负号的处理</span><br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, la);<br>la--;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) &#123;<br>y = <span class="hljs-built_in">abs</span>(y);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) &#123;<br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, la);<br>la--;<br>y = <span class="hljs-built_in">abs</span>(y);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br>a[i] = a[i] * y + tmp; <span class="hljs-comment">//运算</span><br>tmp = a[i] / <span class="hljs-number">10</span>;<span class="hljs-comment">//进位</span><br>a[i] %= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">//进位不为0</span><br><span class="hljs-keyword">if</span> (tmp != <span class="hljs-number">0</span>) &#123;<br>a[la++] = tmp;<br><span class="hljs-keyword">while</span> (a[la - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//刚存进去的进位，判断是否大于10需要进位</span><br>a[la] = a[la - <span class="hljs-number">1</span>] / <span class="hljs-number">10</span>;<br>a[la - <span class="hljs-number">1</span>] %= <span class="hljs-number">10</span>;<br>la++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> ((a[la - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (la &gt; <span class="hljs-number">1</span>)) la--;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = la - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>ans.<span class="hljs-built_in">push_back</span>(a[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精乘高精">4.高精乘高精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">High_Mul</span><span class="hljs-params">(string x, string  y)</span> </span>&#123;<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br>la = x.<span class="hljs-built_in">length</span>();<br>lb = y.<span class="hljs-built_in">length</span>();<br><br><span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123; <span class="hljs-comment">//对负号的处理</span><br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,la--);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>y = y.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,lb--);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,la--);<br>y = y.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,lb--);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">//长度最大变成两个数的长度之和</span><br>lc = la + lb ;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lb; j++) &#123;<br>c[i + j] += a[i] * b[j];<span class="hljs-comment">//两数相乘，存到对应位置</span><br>c[i + j + <span class="hljs-number">1</span>] += c[i + j] / <span class="hljs-number">10</span>;<span class="hljs-comment">//把进位加到前面一位上</span><br>c[i + j] %= <span class="hljs-number">10</span>;<span class="hljs-comment">//取模存0-9的数</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> ((c[lc - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (lc &gt; <span class="hljs-number">1</span>)) lc--;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精除以低精">5.高精除以低精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">未完待续。。。≡(▔﹏▔)≡<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="/2025/01/12/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/12/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="暴力匹配bf">暴力匹配（BF）</h2><p>时间复杂度 O（n*m）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BF_Search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;txt,<span class="hljs-type">const</span> string &amp;pat)</span></span>&#123; <span class="hljs-comment">//匹配成功，返回下标，否则返回-1</span><br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>(); <br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(txt[i] == pat[j]) &#123;i++ ; j++;&#125;<br><span class="hljs-keyword">else</span> &#123;i -= j<span class="hljs-number">-1</span> ; j = <span class="hljs-number">0</span>;&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(j == lp) <span class="hljs-keyword">return</span> i-lp;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kmp算法">KMP算法</h2><p>时间复杂度 O（n+m）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 1000</span><br><span class="hljs-type">int</span> Next[MAXLEN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;pat,<span class="hljs-type">int</span> Prefix[])</span></span>&#123;<br><span class="hljs-type">int</span> len = pat.<span class="hljs-built_in">length</span>();<br>    Prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这里的Prefix[i]是以i为末位的最长公共前后缀，Prefix[0]初始化为0，作为终止条件</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; pat[i] != pat[j])&#123;j = Prefix[j<span class="hljs-number">-1</span>];&#125;<span class="hljs-comment">//当pat[i] != pat[j]时，需要将j回退到Prefix[j-1]（这是公共前后缀更短的唯一的可能性，避免了重复计算）。若此处的j已经回退到0,则没有更短的可能，循环终止。</span><br><span class="hljs-keyword">if</span>(pat[i] == pat[j])&#123;j++;&#125; <span class="hljs-comment">//若相等，继续遍历</span><br>Prefix[i] = j; <span class="hljs-comment">//记录Prefix[i]</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP_Search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;txt,<span class="hljs-type">const</span> string &amp;pat)</span></span>&#123;<br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//i是后缀末尾</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">//j是前缀末尾</span><br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123; <span class="hljs-comment">//如果i == lt,说明找不到pat；如果j == lp，说明找到了</span><br><span class="hljs-keyword">if</span>(txt[i] == pat[j])&#123;i++;j++;&#125;<span class="hljs-comment">//如果相等，继续匹配下一位</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) i++; <br><span class="hljs-keyword">else</span> &#123;j = Next[j<span class="hljs-number">-1</span>];&#125;<span class="hljs-comment">//否则，j回退到Next[j-1];</span><br>&#125;<br><span class="hljs-keyword">if</span>(j == lp) <span class="hljs-keyword">return</span> i-lp; <span class="hljs-comment">//如果找到，返回i-lp，即pat在txt中的首下标</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果没找到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>KMP统计子串个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMPSearchCount</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; txt,<span class="hljs-type">const</span> string &amp; pat)</span></span>&#123;<br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(txt[i] == pat[j])&#123;i++;j++;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> )&#123;i++;&#125;<br><span class="hljs-keyword">else</span> &#123;j = Prefix[j<span class="hljs-number">-1</span>];&#125;<br><span class="hljs-keyword">if</span>(j == lp)&#123;i -= (lp<span class="hljs-number">-1</span>);j=<span class="hljs-number">0</span>;cnt++;&#125;<span class="hljs-comment">//主要是这里改动了一句</span><br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何基础</title>
    <link href="/2025/01/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/12/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="判断两点是否在同一对角线上">判断两点是否在同一对角线上</h1><p>给定两个点 A(x1,y1) 和 B(x2,y2) B(x2,y2)</p><p>若<code>abs(x1 - x2) == abs(y1 - y2)</code>，两点同一条对角线（/）上。</p><p>若<code>x1 - y1 == x2 - y2</code>，两点在主对角线  上。</p><p>若<code>x1 + y1 == x2 + y2</code>，两点在次对角线 / 上。</p><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805348915855360&amp;page=1">1128N Queens Puzzle - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>以N皇后问题为例：</p><p>O(n2)写法，较为简便，但效率低</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//这里i表示行，col[i]表示列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(col[i] == col[j] || <span class="hljs-built_in">abs</span>(i - j) == <span class="hljs-built_in">abs</span>(col[i] - col[j]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(n)写法，哈希优化，较为繁琐，但效率高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//这里i表示行，col[i]表示列</span><br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">if</span>(vis[col[i]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[col[i]] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//主对角线</span><br>        <span class="hljs-type">int</span> tep = i - col[i] + <span class="hljs-number">1500</span>;<br>        <span class="hljs-keyword">if</span>(vis[tep]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[tep] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//次对角线</span><br>        <span class="hljs-type">int</span> tep = i + col[i];<br>        <span class="hljs-keyword">if</span>(vis[tep]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[tep] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面最近点对</title>
    <link href="/2025/01/12/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
    <url>/2025/01/12/%E5%88%86%E6%B2%BB%E3%80%81%E5%87%8F%E6%B2%BB/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p>模板题</p><p><a href="https://www.luogu.com.cn/problem/P1429">P1429平面最近点对（加强版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><p><a href="https://www.luogu.com.cn/problem/P7883">P7883平面最近点对（加强加强版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><h1 id="题解">题解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">400010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;<br><span class="hljs-type">double</span> x,y;<br>&#125;p[MAX];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt;= <span class="hljs-number">1e-6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpx</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <span class="hljs-comment">//按x排序</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">equal</span>(a.x, b.x)) <span class="hljs-keyword">return</span> a.x &lt; b.x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpy</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <span class="hljs-comment">//按y排序</span><br><span class="hljs-keyword">return</span> a.y &lt; b.y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-type">double</span> res = <span class="hljs-number">1e300</span>;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-type">double</span> midx = p[mid].x;<br>res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">solve</span>(l, mid)); <span class="hljs-comment">//左侧最小距离</span><br>res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">solve</span>(mid<span class="hljs-number">+1</span>, r)); <span class="hljs-comment">//右侧最小距离</span><br>        <span class="hljs-comment">//两点分别位于左右两侧的最小距离</span><br>vector&lt;point&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l ; i &lt;= r ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p[i].x - midx) &lt;= res)&#123;<br>v.<span class="hljs-built_in">push_back</span>(p[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmpy);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt; v.<span class="hljs-built_in">size</span>() &amp;&amp; v[j].y - v[i].y &lt; res; j ++)&#123;<br>res = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist</span>(v[i], v[j]), res);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>, &amp;p[i].x , &amp;p[i].y);<br>&#125;<br><span class="hljs-built_in">sort</span>(p,p+n, cmpx);<br>ans = <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.lf&quot;</span>, ans*ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状压DP</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/</url>
    
    <content type="html"><![CDATA[<h2 id="糖果">糖果</h2><p>原题 ：<ahref="https://www.lanqiao.cn/problems/186/learning/?page=3&amp;first_category_id=1&amp;sort=students_count&amp;name=糖果">4.糖果- 蓝桥云课 (lanqiao.cn)</a></p><p>给n包糖果，共有m种糖果，每包糖果包含k种不同的糖果。现在给出每包糖果的组合，求最少买多少包糖果得到所有类别的糖果。</p><p>设dp[i]为 01状态 i（1表示有，0表示无）下，所需购买的最少糖果包数量。</p><p>状态转移方程为： <span class="math display">\[dp[i\space|\space a[i]] = min(dp[i \space|\space a[i]], dp[i] + 1)\]</span> 和01背包很像，就是从 拿 和 不拿 两种状态转移过来。</p><p>这里的a[i]表示某一包糖果中包含糖果的种类，也用01串表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>        a[i] = a[i]|(<span class="hljs-number">1</span>&lt;&lt;(t<span class="hljs-number">-1</span>));<br>    &#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= (<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span> ; j ++)&#123;<br>        dp[j|a[i]] = <span class="hljs-built_in">min</span>(dp[j|a[i]], dp[j]<span class="hljs-number">+1</span>);<br>    &#125;<br>&#125;<br>cout&lt;&lt;(dp[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>] == inf ? <span class="hljs-number">-1</span>:dp[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><h2 id="互不侵犯">互不侵犯</h2><p><a href="https://www.luogu.com.cn/problem/P1896">SCOI2005 互不侵犯 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给 NxN个格子，放置K个国王，每个国王可以攻击到自己周围的8个格子，求国王之间互相无法攻击的总方案数。</p><p>dp{i, j, s} 表示 到第 i 行，第i行的状态为sit[j],包括第i行在内共放了s个皇帝。</p><p>状态转移方程： <span class="math display">\[dp[i][j][s] = \sum \sum dp[i-1][k][s-tol[j]]\]</span> 枚举当前状态i，上一行状态k 和总数量s，判断合法后，转移过来。</p><p>dfs初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// sit -&gt; 第i个行状态</span><br><span class="hljs-comment">// tol -&gt; 第i个行状态下的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &gt; n)&#123;<br>sit[++cnt] = s;<br>tol[cnt] = sum;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(s,sum,x<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">dfs</span>(s|(<span class="hljs-number">1</span>&lt;&lt;(x<span class="hljs-number">-1</span>)),sum<span class="hljs-number">+1</span>,x<span class="hljs-number">+2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sit[a] &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[a]&lt;&lt;<span class="hljs-number">1</span>) &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[b]&lt;&lt;<span class="hljs-number">1</span>) &amp; sit[a]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>    dp[<span class="hljs-number">1</span>][i][tol[i]] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= cnt ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= cnt ; r ++)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(j, r)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = k ; s &gt;= tol[j] ; s--)&#123;<br>                dp[i][j][s] += dp[i<span class="hljs-number">-1</span>][r][s-tol[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>    ans += dp[n][i][k];<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="最短哈密顿回路tsp">最短哈密顿回路（TSP）</h2><p><a href="https://www.luogu.com.cn/problem/P1171">P1171 售货员的难题 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>位运算基础</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//集合 s 代表当前集合</span><br><span class="hljs-comment">//右数 k 位二进制数 0/1 代表 第 k 号元素 不在集合 / 在集合 里 </span><br><br><span class="hljs-comment">//必备操作1： </span><br><span class="hljs-comment">//将第k个元素加入集合</span><br>s | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//必备操作2：</span><br><span class="hljs-comment">//将第k个元素从集合中删除</span><br>s &amp; (~ (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) );<br><br><span class="hljs-comment">//必备操作3：</span><br><span class="hljs-comment">//1)如果第k个元素在 集合s里， 删除它</span><br><span class="hljs-comment">//2)如果不在，把它加入集合s</span><br><span class="hljs-comment">//可以想象成一盏灯的开关:</span><br><span class="hljs-comment">//按下开关， 明 -&gt; 暗， 暗 -&gt; 明 </span><br>s ^ (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//必备操作4:</span><br><span class="hljs-comment">//判断元素k 是否在集合s里</span><br><span class="hljs-comment">//在：返回1，不在：返回0 </span><br>(s &gt;&gt; (k - <span class="hljs-number">2</span>)) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>dp{S, V}中S表示经过的点，V表示当前S中的最后一个点。</p><p>首先，枚举每个状态S，取S中未到达的点V，和S中已经到达的点U，更新dp{S，V}</p><p>最后，再利用DP[（1&lt;&lt;n） - 1] [V] ,判断最后回到起点的最短距离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> dp[MAX][<span class="hljs-number">21</span>],e[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>cin&gt;&gt;e[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,INF,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//状态 （s，v）；</span><br><span class="hljs-comment">//下一步的点 u</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt;= (<span class="hljs-number">1</span>&lt;&lt;n) - <span class="hljs-number">1</span> ; s ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">1</span> ; u &lt;= n ; u ++)&#123;<br><span class="hljs-keyword">if</span>( !( s &amp; (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>) ))&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span> ; v &lt;= n ; v ++)&#123;<br><span class="hljs-keyword">if</span>( s &amp; (<span class="hljs-number">1</span> &lt;&lt; v<span class="hljs-number">-1</span>) )&#123;<br>dp[s| (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>) ][u] = <span class="hljs-built_in">min</span>(dp[s | (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>)][u], <br>                                                    dp[s][v] + e[v][u]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>ans = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>ans = <span class="hljs-built_in">min</span>(dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i] + e[i][<span class="hljs-number">1</span>], ans);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形DP</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<p>树形DP题单：<ahref="https://www.luogu.com.cn/training/13994#information">0x2 树形dp -题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h1 id="最大点权独立集">最大点权独立集</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P1352">P1352没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149664&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 蓝桥舞会 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一棵n个节点的树，每个节点都有一个权值，要找到一个结点集，使得==树的每条边的两端，不能同时都一个在集合里==，同时==集合权值和最大==。</p><p>说明：这种适用于一张图（选了一个节点，就不能选它相连的邻居）</p><p>解法：创建一个dp[n][2]数组，dp{j，0} 就表示以 j 为根的子树不选 j的最大价值；dp{j，1}表示选 j 的最大价值。</p><p>若选择一个节点的权值，其子节点就无法被选取；若不选择，其子节点可以选，也可以不选。</p><p>由此，我们可以得到如下的转移方程： <span class="math display">\[dp[j, 0] = \sum_{i}^{son} \max(dp[i, 0], dp[i,1]) \\dp[j, 1] = \sum_{i}^{son} dp[i, 0]\]</span> DFS遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>        <span class="hljs-comment">// 此时，子节点已经处理好</span><br>dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[it][<span class="hljs-number">1</span>], dp[it][<span class="hljs-number">0</span>]);<br>dp[x][<span class="hljs-number">1</span>] += dp[it][<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">// 输入权值，初始化DP</span><br>    cin&gt;&gt;dp[i][<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>    <span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>    e[y].<span class="hljs-built_in">push_back</span>(x);<br>    e[x].<span class="hljs-built_in">push_back</span>(y);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h1 id="最小点权覆盖集">最小点权覆盖集</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P2016">P2016战略游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给一棵n个节点的树，每个节点的都有权值，要找到一个结点集，使得==树的每条边的两端，至少有一个在集合里==，同时使得==集合权值和最小==。（这题的节点权值为1）</p><p>和最大点权独立集类似：一个节点若选择，其邻居可以选，也可以不选；一个节点若不选，其邻居一定选。</p><p>状态转移方程如下： <span class="math display">\[dp[j,1] = \sum_{i}^{son} min(dp[i,0],dp[i,1]) \\dp[j,0] = \sum_{i}^{son} dp[i,1]\]</span> DFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>dp[x][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(dp[it][<span class="hljs-number">1</span>], dp[it][<span class="hljs-number">0</span>]);<br>dp[x][<span class="hljs-number">0</span>] += dp[it][<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-type">int</span> x,m;cin&gt;&gt;x&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br>        <span class="hljs-type">int</span> y;cin&gt;&gt;y;<br>        e[x].<span class="hljs-built_in">push_back</span>(y);<br>        e[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// DP初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//DP</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>cout&lt;&lt;<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h1 id="树上背包">树上背包</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P2014">CTSC1997选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>树上背包，也叫 有依赖关系的背包问题。</p><p><strong>题意：</strong>给一个n节点的森林，标号从1-n，每个节点存在一个权值。对这个森林内的每棵有向树，都要求出一条从根出发的路径，所有路径的节点数量和不超过m，同时节点权值和最大。</p><p>首先，设置一个超点0，连接0和每一棵树的根。这样就把n条路径的问题，转化为求0出发的一条路径。</p><p>然后，我们设置一个状态DP数组，dp{u, k} 表示以u节点为根，容量为k的最大权值和。有如下的状态转移方程： <spanclass="math display">\[dp[x, j] = max(dp[x,j], dp[x, j-k] + dp[it][k])\]</span> 此处，x表示父节点，it表示子节点，j 和 k 分别表示到两个节点剩下的容量。</p><p>最后，dfs更新dp数组，我们可以得到ans == dp[0][m]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1：遍历每个子节点 it</span><br><span class="hljs-comment">// 2：遍历到父节点的容量 j</span><br><span class="hljs-comment">// 3：遍历父节点分配给子节点的剩余容量k</span><br><span class="hljs-comment">// 注意k不可以 == j </span><br><span class="hljs-comment">// 需要保证学子节点前，先学习了父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; j ; k ++)&#123;<br>dp[x][j] = <span class="hljs-built_in">max</span>(dp[x][j], dp[x][j-k] + dp[it][k]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m; <br>    m++; <span class="hljs-comment">// 设置了超点，m++</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> x,v;cin&gt;&gt;x&gt;&gt;v;<br>e[x].<span class="hljs-built_in">push_back</span>(i);<br>dp[i][<span class="hljs-number">1</span>] = v; <span class="hljs-comment">// dp初始化</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="换根dp">换根DP</h1><p>模板题： <a href="https://www.luogu.com.cn/problem/P3478">POI2008STA-Station - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给定一个 n个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。</p><p>（一个结点的深度之定义为该节点到根的简单路径上边的数量）</p><p>分析：</p><p>对于一个父节点x，和它的子节点y，</p><p>扭转了x和y的位置以后，y以下（含y）的全部节点（siz[y]）深度都要 +1，其他节点（n-siz[y]）的深度都要 - 1</p><p>假设我们已经知道了以x为根的深度和dp[x]，和分别以x，y为根的子树节点数siz[x], siz[y]。</p><p>那么，我们可以通过如下的状态转移方程，得到dp[y]： <spanclass="math display">\[dp[y] = dp[x] + (n - siz[y]) + siz[y]\]</span> dfs函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 首先，我们dfs求出：以节点1为根时，每棵子树总节点数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x, ll f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br>depth[it] = depth[x] + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>siz[x] += siz[it];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>reDfs函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 然后，再次dfs求出 以每个节点为根的深度和</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reDfs</span><span class="hljs-params">(ll x, ll f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//dp[it] = dp[x] + (n - siz[it]) - siz[it]</span><br>dp[it] = dp[x] + n - <span class="hljs-number">2</span>*siz[it];<br><span class="hljs-built_in">reDfs</span>(it, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 建图</span><br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>    ll u,v;cin&gt;&gt;u&gt;&gt;v;<br>    e[u].<span class="hljs-built_in">push_back</span>(v);<br>    e[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-comment">// dp求最值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) siz[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) dp[<span class="hljs-number">1</span>] += depth[i];<br><span class="hljs-built_in">reDfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(dp[i] &gt; max_)&#123;<br>        max_ = dp[i];<br>        ans = i;<br>    &#125;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp">区间DP</h1><h2 id="石子合并">石子合并</h2><p>原题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149673&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 石子合并 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个石块，需要将所有石块合并为1块，每次合并的花销是两个石块的总重量，每次只能合并相邻的石块。</p><p>求合并的最小花销。设 dp{i, j} 为 合并 从 i 到 j个石块的最小花销，可以得到如下的状态转移方程。 <spanclass="math display">\[dp[i, j] = \min(dp[i][k] + dp[k+1][j] + sum(i, j) | i &lt;= k &lt; j)\]</span> 其中，k为将 [i, j]这一列石块合并的中间点。为了得到最优解，我们需要遍历每一个k。</p><p>注意：必须要以 [i, j]的区间长度 从小到大遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f3f3f3f</span> , <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;prefix[i]<br>    prefix[i] += prefix[i<span class="hljs-number">-1</span>];<br>    dp[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt;= n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br></code></pre></td></tr></table></figure><h2 id="涂色">涂色</h2><p>原题：<ahref="https://www.lanqiao.cn/problems/926/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=926">1.涂色- 蓝桥云课 (lanqiao.cn)</a></p><p>​ <a href="https://www.luogu.com.cn/problem/P4170">CQOI2007 涂色 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给一个长度为n的字符串，每个字符代表一种颜色，比如：G代表绿，R代表红。每次涂色可以涂任意长度的区间，这一次的涂色会覆盖上一次的涂色。求最少的涂色次数。</p><p>设 dp{i, j} 为 正确涂色 从 i 到 j个石块的最少次数，得到状态转移方程： <span class="math display">\[\begin{cases}dp[i][j] = min(dp[i-1][j], dp[i][j-1]) &amp;s[i] == s[j] \\ \\dp[i][j] = min(dp[i][k] + dp[k+1][j]  \space|\space i&lt;=k&lt;j )&amp;s[i] != s[j]\end{cases}\]</span> 对于左右端点相同的情况，当前区间的最少次数等同于删去左端点/右端点 后仍需的涂色次数；</p><p>对于不相同的情况，则需要遍历每一种分解的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;s;<br>n = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++) dp[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span> ; l+i<span class="hljs-number">-1</span> &lt; n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 注意这里的特判</span><br>                dp[l][r] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l<span class="hljs-number">+1</span>][r], dp[l][r<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><h2 id="制作回文串">制作回文串</h2><p>原题：<ahref="https://www.lanqiao.cn/problems/1547/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1547">1.制作回文串- 蓝桥云课 (lanqiao.cn)</a></p><p>给一个长度为n的字符串，字符串有m种不同的字母构成，并给出每种字符插入和删除的花销。</p><p>求将这个字符串构造成回文串的最小花销。</p><p>设 dp{i, j} 为 构造 从 i 到 j区间的回文串所需的花销，得到状态转移方程： <span class="math display">\[\begin{cases}dp[i, j] = dp[i+1][j-1] &amp; s[i] == s[j]\\ \\dp[i, j] = min(dp[i+1][j] + cost[i], dp[i][j-1]+cost[j]) &amp; s[i] !=s[j]\end{cases}\]</span> 左右端点相同时，我们跳过两端；</p><p>不同时，我们选择删除一个花销较小的；</p><p>注意：由于对最终生成的字符串没有要求，插入和删除操作都是相同的，我们选择其中一个较小的即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;m&gt;&gt;n;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">char</span> c;cin&gt;&gt;c;<br>    <span class="hljs-type">int</span> w1,w2;cin&gt;&gt;w1&gt;&gt;w2;<br>    cost[<span class="hljs-built_in">int</span>(c)] = <span class="hljs-built_in">min</span>(w1,w2);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span> ; l &lt; n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 注意特判</span><br>                dp[l][r] = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[l][r] = dp[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r<span class="hljs-number">-1</span>] + cost[<span class="hljs-built_in">int</span>(s[r])], dp[l<span class="hljs-number">+1</span>][r] + cost[<span class="hljs-built_in">int</span>(s[l])]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><h2 id="石子合并2.0">石子合并2.0</h2><p>原题：<a href="https://www.luogu.com.cn/problem/P1880">NOI1995]石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>这题是一道经典的环形区间DP，与1.0的区别是，末尾的石子也可以和队首的石子合并，相当于把链 变成了 环 。</p><p>另外，这道题还要求同时求出 最大值 和 最小值。</p><p>对于 4，5，9，4 这个数组，最后的计算结果可能来自 (4,5,9),4,也可能来自 (4,5) (9,4)。但对于环状的情况，还可能是 (4,4)(5,9)等，类似的情况无法被考虑。</p><p>解决环状区间的办法是 退化为 两个连接的链状区间 来解决。</p><p>首先，我们将两个原数组相连，构造出：4 5 9 4, 4 5 9（末尾的4可以不要）</p><p>按原长度划分，可以得到如下四种情况：</p><p>dp(1,4) ==&gt;4 5 9 4</p><p>dp(2,5) ==&gt;5 9 4 4</p><p>dp(3,6) ==&gt;9 4 4 5</p><p>dp(4,7) ==&gt;4 4 5 9</p><p>我们要做的就是求出所有情况的最值，</p><p>但是无需对每一段都做单独的dp，只需要做一次n*2规模的dp，然后取值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前缀和</span><br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;prefix[i];<br>    prefix[i+n] = prefix[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n*<span class="hljs-number">2</span> ; i ++)&#123;<br>    prefix[i] += prefix[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-comment">// 最小值</span><br><span class="hljs-built_in">memset</span>(dpMin, inf, <span class="hljs-built_in">sizeof</span>(dpMin));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n*<span class="hljs-number">2</span> ; i ++) dpMin[i][i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dpMin[l][r] = <span class="hljs-built_in">min</span>(dpMin[l][r], dpMin[l][k] + dpMin[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br>min_ = inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    min_ = <span class="hljs-built_in">min</span>(min_, dpMin[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-comment">//最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dpMax[l][r] = <span class="hljs-built_in">max</span>(dpMax[l][r], dpMax[l][k] + dpMax[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    max_ = <span class="hljs-built_in">max</span>(max_, dpMax[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;min_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;max_;<br></code></pre></td></tr></table></figure><h2 id="能量项链">能量项链</h2><p>原题：<ahref="https://www.lanqiao.cn/problems/557/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=557">1.能量项链- 蓝桥云课 (lanqiao.cn)</a></p><blockquote><p>题目很复杂，不解释了</p></blockquote><p>这题和石子合并类似，区别累加的数字是一个乘积。</p><p>状态转移方程如下： <span class="math display">\[dp[i, j] = max(dp[i][k] + dp[k+1][j] + v[i]*v[k+1]*v[r+1])\]</span> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;v[i];<br>    v[i+n] = v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dp[l][r] = <span class="hljs-built_in">max</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + v[l]*v[k<span class="hljs-number">+1</span>]*v[r<span class="hljs-number">+1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    ans = <span class="hljs-built_in">max</span>(ans, dp[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="最短编辑距离">最短编辑距离</h2><blockquote><p>求最短编辑距离，也叫“近似串匹配”问题</p></blockquote><p>模板题：<a href="https://www.luogu.com.cn/problem/P2758">P2758编辑距离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;s1&gt;&gt;s2;<br>l1 = s<span class="hljs-number">1.l</span>ength(); s1 = <span class="hljs-string">&quot; &quot;</span> + s1;<br>l2 = s<span class="hljs-number">2.l</span>ength(); s2 = <span class="hljs-string">&quot; &quot;</span> + s2;<br><span class="hljs-comment">//初始化边界</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= l1; i ++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= l2; i ++) dp[<span class="hljs-number">0</span>][i] = i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1[i] == s2[j])&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//跳过</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//插入，删除</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//修改</span><br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p><strong>模板+路径回溯</strong></p><p>CAIP 2022 RC-u4 变牛的最快方法</p><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><p><strong>输入格式</strong></p><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><p><strong>输出格式</strong></p><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br>    <span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br>    <span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>    pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    dp[i][<span class="hljs-number">0</span>] = i;<br>    op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>    pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>    dp[<span class="hljs-number">0</span>][i] = i;<br>    op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">//删除 0 改变 1 不变 2 插入 3</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br>        <span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br>        <span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br>        <span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br>        <span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br>        <span class="hljs-keyword">if</span>(min_ == add)&#123;<br>            dp[i][j] = add;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>            op[i][j] = <span class="hljs-number">3</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>            dp[i][j] = del;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>            op[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = rpl;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>            op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><span class="hljs-type">int</span> x = l1, y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>|| y &gt; <span class="hljs-number">0</span>)&#123;<br>    ans.<span class="hljs-built_in">push</span>(op[x][y]);<br>    pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; back = pre[x][y];<br>    x = back.first, y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>    cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望DP</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/</url>
    
    <content type="html"><![CDATA[<h1 id="期望dp概念">期望DP概念</h1><p>要求一个事件期望，有两种方法：</p><p>一种是根据概率公式，直接求： <span class="math display">\[E(x) = \sum_{i}^{n} x_i*P(x_i)\]</span> 但是这样写程序一般会超时。</p><p>另一种更常见的做法是根据期望的递归公式， <spanclass="math display">\[E(x) = F(E(x-1))\]</span> 来逐步推出所要求的期望值。</p><h1 id="买卡片1">买卡片1</h1><p>卡片一共有k种，现在要买n张卡片，买到每种卡片的概率相同，求买到卡片种类数 的期望。</p><p>首先，假设只买1张卡片，期望肯定为1，因为无论买哪张都是新的种类。</p><p>然后，假设我们已经知道 买i-1张卡片，得到的种类数期望,那么再买到一张的新卡片的期望为 (k - E(i-1)) /k（因为x为1，期望和概率相同）。</p><p>设 买i张卡片，得到的种类数 为 DP{i} , 有 <spanclass="math display">\[dp[i] = dp[i-1] + \frac{k - dp[i-1]}{k}\]</span> 即：买 i 张得到种类数的期望 = 买i-1张...的期望 +再获得一张新卡片的期望</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= k ; i ++)&#123;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1.0</span>*k/(k - i<span class="hljs-number">+1</span>);<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)&lt;&lt;dp[k];<br></code></pre></td></tr></table></figure><h1 id="买卡片2">买卡片2</h1><p>卡片一共有k种，买到每种卡片的概率相同，现在需要不断地购买，求买到k种所需要次数 的期望。</p><p>首先，假设只买1张卡片，期望为1，因为无论买哪张都是新的种类。</p><p>然后，假设目前到手 i-1 种，那么接下来，每次购买，买到第 i 种的概率P== (k - i + 1)/k，那么所需要次数的期望，就是 1/P == k/(k - i +1)。</p><p>由此，我们得到递推式： <span class="math display">\[dp[i] = dp[i-1] + \frac{k}{k-i+1}\]</span> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= k ; i ++)&#123;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1.0</span>*k/(k - i<span class="hljs-number">+1</span>);<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)&lt;&lt;dp[k];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP基础</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="求方案数">求方案数</h1><p>这类问题大的明显特定是，给几个参数，然后要求方案数的个数</p><h2 id="e1-走楼梯">E1-走楼梯</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149631&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 破损的楼梯 - 蓝桥云课 (lanqiao.cn)</a></p><p>经典走楼梯问题的变形，每次走1步，或者2步，但破损的楼梯不能走，求总方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">int</span> p;cin&gt;&gt;p;<br>    broken[p] = <span class="hljs-literal">true</span>;<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(!broken[<span class="hljs-number">1</span>]) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(!broken[i]) dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>])%MOD;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure><h2 id="e2-求方案数">E2-求方案数</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149630&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 建造房屋 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n条街道，每个街道上可以建m个房屋，一共要建k个房屋（在每条街道上，至少建一个房屋），求总方案数</p><p>注意，根据样例，可以知道这题不区分一条街道上房屋的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;k&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br>    dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// dp i j 表示 对前i条街道, 房屋数量为j的方案数量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">//总预算j</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-comment">// 设第i条街道可能建了r个房屋</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= m &amp;&amp; j-r &gt;= i<span class="hljs-number">-1</span> ; r ++)&#123;<br>            dp[i][j] = (dp[i][j] + dp[i<span class="hljs-number">-1</span>][j-r]) % MOD;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][k];<br></code></pre></td></tr></table></figure><h2 id="e4-求方案数">E4-求方案数</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149633&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 可构造的序列总数 - 蓝桥云课 (lanqiao.cn)</a></p><p>求满足如下关系的序列总方案个数：</p><ul><li>序列的长度为 n</li><li>1≤<em>a</em>1≤<em>a</em>2≤<em>a</em>3≤......≤an≤<em>k</em></li><li>ai 是 ai−1的倍数（ i≥2<em>i</em>≥2 ）</li></ul><p>总长度为n，元素至少大于等于1，从左到右依次是上一个元素的倍数。</p><p>dp{i，k}就表示长度为n时，小于k的方案数量。</p><p>从小到大遍历，遍历当前元素的倍数的每个，叠加方案数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;k&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>    dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r*r &lt;= j; r ++)&#123;<br>            <span class="hljs-keyword">if</span>(r*r == j)&#123; <span class="hljs-comment">//两个因子相同，去重</span><br>                dp[i][j] = (dp[i][j]+dp[i<span class="hljs-number">-1</span>][r])%MOD;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j % r == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = (dp[i][j]+dp[i<span class="hljs-number">-1</span>][r]+dp[i<span class="hljs-number">-1</span>][j/r])%MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>    ans = (ans + dp[n][i]) % MOD;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e5-求方案数">E5-求方案数</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149635&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 安全序列 - 蓝桥云课 (lanqiao.cn)</a></p><p>有n个空位，放任意数量个酒桶，每2个酒桶需要间隔k个位置，求总方案数</p><p>从小到大遍历空位数量i，空位数量为i的方案数 == i不放酒桶的方案数 +i放酒桶的方案数</p><p>== i-1个位置的方案数 + i-k-1个位置的方案数( i-k-1 &gt;= 0 ,否则为1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(i-k<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">1</span>)&#123;<br>        dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i-k<span class="hljs-number">-1</span>]) % MOD;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp[i] = (dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure><h2 id="e6-求方案数">E6-求方案数</h2><p><ahref="https://www.lanqiao.cn/problems/389/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=389">1.摆花- 蓝桥云课 (lanqiao.cn)</a></p><p>有n种花，需要摆放m盆，每种花最多摆放a[i]盆，求总方案数。</p><p>设dp{i, k} 为前i种花，摆放k盆的总方案数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>            <span class="hljs-comment">//注意若使用1维数组，这里的r需要从1开始，避免重复累加DP[j]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= a[i] ; r ++)&#123;<br><span class="hljs-keyword">if</span>(j - r &gt;= <span class="hljs-number">0</span>) dp[j] = (dp[j] + dp[j - r])%MOD;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e6-异或运算">E6-异或运算</h2><p>给n个数和一个数x，求子序列中异或和为x的个数。</p><p>设DP{i，j} 表示前i个数，异或和为j的方案总数。</p><p>DP{i，j} 包含两种解，一种不包含a[i], 一种包含a[i], 因此，有 DP{i，j}= DP{i-1, j} + DP{i-1, j ^ a[i]}。</p><p>（假设j中已经包含了a[i]，又有j ^ a[i] ^ a[i] ==j，所以相当于从j这个和中消去了a[i]）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//异或预算的特点：</span><br><br><span class="hljs-comment">//任何数异或0，都等于自身；</span><br><span class="hljs-comment">//任何数异或1，都等于自身取反；</span><br><span class="hljs-comment">//任何数异或自身，都等于0；（注意是a ^ a，与上文的^a不同）；</span><br><span class="hljs-comment">//任何数对同一个数异或两次后，都等于自身</span><br><br>cin&gt;&gt;n&gt;&gt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>now = <span class="hljs-number">1</span>; <span class="hljs-comment">//滚动数组优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">64</span> ; j ++)&#123;<br>        dp[now][j] = (dp[now^<span class="hljs-number">1</span>][j] + dp[now^<span class="hljs-number">1</span>][j^a[i]]) % MOD;<br>    &#125;<br>    now ^= <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;dp[now^<span class="hljs-number">1</span>][x];<br></code></pre></td></tr></table></figure><h1 id="求最优解">求最优解</h1><h2 id="e1-数字三角形">E1-数字三角形</h2><p><ahref="https://www.lanqiao.cn/problems/505/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=505">1.数字三角形- 蓝桥云课 (lanqiao.cn)</a></p><p>给一个n列的数字三角形，要从上走到下，<strong>并且左右步数之差不超过1</strong>，要求总和最大的路径。</p><p>这题是基本的数字三角形的变形，由于左右步数之差不超过1，路径结尾一定落在最后一行的中位数列上，所以我们只需要考虑中位数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= i ; j ++)&#123;<br>        cin&gt;&gt;a[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i ; j &gt;= <span class="hljs-number">1</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">1</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j<span class="hljs-number">-1</span>]) + a[i][j];<br>        <span class="hljs-keyword">else</span> dp[j] = dp[j] + a[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>)&#123;<br>    cout&lt;&lt;dp[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[n/<span class="hljs-number">2</span>], dp[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e2-lis变形">E2-LIS变形</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149632&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 拍照 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一个长度为n的序列，求一个位置P，从P往左走，删除元素，使得其上升；从P往右边走，删除元素，使其下降。位置P需要删除的元素是最少的。</p><p>这题是最长上升子序列问题的变形。从左到右，从右到左，分别求一次最长不下降子序列。然后遍历求最值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    dpL[i] = dpR[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span> ; j &gt;= <span class="hljs-number">1</span> ; j--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt;= a[j])&#123;<br>            dpL[i] = <span class="hljs-built_in">max</span>(dpL[i], dpL[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt;= a[j])&#123;<br>            dpR[i] = <span class="hljs-built_in">max</span>(dpR[i], dpR[j] + <span class="hljs-number">1</span>); <br>        &#125;<br>    &#125;<br>&#125;<br>ans = INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    ans = <span class="hljs-built_in">min</span>(ans, n - (dpL[i] + dpR[i] - <span class="hljs-number">1</span>) );<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e3-最大区间和">E3-最大区间和</h2><p>给一个长度为n的数列， 求最大区间和（结果必须大于等于0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br>v.<span class="hljs-built_in">resize</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;v[i];<br>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> max_ = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//每个区间都可以看作是 最后一个数 + 前n个数</span><br><span class="hljs-comment">//此处使用sum记录，往前加多少个数是最优的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(sum + v[i] &lt; <span class="hljs-number">0</span>)&#123;<br>        sum = <span class="hljs-number">0</span>;<br>        l = i<span class="hljs-number">+1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        sum += v[i];<br>        r = i<span class="hljs-number">+1</span>;<br>        <span class="hljs-keyword">if</span>(sum &gt; max_)&#123;<br>            max_ = sum;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(max_ == <span class="hljs-number">-1</span>) max_ = <span class="hljs-number">0</span>;<br>cout&lt;&lt;max_;<br></code></pre></td></tr></table></figure><h1 id="多维dp">多维DP</h1><h2 id="e1-图上dp">E1-图上DP</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149637&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 地图 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一张长为n，宽为m的矩阵图，可以从上到下，或者从左到右走，但是最多旋转k次，</p><p>求从（1，1）走到（n，m）的路径个数</p><p>dp{i,j,t,p} 表示 走到i，j为止，旋转了k次，此时方向为p的方案个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>        cin&gt;&gt;road[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-comment">//初始化边界</span><br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(road[i][<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= m ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(road[<span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>        dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> ; j &lt;= m ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= k ; t ++)&#123;<br>            <span class="hljs-comment">//每个位置的DP都可以由四个状态转移而来</span><br>            <span class="hljs-keyword">if</span>(road[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                dp[i][j][t][<span class="hljs-number">0</span>] = dp[i][j<span class="hljs-number">-1</span>][t<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + dp[i][j<span class="hljs-number">-1</span>][t][<span class="hljs-number">0</span>];<br>                dp[i][j][t][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][j][t][<span class="hljs-number">1</span>] + dp[i<span class="hljs-number">-1</span>][j][t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br>    ans += dp[n][m][i][<span class="hljs-number">0</span>] + dp[n][m][i][<span class="hljs-number">1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h1 id="背包">01背包</h1><h2 id="e1-01背包变形">E1-01背包变形</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149634&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 最快洗车时间 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n辆车，每辆车要洗<spanclass="math inline">\(t_i\)</span>时间，有两个洗车机器，可以同时运行，求全部洗好需要的时间。</p><p>这题是背包问题，设背包的容量为sum/2，求背包的最大价值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    sum += a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum/<span class="hljs-number">2</span> ; j &gt;= a[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + a[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;sum - dp[sum/<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>另一种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    sum += a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//求其中一个机器可能的时间方案</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum ; j &gt;= a[i] ; j --)&#123;<br>        dp[j] = (dp[j] | dp[j - a[i]]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出答案</span><br>ans = INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= sum/<span class="hljs-number">2</span> ; i++)&#123;<br>    <span class="hljs-keyword">if</span>(dp[i]) ans = <span class="hljs-built_in">min</span>(sum - i,ans);<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e2-01背包变形">E2-01背包变形</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149638&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 电影放映计划 - 蓝桥云课 (lanqiao.cn)</a></p><p>给N部电影，总共播放时间是M分钟，每部电影间至少间隔k分钟，给每部电影的分钟数t_i和利润p_i，</p><p>每部电影可以重复播放，要求最大利润。</p><p>每部电影至少间隔k分钟，只需要给每个<spanclass="math inline">\(t_i\)</span>和m都加上k，然后转化为普通完全背包问题即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;t[i]&gt;&gt;p[i];<br>&#125;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    t[i] += k;<br>&#125;<br>m += k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t[i] ; j &lt;= m ; j ++)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-t[i]] + p[i]);<br>        ans = <span class="hljs-built_in">max</span>(ans, dp[j]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e3-多维01背包">E3-多维01背包</h2><p><ahref="https://www.lanqiao.cn/problems/2223/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2223">1.背包与魔法- 蓝桥云课 (lanqiao.cn)</a></p><p>与普通背包问题不同的是，可以进行对物品1次变形：增加重量k，价值翻倍。</p><p>需要增加一个维度，dp[j][r]表示重量j下进行r次变形的最大重量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>        dp[j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">0</span>], dp[j - w[i]][<span class="hljs-number">0</span>] + v[i]);<br>        dp[j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">1</span>], dp[j - w[i]][<span class="hljs-number">1</span>] + v[i]);<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i] + k) dp[j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">1</span>], dp[j - w[i] - k][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>*v[i]);<br>    &#125; <br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[m][<span class="hljs-number">1</span>], dp[m][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h2 id="e4-01背包变形">E4-01背包变形</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149646&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 倒水 - 蓝桥云课 (lanqiao.cn)</a></p><p>有m升水，n个客人，</p><p>对于第i个客人，不倒水，得到ei满意度；倒ai升的水，得到bi满意度；倒ci升的水，得到di满意度；</p><p>求最高的满意度。</p><p>这题相当于在01背包的基础上增加了更多选择，本质一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        ll x1,x2,x3;<br>        x1 = dp[j] + e[i];<br>        x2 = x3 = LONG_LONG_MIN;<br>        <span class="hljs-keyword">if</span>(j &gt;= a[i]) x2 = dp[j - a[i]] + b[i];<br>        <span class="hljs-keyword">if</span>(j &gt;= c[i]) x3 = dp[j - c[i]] + d[i];<br>        dp[j] = <span class="hljs-built_in">max</span>(x1,<span class="hljs-built_in">max</span>(x2,x3));<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="e5-01背包排序">E5-01背包+排序</h2><p><ahref="https://www.lanqiao.cn/problems/2945/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=课程抢购">1.蓝桥课程抢购- 蓝桥云课</a></p><p>给n个课程，每个课程有持续时间t和价值p，每个课程有截止时间d，必须在d之前做完。</p><p>相比普通的01背包，增加了截止时间d。</p><p>更新区间从[t, m]，变为[t,d]，注意需要对d进行排序，保证先考虑d小的课程。</p><p>sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>&#123;<br>ll t,d,p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> task &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> d &lt; rhs.d;<br>&#125;<br>&#125;a[N];<br></code></pre></td></tr></table></figure><p>main</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a<span class="hljs-number">+1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a[i].d ; j &gt;= a[i].t ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - a[i].t] + a[i].p);<br>        ans = <span class="hljs-built_in">max</span>(dp[j], ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e6-01最小背包">E6-01最小背包</h2><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149649&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 购物策略 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个物品，每个物品需要花t个时间来购买，在每个物品的购买期间，每过1个单位时间，就可以免费获得另外的1个商品，求最小花销。</p><p>这题的限制不是体积，而是数量，我们可以把背包的容量当成是某个数量，买每个物品消耗的数量为t[i]+ 1,</p><p>然后就可以转化为求： 背包体积至少为n的最小花销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;t[i]&gt;&gt;c[i];<br>    t[i]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    dp[i] = INF;<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(ll j = n; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, j - t[i])] + c[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串问题</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<ahref="https://writings.sh/post/algorithm-longest-palindromic-substring#一维动态规划方法">最长回文子串问题（五种方法）| 春水煎茶 (writings.sh)</a></p><h1 id="判断回文字符串">判断回文字符串</h1><p>暴力O(N2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">palin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-keyword">if</span>(s[l++] != s[r--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求最长回文子子串">求最长回文子子串</h1><h2 id="暴力枚举on4">暴力枚举O(N4)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxPalin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len ; i &gt;= <span class="hljs-number">2</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j+i<span class="hljs-number">-1</span> &lt; len ; j ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">palin</span>(s.<span class="hljs-built_in">substr</span>(j,i))) <span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维动态规划on2">二维动态规划O(N2)</h2><p>dp[i][j] 表示 [ i, j ]区间内的子串是否为回文串</p><p>状态转移方程 <span class="math inline">\(dp[l][r] = (s[l] == s[r]\&amp;\&amp; dp[l+1][r-1])\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>    dp[i][i] = <span class="hljs-literal">true</span>;<br>    max_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i<span class="hljs-number">-1</span>] == s[i])&#123;<br>        dp[i<span class="hljs-number">-1</span>][i] = <span class="hljs-literal">true</span>;<br>        max_ = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span> ; i &lt;= len ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j+i<span class="hljs-number">-1</span> &lt; len ; j ++)&#123;<br>        <span class="hljs-type">int</span> l = j;<br>        <span class="hljs-type">int</span> r = j + i - <span class="hljs-number">1</span>;<br>        dp[l][r] = (s[l] == s[r] &amp;&amp; dp[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(dp[l][r]) max_ = <span class="hljs-built_in">max</span>(max_, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一维动态规划on2">一维动态规划O(N2)</h2><p>dp[i] 表示以i结尾的最长回文子串的起始位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxPalin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == s[dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>])&#123;<br>dp[i] = dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> l = dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> r = i;<br><span class="hljs-type">int</span> st = l;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>l++;r--;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l++;r=i;<br>st = l;<br>&#125;<br>&#125;<br>dp[i] = st;<br>&#125;<br>res = <span class="hljs-built_in">max</span>(i - dp[i] + <span class="hljs-number">1</span>, res);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题汇总</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="背包-最优解">01背包 最优解</h1><p>参考：<a href="https://www.acwing.com/blog/content/458/">背包问题中体积至多是 j ，恰好是 j ，至少是 j 的初始化问题的研究 - AcWing</a></p><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149645&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包1 - 蓝桥云课 (lanqiao.cn)</a></p><p>说明1：如果需要限制取走物品的个数，而不是重量，只需要设每个物品的体积为1，再调整背包体积即可</p><p>说明2：如果需要使用LONGLONG，INF可以修改为0x3f3f3f3f3f3f3f3f，但初始化不能用memset，需要遍历DP数组。</p><p>1：给n个物品，并给出每个物品的体积w和价值v，背包体积==不超过m==，求能获得的==最大价值==。</p><p><strong>一维</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 无需进行初始化，DP数组全部为0即可</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2：给n个物品，并给出每个物品的体积w和价值v，背包体积==恰好是m==，求能获得的==最大价值/最小价值==。</p><p>1）最大价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 保证只有递归回到dp[0]的状态会被考虑</span><br><span class="hljs-comment">// dp[0] = 0, 其余为-INF</span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2）最小价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dp[0] = 0, 其余为INF</span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>3：给n个物品，并给出每个物品的体积w和价值v，背包体积==至少是m==，求能获得的==最小价值==。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dp[0] = 0, 其余为INF</span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-comment">// 即使，j - w[i]</span><br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - w[i])] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="背包-方案数">01背包 方案数</h1><p>1：给n个物品，每个物品的体积为v，且只能选一次，求总体积==不超过m==的方案数</p><p><strong>二维</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于方案数问题，二维数组的好处是, dp&#123;i, j&#125;能够表示取前i个物品，体积不超过j的方案数。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>    dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            <span class="hljs-comment">// 拿或者不拿</span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i<span class="hljs-number">-1</span>][j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure><p><strong>一维</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>    dp[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            dp[j] = dp[j] + dp[j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[j] = dp[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2：给n个物品，每个物品的体积为v，且只能选一次，求总体积==恰好是m==的方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//与1唯一的区别在初始化</span><br><span class="hljs-comment">//只有递归会到dp[0]这个状态才被计入方案数，所以只有dp[0] = 1</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            dp[j] = dp[j] + dp[j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[j] = dp[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>3：给n个物品，每个物品的体积为v，且只能选一次，求总体积==至少是m==的方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化和2相同</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-comment">// 即使 j-w[i] &lt; 0，也继续叠加方案数量。</span><br>        <span class="hljs-comment">// 因为这个操作增多的方案数 == 大于m的方案数</span><br>        dp[j] = dp[j] + dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j-w[i])];<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="完全背包">完全背包</h1><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149652&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包2 - 蓝桥云课 (lanqiao.cn)</a></p><p>完全背包和01背包的区别是：完全背包中，每个物品都可以取无限次；而01背包，每个物品只能取1次。</p><p>一维数组的模板的变化很小，只需要修改遍历的方向（状态转移时考虑多次取当前物品）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i] ; j &lt;= m ; j ++)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="多重背包">多重背包</h1><p>多重背包和01背包的区别是：多重背包中，每个物品可以取s个，这个s是题目给定的；而01背包，每个物品只能取1次。</p><h2 id="朴素onsm">朴素O(N*S*M)</h2><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149655&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包3 - 蓝桥云课 (lanqiao.cn)</a></p><p>多重背包可以一般退化为01背包来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">// 区别是每个物品需要跑si次, 就相当于有si个该物品</span><br>    <span class="hljs-keyword">while</span>(s[i]--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="二进制优化onlogsm">二进制优化O(N*logS*M)</h2><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149657&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 新一的宝藏搜寻加强版 - 蓝桥云课 (lanqiao.cn)</a></p><p>在进行二进制优化之前，我们首先要知道：</p><p>对于每一个整数n，都可以用二进制将其分解为：2^0 + 2^1 ... 2^m，而任何小于n的正整数[1, n]，都可以取一其中的几个进行表示。</p><p>例如，10 == 1 + 2 + 4 + 3,</p><p>有 3 == 1 + 2；6 == 1 +2 + 3；7 == 1 + 2 + 4</p><p>因此，我们对于s个物品，我们也可以用二进制的方式对它进行分解，以优化时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> infIsTrue</span><br>    <span class="hljs-comment">//若s[i] == 0时表示无限个，需要结合多重背包</span><br>     <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w[i] ; j &lt;= m ; j ++)&#123;<br>             dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);<br>         &#125;<br>         <span class="hljs-keyword">continue</span>;<br>     &#125;    <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">// k从1开始，逐次加倍</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; s[i] &gt;= k ; s[i] -= k, k += k)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= k*w[i] ; j --)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k*w[i]] + k*v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// s 分解后末尾的值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= s[i]*w[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - s[i]*w[i]] + s[i]*v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="单调队列优化onm">单调队列优化O(N*M)</h2><p>waiting...</p><h1 id="二维费用背包">二维费用背包</h1><p>模板题：<ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149661&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小蓝的神秘行囊 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个物品，并给出每个物品的体积v，重量w和价值p，背包体积不超过V，重量不超过m，求能获得的最大价值。</p><p>只需要在01背包的基础上增加一个维度即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = V ; t &gt;= v[i] ; t --)&#123;<br>            dp[j][t] = <span class="hljs-built_in">max</span>(dp[j][t], dp[j - w[i]][t - v[i]] + p[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分组背包">分组背包</h1><p>给n组物品，每组物品有s个，给出每个物品的重量w和价值p，每组物品只能取其中一个，背包重量不超过m，求能获得的最大价值。</p><p>分组背包问题需要使用二维数组，因为同一组（i）的内不同物品的状态只能从上一组（i-1）转移过来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= m ; j ++) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= cnt[i] ; t ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i][t] ; j --)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j - w[i][t]] + v[i][t]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LIS和LCS</title>
    <link href="/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS%E5%92%8CLCS/"/>
    <url>/2025/01/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS%E5%92%8CLCS/</url>
    
    <content type="html"><![CDATA[<h1 id="lis最长上升子序列">LIS：最长上升子序列</h1><p><ahref="https://blog.csdn.net/lxt_Lucia/article/details/81206439">参考：最长上升子序列(LIS) 详解+例题模板 (全)-CSDN博客</a></p><h2 id="on2">O(N^2)</h2><p>解法：线性DP（N &lt;= 5000）</p><p>dp[i]： 以 i 结尾的最长上升子序列长度</p><p>每次遍历一个位置<code>i</code>，往之前的位置遍历，找到每一个能连接上的序列，保存<code>dp[i]</code>为找到的最大长度。</p><p>1）若要求最长不下降子序列，可将条件 <code>a[i] &gt; a[j]</code>改为<code>a[i] &gt;= a[j]</code></p><p>2）若要求最长下降子序列，即：将数组逆序排序，再求最长上升子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span> ; j &gt;= <span class="hljs-number">0</span> ;j --)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123; <span class="hljs-comment">//不下降：a[i] &gt;= a[j]</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>            res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h2 id="onlogn">O(NlogN)</h2><p>解法：二分+贪心 (N &lt;= 1e6)</p><p>low[i]：所有长度为i的子序列的中最小的结尾值。</p><p>对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。</p><p>遍历a数组，并不断维护low数组，最后得到的cnt值，就是最长上升子序列的长度。</p><p>如果a[i]能接在当前最长的子序列的末尾上，即 a[i] &gt;low[cnt]，更新low[cnt++]为a[i]；</p><p>否则，往回找到一个第&gt;=a[i]的low[j]，替换为a[i]，维护low[j]为同长度序列的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//查找区间[l+1,r]</span><br>    <span class="hljs-comment">//找到第一个 &gt; x 的位置</span><br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(low[mid] &lt;= x)&#123; <span class="hljs-comment">//不下降：low[mid] &lt; x</span><br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>low[++cnt] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; low[cnt])&#123;  <span class="hljs-comment">//不下降：a[i] &gt;= low[cnt]</span><br>low[++cnt] = a[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//int j = lower_bound(low+1,low+cnt+1,a[i]) - low;</span><br>            <span class="hljs-comment">//不下降：int j = upper_bound(low+1,low+cnt+1,a[i]) - low;</span><br><span class="hljs-type">int</span> j = <span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>,cnt,a[i]);<br>low[j] = a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lcs最长公共子序列">LCS：最长公共子序列</h1><p><a href="https://www.luogu.com.cn/problem/P1439">P1439【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><p><ahref="https://www.lanqiao.cn/courses/21965/learning/?id=1149643&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 最长公共子序列 - 蓝桥云课 (lanqiao.cn)</a></p><h2 id="onm">O(N*M)</h2><p>左右末端若相等，当前值 == 删去当前末端的最大长度 + 1</p><p>左右末端若不相等，必然其中一个是无效的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++) cin&gt;&gt;b[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure><h2 id="求lcs序列">求LCS序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; lcs;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getLcs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> j = m;<br><span class="hljs-keyword">while</span>(i&amp;&amp;j)&#123;<br><span class="hljs-keyword">if</span>(a[i] == a[j])&#123;<br>lcs.<span class="hljs-built_in">push_back</span>(a[i]);<br>i--;j--;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 舍去dp值较小的末端</span><br><span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>]) i--;<br><span class="hljs-keyword">else</span> j--;<br>&#125;<br>&#125;<br><span class="hljs-built_in">reverse</span>(lcs.<span class="hljs-built_in">begin</span>(),lcs.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="onlogn-1">O(N*logN)</h2><p><a href="https://www.luogu.com.cn/problem/P1439">P1439【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><p>==前提！！！若A和B数组中的元素是相同的元素的不同排列==，即A中每个元素都能在B中找到相同的元素，</p><p>此时，LCS问题可以转化为LIS问题。</p><p>首先，对于初始数组，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A: <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>B: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A: a b c d e<br>B: c b a d e<br></code></pre></td></tr></table></figure><p>这样标号之后，LCS长度显然不会改变。</p><p>由 两个序列的子序列一定是A的子序列，且A是单调递增的，</p><p>可以得到：只要子序列在B中单调递增，它就是A的子序列。</p><p>所以求A和B的LCS，就是求B的LIS，因此完成转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(low[mid] &lt;= x)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>Hash[a[i]] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;b[i];<br>b[i] = Hash[b[i]];<br>&#125;<br>low[++cnt] = b[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(b[i] &gt; low[cnt])&#123;<br>low[++cnt] = b[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>, cnt, b[i]);<br>low[p] = b[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL汇总</title>
    <link href="/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="stl容器">STL容器</h1><p>参考：<a href="https://wyqz.top/p/870124582.html#toc-heading-66">C++STL总结 | 行码棋 (wyqz.top)</a></p><h2 id="vector动态数组">vector：动态数组</h2><ul><li>顺序结构，允许随机访问</li><li>插入、删除操作效率低，查询效率高</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>c.front()</code></td><td style="text-align: left;">返回第一个数据O(1)</td></tr><tr><td style="text-align: left;"><code>c.back()</code></td><td style="text-align: left;">返回数组中的最后一个数据 O(1)</td></tr><tr><td style="text-align: left;"><code>c.pop_back()</code></td><td style="text-align: left;">删除最后一个数据O(1）</td></tr><tr><td style="text-align: left;"><code>c.push_back(element)</code></td><td style="text-align: left;">在尾部加一个数据O(1)</td></tr><tr><td style="text-align: left;"><code>c.size()</code></td><td style="text-align: left;">返回实际数据个数（unsigned类型）O(1)</td></tr><tr><td style="text-align: left;"><code>c.clear()</code></td><td style="text-align: left;">清除元素个数O(N)，N为元素个数</td></tr><tr><td style="text-align: left;"><code>c.resize(n, v)</code></td><tdstyle="text-align: left;">改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td></tr><tr><td style="text-align: left;"><code>c.insert(it, x)</code></td><tdstyle="text-align: left;">向任意迭代器<code>it</code>插入一个元素<code>x</code>，O(N)</td></tr><tr><tdstyle="text-align: left;">例：<code>c.insert(c.begin() + 2,-1)</code></td><tdstyle="text-align: left;">将<code>-1</code>插入<code>c[2]</code>的位置</td></tr><tr><td style="text-align: left;"><code>c.erase(first,last)</code></td><tdstyle="text-align: left;">删除<code>[first,last)</code>的所有元素，O(N)</td></tr><tr><td style="text-align: left;"><code>c.begin()</code></td><tdstyle="text-align: left;">返回首元素的迭代器（通俗来说就是地址）O(1)</td></tr><tr><td style="text-align: left;"><code>c.end()</code></td><tdstyle="text-align: left;">返回最后一个元素后一个位置的迭代器（地址）O(1)</td></tr><tr><td style="text-align: left;"><code>c.empty()</code></td><td style="text-align: left;">判断是否为空，为空返回真，反之返回假O(1)</td></tr></tbody></table><h3 id="vector初始化">vector初始化</h3><p>vector的初始化常借助resize和assign</p><blockquote><p>resize的不指定value时的初始值如下：</p><p>int -- 0</p><p>string -- ""</p><p>bool -- false</p><p>double -- 0.0</p></blockquote><p>时间复杂度<span class="math inline">\(O(n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-comment">//resize不会改变原有数据，常用于初始化和拓展</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);       <span class="hljs-comment">// 大小调整为5, 元素值默认 -&gt; &#123;1,2,3,0,0&#125;</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">// 大小调整为7，每个元素初始化为10 -&gt; &#123;1,2,3,0,0,10,10&#125;</span><br><br><span class="hljs-comment">//assign会直接覆盖原有数据</span><br>v.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 用5个10填充v -&gt; &#123;10,10,10,10,10&#125;</span><br></code></pre></td></tr></table></figure><h3 id="vector复制操作">vector复制操作</h3><blockquote><p>C++中Vector的所有赋值方式都是<strong>深拷贝</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1：赋值运算符</span><br>v2 = v1;  <span class="hljs-comment">// 拷贝 vec1 到 vec2</span><br><span class="hljs-comment">//2：拷贝构造函数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;<br><span class="hljs-comment">//3：assign</span><br>v<span class="hljs-number">2.</span><span class="hljs-built_in">assign</span>(vec<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), vec<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="stack栈">stack：栈</h2><ul><li>不允许sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push(ele)</code></td><td style="text-align: left;">元素<code>ele</code>入栈，增加元素O(1)</td></tr><tr><td style="text-align: left;"><code>s.pop()</code></td><td style="text-align: left;">移除栈顶元素 O(1)</td></tr><tr><td style="text-align: left;"><code>s.top()</code></td><td style="text-align: left;">取得栈顶元素（但不删除）O(1)</td></tr><tr><td style="text-align: left;"><code>s.empty()</code></td><td style="text-align: left;">检测栈内是否为空，空为真 O(1)</td></tr><tr><td style="text-align: left;"><code>s.size()</code></td><td style="text-align: left;">返回栈内元素的个数 O(1)</td></tr></tbody></table><ul><li><strong>数组模拟栈</strong></li></ul><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或<code>hh</code> 来进行模拟</p></blockquote><p><strong>特点：</strong>比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sta[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 栈 从左至右为栈底到栈顶</span><br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// tt 代表栈顶指针,初始栈内无元素，tt为-1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-comment">//入栈 </span><br>    sta[++top] = i;<br>&#125;<br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> top_element = sta[top--]; <br></code></pre></td></tr></table></figure><h2 id="queue队列">queue：队列</h2><ul><li>不允许sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>q.front()</code></td><td style="text-align: left;">返回队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.back()</code></td><td style="text-align: left;">返回队尾元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.push(element)</code></td><td style="text-align: left;">尾部添加一个元素<code>element</code>进队O(1)</td></tr><tr><td style="text-align: left;"><code>q.pop()</code></td><td style="text-align: left;">删除第一个元素 出队 O(1)</td></tr><tr><td style="text-align: left;"><code>q.size()</code></td><tdstyle="text-align: left;">返回队列中元素个数，返回值类型<code>unsigned int</code>O(1)</td></tr><tr><td style="text-align: left;"><code>q.empty()</code></td><tdstyle="text-align: left;">判断是否为空，队列为空，返回<code>true</code>O(1)</td></tr></tbody></table><ul><li><strong>数组模拟队列</strong></li></ul><p>使用<code>q[]</code>数组模拟队列</p><p><code>rear</code>表示队尾元素的下标，初始值为<code>0</code></p><p><code>front</code>表示队首元素的下标，初始值为<code>0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>,rear = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//   入队 </span><br>    q[rear++] = <span class="hljs-number">1</span>;<br>    q[rear++] = <span class="hljs-number">2</span>; <br><span class="hljs-comment">//    出队 </span><br>    <span class="hljs-keyword">while</span>(front != rear) &#123;<br>        <span class="hljs-type">int</span> t = q[front++];<br>        cout&lt;&lt;t&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h2 id="deque双端队列">deque：双端队列</h2><ul><li>和vectot一样，可以随机访问，也可以sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><tdstyle="text-align: left;"><code>push_back(x)/push_front(x)</code></td><td style="text-align: left;">把<code>x</code>插入队尾后 / 队首O(1)</td></tr><tr><td style="text-align: left;"><code>back()/front()</code></td><td style="text-align: left;">返回队尾 / 队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>pop_back() / pop_front()</code></td><td style="text-align: left;">删除队尾 / 队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>erase(iterator it)</code></td><td style="text-align: left;">删除双端队列中的某一个元素</td></tr><tr><tdstyle="text-align: left;"><code>erase(iterator first,iterator last)</code></td><tdstyle="text-align: left;">删除双端队列中<code>[first,last)</code>中的元素</td></tr><tr><td style="text-align: left;"><code>empty()</code></td><td style="text-align: left;">判断deque是否空 O(1)</td></tr><tr><td style="text-align: left;"><code>size()</code></td><td style="text-align: left;">返回deque的元素数量 O(1)</td></tr><tr><td style="text-align: left;"><code>clear()</code></td><td style="text-align: left;">清空deque</td></tr></tbody></table><h2 id="priority_queue优先队列堆">priority_queue：优先队列（堆）</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>q.top()</code></td><td style="text-align: left;">访问队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.push()</code></td><td style="text-align: left;">入队 O(logN)</td></tr><tr><td style="text-align: left;"><code>q.pop()</code></td><td style="text-align: left;">堆顶（队首）元素出队 O(logN)</td></tr><tr><td style="text-align: left;"><code>q.size()</code></td><td style="text-align: left;">队列元素个数 O(1)</td></tr><tr><td style="text-align: left;"><code>q.empty()</code></td><td style="text-align: left;">是否为空 O(1)</td></tr><tr><tdstyle="text-align: left;"><strong>注意</strong>没有<code>clear()</code>！</td><td style="text-align: left;">不提供该方法</td></tr><tr><tdstyle="text-align: left;">优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td><td style="text-align: left;"></td></tr></tbody></table><ul><li>大小根堆的设置方法，也可以自定义比较函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">// 默认大根堆, 即每次取出的元素是队列中的最大值 </span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 小根堆, 每次取出的元素是队列中的最小值</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; q <span class="hljs-comment">//大根堆</span><br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp1</span> &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; y; &#125; &#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp2</span> &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; &#125;; priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp1&gt; q1; <span class="hljs-comment">//小根堆 </span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp2&gt; q2; <span class="hljs-comment">// 大根堆</span><br></code></pre></td></tr></table></figure><h2 id="set集合红黑树">set：集合（红黑树）</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.begin()</code></td><tdstyle="text-align: left;">返回set容器的第一个元素的地址（迭代器）O(1)</td></tr><tr><td style="text-align: left;"><code>s.end()</code></td><tdstyle="text-align: left;">返回set容器的最后一个元素的下一个地址（迭代器）O(1)</td></tr><tr><td style="text-align: left;"><code>s.rbegin()</code></td><tdstyle="text-align: left;">返回逆序迭代器，指向容器元素最后一个位置O(1)</td></tr><tr><td style="text-align: left;"><code>s.rend()</code></td><tdstyle="text-align: left;">返回逆序迭代器，指向容器第一个元素前面的位置O(1)</td></tr><tr><td style="text-align: left;"><code>s.clear()</code></td><td style="text-align: left;">删除set容器中的所有的元素,返回unsignedint类型O(N)</td></tr><tr><td style="text-align: left;"><code>s.empty()</code></td><td style="text-align: left;">判断set容器是否为空O(1)</td></tr><tr><td style="text-align: left;"><code>s.insert()</code></td><td style="text-align: left;">插入一个元素 O（log n）</td></tr><tr><td style="text-align: left;"><code>s.size()</code></td><td style="text-align: left;">返回当前set容器中的元素个数O(1)</td></tr><tr><td style="text-align: left;"><code>erase(iterator)</code></td><td style="text-align: left;">删除定位器iterator指向的值</td></tr><tr><td style="text-align: left;"><code>erase(first,second）</code></td><td style="text-align: left;">删除定位器first和second之间的值</td></tr><tr><td style="text-align: left;"><code>erase(key_value)</code></td><td style="text-align: left;">删除键值key_value的值</td></tr><tr><td style="text-align: left;">查找</td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;"><code>s.find(element)</code></td><tdstyle="text-align: left;">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回s.end()O(logN)</td></tr><tr><td style="text-align: left;"><code>s.count(element)</code></td><tdstyle="text-align: left;">返回set中的元素出现的个数，由于set中无重复元素，只能返回0和 1。此函数相当于查询element是否出现 &gt; O(logN)</td></tr><tr><td style="text-align: left;"><code>s.lower_bound(k)</code></td><tdstyle="text-align: left;">返回大于等于k的第一个元素的迭代器O(logN)</td></tr><tr><td style="text-align: left;"><code>s.upper_bound(k)</code></td><td style="text-align: left;">返回大于k的第一个元素的迭代器O(logN)</td></tr></tbody></table><h2 id="map映射红黑树">map：映射（红黑树）</h2><ul><li><p>优点：</p><ul><li><p>map元素有序（这是map最大的优点，其元素的有序性在很多应用中都会简化很多的操作）；</p></li><li><p>其红黑树的结构使得map的很多操作都可在O(logn)下完成；</p></li><li><p>map的各项性能较为稳定，与元素插入顺序无关；</p></li><li><p>map支持范围查找。</p></li></ul></li><li><p>缺点：</p><ul><li><p>占用的空间大：红黑树的每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大。</p></li><li><p>查询平均时间不如unordered_map。</p></li></ul></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>mp.find(key)</code></td><tdstyle="text-align: left;">返回键为key的映射的迭代器存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()O(logN)</td></tr><tr><td style="text-align: left;"><code>mp.erase(it)</code></td><td style="text-align: left;">删除迭代器对应的键和值O(1)</td></tr><tr><td style="text-align: left;"><code>mp.erase(key)</code></td><td style="text-align: left;">根据映射的键删除键和值 O(logN)</td></tr><tr><td style="text-align: left;"><code>mp.erase(first,last)</code></td><td style="text-align: left;">删除左闭右开区间迭代器对应的键和值O(last−first)</td></tr><tr><td style="text-align: left;"><code>mp.size()</code></td><td style="text-align: left;">返回映射的对数O(1)</td></tr><tr><td style="text-align: left;"><code>mp.clear()</code></td><td style="text-align: left;">清空map中的所有元素O(N)</td></tr><tr><td style="text-align: left;"><code>mp.insert()</code></td><td style="text-align: left;">插入元素，插入时要构造键值对</td></tr><tr><td style="text-align: left;"><code>mp.empty()</code></td><td style="text-align: left;">如果map为空，返回true，否则返回false</td></tr><tr><td style="text-align: left;"><code>mp.begin()</code></td><td style="text-align: left;">返回指向map第一个元素的迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.end()</code></td><tdstyle="text-align: left;">返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td style="text-align: left;"><code>mp.rbegin()</code></td><tdstyle="text-align: left;">返回指向map最后一个元素的迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.rend()</code></td><tdstyle="text-align: left;">返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.count(key)</code></td><tdstyle="text-align: left;">查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td></tr><tr><td style="text-align: left;"><code>mp.lower_bound()</code></td><td style="text-align: left;">返回一个迭代器，指向键值&gt;=key的第一个元素</td></tr><tr><td style="text-align: left;"><code>mp.upper_bound()</code></td><td style="text-align: left;">返回一个迭代器，指向键值&gt;key的第一个元素</td></tr></tbody></table><h2 id="unordered_map哈希表">unordered_map：哈希表</h2><p>unorder_map是链式存储法的哈希表，每个key值对应的链表，叫做一个“桶”</p><ul><li>优点：<ul><li>查询速度快，平均性能接近于常数时间<strong>O(1)</strong>；</li></ul></li><li>缺点：<ul><li>元素无序；</li><li>unordered_map相对于map空间占用更大，且其利用率不高；</li><li>查询性能不太稳定，最坏时间复杂度可达到<strong>O(n)</strong>。</li></ul></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>mp.begin()</code></td><td>返回指向map第一个元素的迭代器（地址）</td></tr><tr><td><code>mp.end()</code></td><td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td><code>mp.empty()</code></td><td>空则返回true，非空返回false</td></tr><tr><td><code>mp.size()</code></td><td>返回哈希表的大小</td></tr><tr><td><code>mp.at(key)</code></td><td>根据key值，查找value，若不存在，抛出异常</td></tr><tr><td><code>mp.find(key)</code></td><td>存在该key值则返回该位置上的迭代器，否则返回mp.end()</td></tr><tr><td><code>mp.clear()</code></td><td>清空表</td></tr><tr><td><code>mp.find(key)</code></td><td>存在该key值则返回该位置上的迭代器，否则返回mp.end()</td></tr><tr><td><code>mp.count(key)</code></td><td>该key值对应value存在，返回1，否则为0</td></tr><tr><td><code>mp.emplace(key)</code></td><td>向容器中添加新键值对（旧值不会被新值覆盖），效率对比insert()高</td></tr><tr><td><code>mp.insert(pair)</code></td><td>向容器中添加新键值对（旧值被新值覆盖）</td></tr></tbody></table><ul><li>mp[key] = value 和insert（pair）都会覆盖旧value，而emplace不会。</li></ul><h2 id="string字符串">string：字符串</h2><ul><li>运算符特性：</li></ul><p>1.支持比较运算符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>。支持<code>string</code>与<code>C-string</code>的比较（如<code>str &lt; "hello"</code>）。</p><p>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按<code>字典顺序</code> 进行逐一得 比较。</p><p>字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>2.支持<code>+</code><strong>运算</strong>符，代表拼接字符串：string字符串可以拼接，通过”+”运算符进行拼接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br>string s = s1 + s2;<br>cout &lt;&lt; s;   <span class="hljs-comment">//123456</span><br></code></pre></td></tr></table></figure><ul><li><strong>获取字符串长度</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><tdstyle="text-align: left;"><code>s.size()</code>和<code>s.length()</code></td><tdstyle="text-align: left;">返回string对象的字符个数，他们执行效果相同</td></tr><tr><td style="text-align: left;"><code>s.max_size()</code></td><tdstyle="text-align: left;">返回string对象最多包含的字符数，超出会抛出length_error异常</td></tr><tr><td style="text-align: left;"><code>s.capacity()</code></td><tdstyle="text-align: left;">重新分配内存之前，string对象能包含的最大字符数</td></tr></tbody></table><ul><li><strong>插入</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push_back()</code></td><td style="text-align: left;">在末尾插入</td></tr><tr><td style="text-align: left;">例：<code>s.push_back('a')</code></td><td style="text-align: left;">末尾插入一个字符a</td></tr><tr><td style="text-align: left;"><code>s.insert(pos,element)</code></td><td style="text-align: left;">在pos位置插入element</td></tr><tr><tdstyle="text-align: left;">例：<code>s.insert(s.begin(),'1')</code></td><td style="text-align: left;">在第一个位置插入1字符</td></tr><tr><td style="text-align: left;"><code>s.append(str)</code></td><td style="text-align: left;">在s字符串结尾添加str字符串</td></tr><tr><td style="text-align: left;">例：<code>s.append("abc")</code></td><td style="text-align: left;">在s字符串末尾添加字符串“abc”</td></tr></tbody></table><ul><li><strong>删除</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>erase(iterator p)</code></td><td style="text-align: left;">删除字符串中p所指的字符</td></tr><tr><tdstyle="text-align: left;"><code>erase(iterator first, iterator last)</code></td><tdstyle="text-align: left;">删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td></tr><tr><td style="text-align: left;"><code>erase(pos, len)</code></td><tdstyle="text-align: left;">删除字符串中从索引位置pos开始的len个字符</td></tr><tr><td style="text-align: left;"><code>clear()</code></td><td style="text-align: left;">删除字符串中所有字符</td></tr></tbody></table><ul><li><strong>字符替换</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.replace(pos,n,str)</code></td><tdstyle="text-align: left;">把当前字符串从索引pos开始的n个字符替换为str</td></tr><tr><td style="text-align: left;"><code>s.replace(pos,n,n1,c)</code></td><tdstyle="text-align: left;">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td></tr><tr><td style="text-align: left;"><code>s.replace(it1,it2,str)</code></td><tdstyle="text-align: left;">把当前字符串<code>[it1,it2)</code>区间替换为str<strong>it1 ,it2为迭代器哦</strong></td></tr></tbody></table><ul><li><strong>大小写转换</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>tolower(s[i])</code></td><td style="text-align: left;">转换为小写</td></tr><tr><td style="text-align: left;"><code>toupper(s[i])</code></td><td style="text-align: left;">转换为大写</td></tr></tbody></table><ul><li><strong>分割</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.substr(pos,n)</code></td><td style="text-align: left;">截取从pos索引开始的n个字符</td></tr></tbody></table><ul><li><strong>查找</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.find (str, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td style="text-align: left;"><code>s.find (c, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.rfind (str, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td style="text-align: left;"><code>s.rfind (c, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><tdstyle="text-align: left;"><code>s.find_first_of (str, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><tdstyle="text-align: left;"><code>s.find_first_not_of (str,pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.find_last_of(str, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><tdstyle="text-align: left;"><code>s.find_last_not_of ( str, pos)</code></td><tdstyle="text-align: left;">在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td></tr></tbody></table><h2 id="sort排序">sort：排序</h2><p><strong>O(NlogN)</strong></p><ul><li>对数组正常升序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a , a + n);<br>vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">// vector数组定义</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><ul><li>使用第三个参数，进行降序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><ul><li>自定义排序规则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>&#125;<br><span class="hljs-built_in">sort</span>(node, node + n, cmp); <br><span class="hljs-comment">// 只接受以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span><br></code></pre></td></tr></table></figure><ul><li>stable_sort使用方法和sort一样，但排序时不会改变相等元素的相对位置，是稳定排序</li></ul><h1 id="stl函数">STL函数：</h1><h2 id="有序序列的二分查找">有序序列的二分查找</h2><p><ahref="https://blog.csdn.net/weixin_28712713/article/details/80922917">45正确区分count、find、binary_search、lower_bound、upper_bound和equal_range_findlowbound-CSDN博客</a></p><img src="/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/70.png" class="" title="img"><p><strong>1.binary_search</strong></p><p>找得到返回1，找不到返回0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">12</span>) &lt;&lt; endl;<span class="hljs-comment">//1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">77</span>) &lt;&lt; endl;<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>如果sort中使用了自定义排序规则，binary_search里一样要引用该参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-built_in">Rule</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">8</span>, <span class="hljs-built_in">Rule</span>()) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>2.lower_bound、upper_bound</strong></p><p>使用方法和bianry_search一样，lower_bound返回的是一个 &gt;=查找元素的迭代器/指针，upper_bound为 &gt; 。</p><h2 id="getline">getline</h2><p><strong>读入字符串，遇空格，回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; cin &gt;&gt; s;<br></code></pre></td></tr></table></figure><p><strong>读入一行字符串（包括空格），遇回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <span class="hljs-built_in">getline</span>(cin, s);<br></code></pre></td></tr></table></figure><p>注意:<code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code>或<code>cin.get()</code></p><p>错误读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getline</span>(cin, s); <span class="hljs-comment">//此时读取相当于读取了前一个回车字符</span><br></code></pre></td></tr></table></figure><p>正确读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//cin.get()</span><br><span class="hljs-built_in">getline</span>(cin, s);<span class="hljs-comment">//可正确读入下一行的输入</span><br></code></pre></td></tr></table></figure><h2id="set_unionintersectiondifference并集交集差集">set_union/intersection/difference：并集/交集/差集</h2><p>set_union, set_intersection,set_difference：</p><p><strong>复杂度：O(N+M)</strong></p><p>注意：两个集合必须为<strong>有序集合</strong>，所以下面演示代码使用了排序。</p><p>vector容器可以替换成set容器，因为set自动会对元素进行排序。</p><p>函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>&#125;, b = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 1 2 4 5 8</span><br><span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 2 3 5 8 9</span><br>vector&lt;<span class="hljs-type">int</span>&gt; c, d, e;<br><span class="hljs-comment">// a并b：1 2 3 4 5 8 9</span><br><span class="hljs-built_in">set_union</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(c, c.<span class="hljs-built_in">begin</span>()));<br><span class="hljs-comment">// a交b：2 5 8</span><br><span class="hljs-built_in">set_intersection</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(d, d.<span class="hljs-built_in">begin</span>()));<br><span class="hljs-comment">// a差b： 1 4</span><br><span class="hljs-built_in">set_difference</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(e, e.<span class="hljs-built_in">begin</span>()));<br></code></pre></td></tr></table></figure><h2 id="reverse翻转序列">reverse：翻转序列</h2><p><strong>复杂度： O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(beg,end)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//1,2,3,4,5</span><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 5,4,3,2,1</span><br></code></pre></td></tr></table></figure><h2 id="unique删除重复元素">unique：删除重复元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">unique</span>(beg, end)<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><p>用于去除相邻的重复元素</p><p>unique函数返回一个指向去重后的末尾指针，但是数组size没有改变，需要删除操作</p><p>同样兼容c数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 1，2，3，2，2，2，3，3，3</span><br>v.<span class="hljs-built_in">erase</span>(it,v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 1，2，3</span><br></code></pre></td></tr></table></figure><h2 id="next_permutation全排列函数">next_permutation：全排列函数</h2><p><strong>复杂度：</strong> O(N)</p><p>next_permutation：如果数组存在下一个全排列，返回 bool =1，并移动到下一位，否则返回0</p><p>perv_permutaion是前者的逆操作</p><p>这两个函数同样兼容c数组，操作与vector相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()))&#123;<br><span class="hljs-type">int</span> len = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="auto">auto</h2><p>auto可以根据等号后面的值来自动适配变量类型，也可以简化遍历书写</p><p>常见用法：</p><p>for(auto x : range) // 拷贝元素 for(auto &amp;&amp;x : range)//修改元素 for(const auto &amp;x : range) // 只读元素（无法修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : v)&#123;<br>i = <span class="hljs-number">2</span>*i;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br><span class="hljs-comment">//2 4 6 8 10 12 14</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span> &gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>() ; it ++)&#123;<br>cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//auto：</span><br><span class="hljs-comment">//1 2 3 4 5 6 7</span><br><span class="hljs-comment">//auto &amp;&amp;：</span><br><span class="hljs-comment">//2 4 6 8 10 12 14</span><br><span class="hljs-comment">//const auto &amp;,报错</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2025/01/12/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2025/01/12/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><h2 id="概念">概念</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="实现">实现</h2><p>属性： pre[]：记录每个结点的先驱结点size[]：记录当前结点所属集合的大小 count：记录连通分量的个数 方法：查找代表元（find）：查找当前结点所属集合的代表元，树形结构，我们可以通过pre逐层向上查找，一直找到根节点即为当前集合的代表元。（这里的代表元就是一个集合中的代表元素，如果两个元素的代表元相同，则这两个元素属于同一集合）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p>合并（connect）：合并两个结点，我们通过pre[y]=x，将y结点连接到x上，这里我们为了减少find函数的迭代次数，我们总是把小的集合连接到大的集合上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询（isconnect）：判断两个结点是否属于同一集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><p>断开连接（disconnect）：将当前结点断开与其上层节点的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        pre[x] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre;<br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count = n;<br>        pre.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            pre[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        pre[x] = x;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="模板">模板</h1><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集- 洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre[MAX],n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy) pre[fx] = fy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;t;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-type">int</span> z,x,y;<br>cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">if</span>(z == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Union</span>(x,y);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)?<span class="hljs-string">&quot;Y&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>)&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树算法合集</title>
    <link href="/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <url>/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树基本性质">二叉树基本性质</h1><p>性质1：在二叉树的第 <span class="math inline">\(i\)</span> 层上至多有<span class="math inline">\(2^{i-1}\)</span> 个结点（i&gt;=1）</p><p>性质2：深度为 <span class="math inline">\(k\)</span> 的二叉树至多有<span class="math inline">\(2^k-1\)</span> 个结点（k&gt;=1）</p><p>性质3：对于任何一颗二叉树T，如果其终端结点数为<spanclass="math inline">\(n_0\)</span>，度为2的结点数为<spanclass="math inline">\(n_2\)</span>，则<spanclass="math inline">\(n_0=n_2+1\)</span></p><blockquote><p>原理：点数 = 边数 + 1</p><p>由 <span class="math inline">\(n = n0 + n1 + n2 = 2*n2 + n1 +1\)</span> 得 <span class="math inline">\(n_0=n_2+1\)</span></p></blockquote><p>性质4：具有n个节点的<strong>完全二叉树</strong>深为<spanclass="math inline">\(log_2{k}+1\)</span></p><p>性质5：如果对一颗有n个结点的<strong>完全二叉树</strong>（其深度为<spanclass="math inline">\([log_2n]+1\)</span>）的结点按层序编号（从第1层到<spanclass="math inline">\([log_2n]+1\)</span>层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）:</p><p>（1）如果<spanclass="math inline">\(i=1\)</span>，则结点i是二叉树的根，无双亲，如果<spanclass="math inline">\(i&gt;1\)</span>,则其双亲结点是结点<spanclass="math inline">\([i/2]\)</span> （2）如果<spanclass="math inline">\(2i&gt;n\)</span>，则结点i无左孩子（结点i为叶子结点）否则左孩子是结点<spanclass="math inline">\(2i\)</span>。 （3）如果<spanclass="math inline">\(2i+1&gt;n\)</span>,则结点i无右孩子，否则其右孩子是结点<spanclass="math inline">\(2i+1\)</span>.</p><blockquote><p>若根节点从0开始，左 = <span class="math inline">\(2i + 1\)</span>，右= <span class="math inline">\(2i+2\)</span></p></blockquote><h1 id="节点数据结构">节点数据结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> val;<br>node * l;<br>node * r;<br><br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> val_)&#123;<br>val = val_;<br>        l = <span class="hljs-literal">nullptr</span>;<br>        r = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的遍历">二叉树的遍历</h1><p>先序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>        in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">layerTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br>queue&lt;node *&gt; q;<br>q.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node * f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>layer.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br><br><span class="hljs-keyword">if</span>(f-&gt;l != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;l);<br><span class="hljs-keyword">if</span>(f-&gt;r != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的建树">二叉树的建树</h1><h2 id="t1--已知后序和中序遍历">T1--已知后序和中序遍历</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805349394006016&amp;page=1">1127ZigZagging on a Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>后序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(postl &gt; postr) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != post[postr]) i++;<br><br>node* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(postl, postl + (i - inl) - <span class="hljs-number">1</span>, inl, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//注意：这里不能改成（r-inl），因为左右子树未必节点数相同</span><br>p-&gt;r = <span class="hljs-built_in">create</span>(postl + (i - inl), postr - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, inr);<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="t2--已知先序和中序遍历">T2--已知先序和中序遍历</h2><blockquote><p>前序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-type">int</span> i = inl;<br>    <span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br>    <br>    node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>    p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br>    p-&gt;r = <span class="hljs-built_in">create</span>(prel + (i-inl) + <span class="hljs-number">1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="t3--已知层序和中序遍历">T3--已知层序和中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> layerl, <span class="hljs-type">int</span> layerr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(layerl &gt; layerr)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != layer[layerl]) i++;<br><br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(layerl<span class="hljs-number">+1</span>, layerl + (i-inl) ,inl, i<span class="hljs-number">-1</span>);<br>p-&gt;r = <span class="hljs-built_in">create</span>(layerl+(i-inl)<span class="hljs-number">+1</span>, layerr, i<span class="hljs-number">+1</span>, inr);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2id="t4--已知先序和后序遍历不唯一">T4--已知先序和后序遍历（不唯一）</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805353470869504&amp;page=1">1119Pre- and Post-order Traversals - PAT (Advanced Level) Practice(pintia.cn)</a></p><blockquote><p>已知先序和后序遍历可能无法唯一地确定二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-keyword">return</span> p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<span class="hljs-comment">//找到后序遍历倒数第二个点，即右子树的第一个点</span><br><span class="hljs-keyword">if</span>(i - prel - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)&#123; <br>p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//若左子树为空，那么右子树第一个点可能在左子树，也可能在右子树。此处我们将该点放在右子树</span><br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>p-&gt;r = <span class="hljs-built_in">create</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h1 id="序列互转">序列互转</h1><h2 id="任意两种序列-转-其他">任意两种序列 转 其他</h2><p>若题目只要求某个遍历序列，可以在建树的过程中，直接生成序列。</p><p>先 + 中 转 后</p><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805345078067200&amp;page=1">1138Postorder Traversal - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br><span class="hljs-built_in">getPost</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">getPost</span>(prel+(i-inl)<span class="hljs-number">+1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>post.<span class="hljs-built_in">push_back</span>(pre[prel]);<br>&#125;<br></code></pre></td></tr></table></figure><p>先+后 转 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getIn</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(pre[prel] == post[postr])&#123;<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<br><span class="hljs-keyword">if</span>(i - prel &gt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">getIn</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-built_in">getIn</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="先中后序-转-层序完全二叉树">先/中/后序 转层序（完全二叉树）</h2><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>满二叉树(Full binary tree)：各层 (1~h-1)的结点数都达到最大个数的二叉树。所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层。</p></blockquote><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805407749357568&amp;page=0">1064Complete Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a>、</p><p>对于一颗完全二叉树/满二叉树而言，按层序从上到下，从左到右地标注（root= 0），可以得到任意一个节点r，其左孩子为r*2+1，右孩子为 r*2 +2。可以根据这个性质，将先/中/后序序列转为层序。</p><p>这里以中序转层序（节点数为n）为例，函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inToLayer</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>layer[r] = in[idx++];<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层序-转-先中后序完全二叉树">层序 转先/中/后序（完全二叉树）</h2><p>以 层序 转 后序为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>post.<span class="hljs-built_in">push_back</span>(layer[r]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的深度">求二叉树的深度</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(p-&gt;l),<span class="hljs-built_in">getDepth</span>(p-&gt;r));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的镜像">求二叉树的镜像</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(p-&gt;l != <span class="hljs-literal">nullptr</span> || p-&gt;r != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">swap</span>(p-&gt;l, p-&gt;r);<br><span class="hljs-built_in">mirror</span>(p-&gt;l);<br><span class="hljs-built_in">mirror</span>(p-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树">平衡二叉树</h1><blockquote><p>定义：一棵空树 或 左右子树的高度差不超过1且左右子树也是平衡树</p></blockquote><p>输入一颗二叉树，判断是否为平衡二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBanlance</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> &amp; depth)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">int</span> ld,rd;<br>    <span class="hljs-comment">//先判断左右子树是否平衡，再判断当前子树，避免重复计算深度</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBanlance</span>(p-&gt;l,ld) &amp;&amp; <span class="hljs-built_in">isBanlance</span>(p-&gt;r,rd))&#123;<br><span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(ld - rd);<br><span class="hljs-keyword">if</span>(diff &lt;= <span class="hljs-number">1</span>)&#123;<br>depth = <span class="hljs-built_in">max</span>(ld,rd) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><blockquote><p>定义：一颗二叉树，所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</p><p>直观理解：从根节点画一条纵轴，左右子树完全沿轴对称</p></blockquote><p>核心思想：左右子树对称 &lt;=&gt; 左右根节点相等 &amp;&amp;左子树的左子树和右子树的右子树对称 &amp;&amp;左子树的右子树和右子树的左子树对称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSym</span><span class="hljs-params">(node * le, node * ri)</span></span>&#123;<br><span class="hljs-keyword">if</span>(le == <span class="hljs-literal">nullptr</span> &amp;&amp; ri == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(le != <span class="hljs-literal">nullptr</span> &amp;&amp; ri != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">return</span> (le-&gt;x == ri-&gt;x) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;l,ri-&gt;r) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;r,ri-&gt;l);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeSym</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSym</span>(p-&gt;l, p-&gt;r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全二叉树">完全二叉树</h1><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805359372255232&amp;page=1">1110Complete Binary Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h层所有的结点都连续集中在最左边，这就是完全二叉树。</p></blockquote><p>一颗树是完全二叉树的充要条件是：层序遍历的最大下标等于 n-1 (root ==0)</p><blockquote><p>root == 1时，层序遍历的最大下标等于 n</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-type">int</span> d = q.<span class="hljs-built_in">front</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br>maxIdx = <span class="hljs-built_in">max</span>(maxIdx,d);<br><span class="hljs-keyword">if</span>(nodes[f].l != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].l,<span class="hljs-number">2</span>*d + <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">if</span>(nodes[f].r != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].r,<span class="hljs-number">2</span>*d + <span class="hljs-number">2</span>&#125;);<br>&#125;<br><span class="hljs-keyword">return</span> maxIdx == n<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树bst">二叉搜索树BST</h1><blockquote><p>二叉搜索树(Binary SearchTree)：它是一棵空树，或者是具有下列性质的二叉树：</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>左、右子树也分别为二叉排序树。</p></blockquote><p>一个重要性质：二叉搜索树的中序遍历序列是有序上升的。（很多题目中可利用该性质将BST当成普通二叉树来做）</p><h2 id="bst建树">BST建树</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805355987451904&amp;page=1">1115Counting Nodes in a Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node * <span class="hljs-title">insert</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt;= p-&gt;val)&#123; <span class="hljs-comment">//根据不同题目，这里可能是x &gt; p-&gt;val</span><br>p-&gt;r = <span class="hljs-built_in">insert</span>(p-&gt;r, x);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p-&gt;l = <span class="hljs-built_in">insert</span>(p-&gt;l, x);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node * root = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;v[i]; <span class="hljs-comment">//按固定顺序插入的二叉搜索树是唯一的。</span><br>    root = <span class="hljs-built_in">insert</span>(root, v[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bst上lca">BST上LCA</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805343727501312&amp;page=1">1143Lowest Common Ancestor - PAT (Advanced Level) Practice(pintia.cn)</a></p><p>BST上任意两点的最近公共祖先满足条件：<spanclass="math inline">\(min(u,v) &lt;= a &lt;= max(u,v)\)</span></p><p>满足这个条件的点是唯一的，是充要条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//沿先序遍历路径找LCA</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-comment">//pre[i] &gt;= min(u,v) &amp;&amp; pre[i] &lt;= max(u,v)</span><br>    <span class="hljs-keyword">if</span>((pre[i] &gt;= u &amp;&amp; pre[i] &lt;= v) || (pre[i] &gt;= v &amp;&amp; pre[i] &lt;= u))&#123;<br>        a = pre[i];<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断某个先序序列是否来自bst">判断某个先序序列是否来自BST</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805440976633856&amp;page=0">1043Is It a Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><p>法1：按该先序序列逐个插入节点，建立BST，与正确的先序序列比较。</p><p>法2：直接在先序序列上判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于二叉搜索树的先序遍历的序列而言</span><br><span class="hljs-comment">//头节点一定为根节点，而左右子树的根，在该序列中的距离一定为1</span><br><span class="hljs-comment">//由此规律可构造的平衡树的节点个数一定是n个</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> j = r;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &lt; pre[l]) i++;<span class="hljs-comment">//第一个 &gt;= root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &gt;= pre[l]) j--;<span class="hljs-comment">//最后一个 &lt; root的节点</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &gt;= pre[l]) i++;<span class="hljs-comment">//第一个 &lt; root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &lt; pre[l]) j--;<span class="hljs-comment">//最后一个 &gt;= root的节点</span><br>&#125;<br><span class="hljs-keyword">if</span>(i - j != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">getPost</span>(l<span class="hljs-number">+1</span>, j);<br><span class="hljs-built_in">getPost</span>(i, r);<br>post.<span class="hljs-built_in">push_back</span>(pre[l]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h1><blockquote><p>AVL树的名字来源于它的发明作者G.M.<strong>A</strong>delson-<strong>V</strong>elsky 和 E.M.<strong>L</strong>andis。</p><p>AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）</p><p>将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(BalanceFactor)。</p></blockquote><p>每次查找AVL树中的元素，耗时O（logN）</p><p>AVL树满足以下两个条件：</p><blockquote><p>条件一：它必须是二叉查找树。</p><p>条件二：每个节点的左子树和右子树的高度差至多为1。</p></blockquote><h2 id="avl建树">AVL建树</h2><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805351302414336&amp;page=1">1123Is It a Complete AVL Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><h1 id="中缀表达式">中缀表达式</h1><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805347921805312&amp;page=1">1130Infix Expression - PAT (Advanced Level) Practice (pintia.cn)</a></p><style>.dhxmxetiyipx{}</style><img src="/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/4d1c4a98-33cc-45ff-820f-c548845681ba.jpeg" class="dhxmxetiyipx" alt="infix1.JPG"><blockquote><p>二叉运算树的中序遍历，恰是一个中缀表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">inTra</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>string le = <span class="hljs-built_in">inTra</span>(tree[p].l);<br>string ri = <span class="hljs-built_in">inTra</span>(tree[p].r);<br><span class="hljs-keyword">if</span>((le != <span class="hljs-string">&quot;&quot;</span> || ri != <span class="hljs-string">&quot;&quot;</span>) &amp;&amp; p != root)&#123; <span class="hljs-comment">//若非根节点p，存在孩子，需要加上括号</span><br>le = <span class="hljs-string">&quot;(&quot;</span> + le;<br>ri = ri + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> le + tree[p].s + ri;<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">inTra</span>(root);<br></code></pre></td></tr></table></figure><h1 id="最近公共祖先lca">最近公共祖先LCA</h1><p>参考BLOG：</p><p><ahref="https://www.jvruo.com/archives/629/#comments">【蒟蒻图论】三种算法解决LCA- 蒟蒻のBLOG (jvruo.com)</a></p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3379">P3379【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><blockquote><p>在“Lowest Common Ancestor”中，“lowest”的含义与常规理解有些不同，</p><p>指的是最深的公共祖先，而不是最接近树根的节点。</p></blockquote><blockquote><p>LCA适用于多叉树（有向无环图），而不仅仅是二叉树。</p></blockquote><style>.hfkjvkfqdmqn{zoom:70%;}</style><img src="/2025/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/3030388996.png" class="hfkjvkfqdmqn" alt="LCA2.png"><h2 id="倍增">倍增</h2><p><ahref="https://shawnliang.wiki/post/lca-binary-lifting/">LCA算法之倍增法- Shawn's algorithm notes (shawnliang.wiki)</a></p><p>倍增是用的最多的LCA<strong>在线</strong>算法，其复杂度为 <spanclass="math inline">\(O(nlogn+mlogn)\)</span> [n为点数，m为询问数]</p><p><ahref="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1038430130011897856&amp;page=1">1151LCA in a Binary Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>前序+中序建树 + 二叉树上LCA</p><p>坑点：题目没说给出的序列值是在下标1~N范围内，MAX = N会段错误</p></blockquote><p><code>depth</code>和<code>fa</code>预处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br>depth[x] = depth[f] + <span class="hljs-number">1</span>;<br>fa[x][<span class="hljs-number">0</span>] = f;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; (<span class="hljs-number">1</span>&lt;&lt;i) &lt;= depth[x] ; i ++)&#123;<br>fa[x][i] = fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != f)&#123;<br><span class="hljs-built_in">dfs</span>(it, x);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><code>log2(x)</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) lg[i]--;<br></code></pre></td></tr></table></figure><p><code>lca(a, b)</code>：a和b两点最短公共祖先</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-comment">//将两个节点跳到同一深度</span><br><span class="hljs-keyword">if</span>(depth[a] &lt; depth[b]) <span class="hljs-built_in">swap</span>(a,b);<br><span class="hljs-keyword">while</span>(depth[a] != depth[b])&#123;<br>a = fa[a][lg[depth[a] - depth[b]]];<br>&#125;<br><span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-comment">//逐步倍增到LCA前一位置：即a和b的父亲相等</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = lg[depth[a]] ; k &gt;= <span class="hljs-number">0</span> ; k --)&#123;<br><span class="hljs-keyword">if</span>(fa[a][k] != fa[b][k])&#123;<br>a = fa[a][k];<br>b = fa[b][k];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉序-st表">欧拉序 + ST表</h2><h2 id="tarjan">Tarjan</h2><p><ahref="https://www.cnblogs.com/JVxie/p/4854719.html">最近公共祖先LCA(Tarjan算法)的思考和算法实现- JVxie - 博客园 (cnblogs.com)</a></p><p>Tarjan是求解LCA唯一的<strong>离线</strong>算法，其时间复杂度达到了<spanclass="math inline">\(O(n+m)\)</span>。</p><p>Tarjan的基本逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span>从根节点开始进行<span class="hljs-built_in">DFS</span> (设当前遍历到节点u，其子节点为v);<br><span class="hljs-number">2.</span>若u还存在没访问过的子节点，继续遍历，否则进行操作<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>；<br><span class="hljs-number">3.</span>将u标记为”访问过“<br><span class="hljs-number">4.</span>在并查集中，将v合并到u上,并标记节点v已被访问过；<br><span class="hljs-number">5.</span>寻找与当前点u有询问关系的点x，若点x已经被访问过，那么lca（u,x）= <span class="hljs-built_in">find</span>(u)；<br></code></pre></td></tr></table></figure><p>Tarjan函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it] &amp;&amp; it != f)&#123;<br><span class="hljs-built_in">tarjan</span>(it, x);<br><span class="hljs-built_in">join</span>(x, it);<br>&#125;<br>&#125;<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; it : q[x])&#123;<br><span class="hljs-type">int</span> t = it.first;<br><span class="hljs-type">int</span> i = it.second;<br><span class="hljs-keyword">if</span>(visited[t])&#123;<br>ans[i] = <span class="hljs-built_in">find</span>(t);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>询问关系的存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q[MAX];<br><span class="hljs-comment">//first - 端点 ；second - 下标 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;<br>    q[u].<span class="hljs-built_in">push_back</span>(&#123;v,i&#125;);<br>    q[v].<span class="hljs-built_in">push_back</span>(&#123;u,i&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最优二叉查找树">最优二叉查找树</h1><p><ahref="https://pintia.cn/problem-sets/1844196541682872320/exam/problems/type/7?problemSetProblemId=1844196541703843844&amp;page=0">7-5最优二叉查找树 - 练习3-2 (pintia.cn)</a></p><p>假设 一颗 查找树 上的每个点（深度为 c）都有一个查找概率p，那么我们可以得到查找次数的期望： <spanclass="math display">\[E(c) = \sum_{i}^{n} c_i*p_i\]</span> 最优二叉查找树 指的是 使得查找次数期望最小 的 二叉查找树。</p><p>设C（i，j）为以i为左端点，j为右端点的二叉树的查找期望代价。</p><p>我们可以得到如下的状态转移方程： <span class="math display">\[\begin{cases}C[i][j] = 0 &amp; i &gt; j \\C[i][j] = P_i &amp; i = j \\C[i][j] = min( C[i][k-1] + C[k+1][j] + \sum_{i}^{j} P ) ) &amp; else \\\end{cases}\]</span>在得到c[i][j]数组的同时，我们需要可以记录一下，取最小值时候的根k，得到R[i][j]数组，以构造查找树。</p><p>动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//处理坐标为x，y的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">// int root = 0;</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x ; i &lt;= y ; i ++)&#123;<br>sum += c[i][i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = x ; k &lt;= y ; k ++)&#123;<br><span class="hljs-keyword">if</span>(sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y] &lt; res)&#123;<br>res = sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y];<br><span class="hljs-comment">// root = k;</span><br>&#125;<br>&#125;<br>c[x][y] = res;<br><span class="hljs-comment">// r[x][y] = root;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按主对角线方向进行dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-type">double</span> p;cin&gt;&gt;p;<br>    c[i][i] = p*<span class="hljs-number">10000</span>; <span class="hljs-comment">// 这题要求输出结果x10000后的数值</span><br>    r[i][i] = i;<br>&#125;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>,y = <span class="hljs-number">2</span>,cnt = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>( !( x == <span class="hljs-number">1</span> &amp;&amp; y == n) )&#123;<br>    <span class="hljs-built_in">dp</span>(x, y);<br>    x++;y++;<br>    <span class="hljs-keyword">if</span>(y &gt; n)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = ++cnt;<br>    &#125;<br>&#125;<span class="hljs-built_in">dp</span>(x, y);<br>cout&lt;&lt;c[<span class="hljs-number">1</span>][n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛</title>
    <link href="/2025/01/12/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E7%AD%9B/"/>
    <url>/2025/01/12/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举法">枚举法</h1><blockquote><p>暴力枚举法， 一般在查询很少的时候使用</p></blockquote><p>判断一个数 n 是否为质数的时间复杂度为<spanclass="math inline">\(O(\sqrt{n})\)</span></p><p>若询问m次，时间复杂度为 <spanclass="math inline">\(O(m\sqrt{n})\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= x ; i ++)&#123;<br><span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="埃式筛法">埃式筛法</h1><blockquote><p>Eratosthenes 筛法（埃拉托斯特尼筛法，简称埃氏筛法。</p></blockquote><p>建立一个&lt;=n的<spanclass="math inline">\(O(1)\)</span>查询表的时间复杂度是<spanclass="math inline">\(O(nloglogn)\)</span></p><p>原理：对于任意一个大于1的正整数，那么它的x倍就是非素数。如果从小到大遍历每个数，同时把当前数的所有倍数记为非素数，那么运行结束的时候没有被标记的数就是素数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= n ; i ++)&#123; <br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i ; j &lt;= n ; j += i)&#123;<span class="hljs-comment">//注意这里可以从i*i开始</span><br>isPrime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="欧拉筛法">欧拉筛法</h1><blockquote><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。</p><p>而欧拉筛法保证了一个合数只被最小的素因数标记，达到了线性的时间复杂度</p></blockquote><p>建立一个&lt;=n的<spanclass="math inline">\(O(1)\)</span>查询表的时间复杂度是<spanclass="math inline">\(O(n)\)</span></p><p>原理：从小到大遍历每个数，记录&lt;= i的非素数，将它们与 i的乘积（&lt;=n）标记为非素数，若i % it ==0，则直接break，因为后面还会有更大倍数标记这个乘积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    vector&lt;<span class="hljs-type">int</span> &gt; pri;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br>pri.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : pri)&#123;<br><span class="hljs-keyword">if</span>(i*it &gt; n) <span class="hljs-keyword">break</span>;<br>isPrime[i*it] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(i % it == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//关键</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>康托展开</title>
    <link href="/2025/01/12/%E6%A8%A1%E6%8B%9F/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <url>/2025/01/12/%E6%A8%A1%E6%8B%9F/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="康托展开">康托展开</h1><p>康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。<span class="math display">\[X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!\]</span> 其中, a[i]为整数，并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n,表示当前未出现的的元素中排第几个，这就是康托展开</p><p>举个例子说明。 在（1，2，3，4，5）5个数的排列组合中，计算34152的康托展开值。</p><p>首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为a[5]<em>(5-1)!第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2第三位是1，则在其之后小于1的数有0个，所以a[3]=0第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0根据公式： X = 2 </em> 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! = 2 * 24 +2 * 6 + 1 = 61 所以比 34152 小的组合有61个，即34152是排第62。</p><h1 id="八数码难题bfs剪枝">八数码难题（BFS剪枝）</h1><p><a href="https://www.luogu.com.cn/problem/P1379">P1379 八数码难题 -洛谷 | 计算机科学教育新生态</a></p><p>在 3×3 的棋盘上，摆有八个棋子，每个棋子上标有 1 至 8的某一数字。棋盘中留有一个空格，空格用 0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 状态结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> x,y,steps;<br><span class="hljs-type">int</span> ctVal;<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>&#125;;<br><br><span class="hljs-comment">// 0-10的阶乘</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> f[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-comment">// 某个排列是否出现过</span><br><span class="hljs-type">bool</span> visct[<span class="hljs-number">10000000</span>];<br><span class="hljs-comment">// 起点和终点</span><br>string s,t;<br><span class="hljs-type">int</span> tt;<br><br><span class="hljs-comment">// 康托展开</span><br><span class="hljs-comment">// 即将 某个排列 映射 到 某个数字（第几个排列）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>vis[s[i]-<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; s[i] - <span class="hljs-string">&#x27;0&#x27;</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[j]) low++;<br>&#125;<br>res += f[cnt--]*low;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;node&gt; q;<br><span class="hljs-comment">// 初始化起点</span><br>node temp;<br>temp.steps = <span class="hljs-number">0</span>;<br>temp.ctVal = <span class="hljs-built_in">cantor</span>(s);<br>visct[temp.ctVal] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>temp.a[i][j] = s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>temp.x = i;<br>temp.y = j;<br>&#125;<br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(temp);<br><br>tt = <span class="hljs-built_in">cantor</span>(<span class="hljs-string">&quot;123804765&quot;</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node fr = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 如果找到，退出</span><br><span class="hljs-keyword">if</span>(fr.ctVal == tt)&#123;<br>cout&lt;&lt;fr.steps;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>node nex; string str;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br>nex.x = fr.x + dirx[i];<br>nex.y = fr.y + diry[i];<br><span class="hljs-keyword">if</span>(!(nex.x &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.x &lt;= <span class="hljs-number">3</span> &amp;&amp; nex.y &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.y &lt;= <span class="hljs-number">3</span>)) <span class="hljs-keyword">continue</span>;<br>nex.steps = fr.steps + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memcpy</span>(nex.a,fr.a,<span class="hljs-built_in">sizeof</span>(nex.a));<br><span class="hljs-built_in">swap</span>(nex.a[fr.x][fr.y],nex.a[nex.x][nex.y]);<br>str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>str += <span class="hljs-built_in">char</span>(nex.a[i][j] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br>nex.ctVal = <span class="hljs-built_in">cantor</span>(str);<br><span class="hljs-comment">// 如果康托展开值重复，说明之前出现过更优解</span><br><span class="hljs-keyword">if</span>(!visct[nex.ctVal])&#123;<br>q.<span class="hljs-built_in">push</span>(nex);<br>visct[nex.ctVal] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
